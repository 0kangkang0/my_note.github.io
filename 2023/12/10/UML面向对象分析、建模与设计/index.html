<!-- build time:Sun Dec 10 2023 18:38:06 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="KangKang" href="https://blog.0kangkang0.top/rss.xml"><link rel="alternate" type="application/atom+xml" title="KangKang" href="https://blog.0kangkang0.top/atom.xml"><link rel="alternate" type="application/json" title="KangKang" href="https://blog.0kangkang0.top/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://blog.0kangkang0.top/2023/12/10/UML%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E3%80%81%E5%BB%BA%E6%A8%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1/"><title>UML面向对象分析、建模与设计 | kangkang = KangKang</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">UML面向对象分析、建模与设计</h1><div class="meta"><span class="item" title="创建时间：2023-12-10 15:23:43"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-12-10T15:23:43+08:00">2023-12-10</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">kangkang</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="/img/00039-3604723839.png"></li><li class="item" data-background-image="/img/00017-752649644.png"></li><li class="item" data-background-image="/img/00038-207222746.png"></li><li class="item" data-background-image="/img/00009-2312059879.png"></li><li class="item" data-background-image="/img/00013-1028390107.png"></li><li class="item" data-background-image="/img/00020-3349926000.png"></li></ul></div><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div></header><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.0kangkang0.top/2023/12/10/UML%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E3%80%81%E5%BB%BA%E6%A8%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="KangKang"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="KangKang"></span><div class="body md" itemprop="articleBody"><h1 id="软件工程与面向对象方法"><a class="anchor" href="#软件工程与面向对象方法">#</a> 软件工程与面向对象方法</h1><h2 id="软件工程"><a class="anchor" href="#软件工程">#</a> 软件工程</h2><p>软件的定义：<strong>软件</strong>是我们使用硬件设备的桥梁。我们可以把软件理解为，由程序、数据和文档构成的集合体</p><ul><li><strong>程序</strong>是能够完成预定功能和性能的一组计算机指令</li><li><strong>数据</strong>是程序在执行过程需要输入、处理和输出的内容和结构</li><li><strong>文档</strong>是描述程序设计和使用的部分</li></ul><p>软件工程的定义：软件工程（software engineering）是指应用计算机科学技术、数字和管理学的原理，运用工程学的理论、方法和技术，研究和知道软件开发和演化的一门交叉学科。</p><p><strong>软件工程的三个主要方面</strong>：</p><ul><li>软件工程目标</li><li>软件工程过程</li><li>软件工程的四条原则</li></ul><p><strong>软件工程的四条原则</strong>：</p><ul><li>开发模型</li><li>开发方法</li><li>工程支持</li><li>工程管理</li></ul><h3 id="软件工程的历史"><a class="anchor" href="#软件工程的历史">#</a> 软件工程的历史</h3><ul><li>20 世纪 60 年代以前，软件 “个体生产方式”</li><li>20 世纪 60 至 70 年代，软件奇数取得了很大的进展。软件应用的需求变多，规模变大，复杂程度变高。</li><li>软件的生产方式满足不了社会对软件的需求，最终导致 “软件危机” 的开始。</li><li>1968 年，在北大西洋公约组织举行的一次学术会议上，首次提出了 “软件工程” 的概念。</li></ul><h4 id="软件危机"><a class="anchor" href="#软件危机">#</a> 软件危机</h4><p><strong>定义</strong>：在计算机软件开发和维护中所遇到的一系列严重问题。</p><p><strong>造成软件危机的主要原因</strong>：</p><ul><li>用户需求不明确</li><li>软件本身的复杂性</li><li>软件维护和开发方法不正确</li></ul><p><strong>造成软件危机的主要表现</strong>：</p><ul><li>软件开发周期大大超过规定日期</li><li>软件开发成本严重超标</li><li>软件价格昂贵</li><li>软件可维护性差</li><li>软件质量难于保证</li></ul><h3 id="软件建模"><a class="anchor" href="#软件建模">#</a> 软件建模</h3><p><strong>定义</strong>：建模时构建模型的过程。是一项经过检验并被广为接受的工程技术</p><p><strong>目的</strong>：建模可以更好的理解正在开发分系统</p><p><strong>建模原理</strong></p><ul><li>选择合适的模型</li><li>可以在不同的精度级别上表示每一种模型</li><li>最好的模型与显示相联系的</li><li>LOREM IPSUM</li></ul><p><strong>普遍的建模方法</strong></p><ul><li>从算法的角度建模</li><li>从面向对象的角度建模</li></ul><h2 id="面向对象"><a class="anchor" href="#面向对象">#</a> 面向对象</h2><h3 id="面向对象方法简介"><a class="anchor" href="#面向对象方法简介">#</a> 面向对象方法简介</h3><p><strong>定义</strong>：面向对象是基于对象概念，以对象为中心，以类和继承为构造机制，来认识、理解、刻画客观世界和设计、构建相应的软件系统。</p><p><strong>面向对象技术</strong>：是一种以对象为基础，以事件或消息来驱动对象执行处理的程序设计技术。</p><p><strong>软件开发过程各阶段所应用的面向对象技术</strong></p><ul><li>面向对象的方法</li><li>面向对象的分析</li><li>面向对象的设计</li><li>面向对象的编程</li></ul><h3 id="面向对象发展历史"><a class="anchor" href="#面向对象发展历史">#</a> 面向对象发展历史</h3><ul><li>20 世纪 50 年代后期，ALGOL 语言首次提供封装（保护）的尝试。</li><li>1967 年，Simula 语言提出了对象的概念，并使用类，也支持类继承。第一门面向对象的编程语言。</li><li>20 世纪 70 年代，Smalltalk 语言诞生，它取 Simula 的类为核心概念。</li><li>1980 年，Xerox 公司推出商品化的 Smalltalk80，它在系统设计中强调对象概念的统一，引入对象、对象类、方法、示例等概念和术语，采用动态联编和单继承机制。</li><li>20 世纪 80 年代至 90 年代 Objective C、C++、Eiffel 和 CLOS 等语言大量涌现。C++ 语言的广泛应用，使得面向对象技术真正的从实验室阶段走到了商业化阶段。面向对象的软件工程迅速发展。</li><li>1986 年在美国举行了首届 “面向对象编程、系统、语言和应用（OOPSLA'86）” 国际会议，使面向对象受到世人瞩目。</li></ul><h3 id="面向对象方法的概念"><a class="anchor" href="#面向对象方法的概念">#</a> 面向对象方法的概念</h3><h4 id="对象"><a class="anchor" href="#对象">#</a> 对象</h4><p><strong>定义</strong>：客观世界中的事物都是对象（object），是一个属性（数据）集及其操作（行为）的封装体。</p><p><strong>三大分类</strong>：</p><ul><li>客观对象：现实中的实体</li><li>问题对象：抽象客观对象某些属性和方法来研究某个问题或场景中的性质</li><li>计算机对象：问题对象通过封装等过程称为计算机中的一个包含有数据和操作的集合体</li></ul><p><strong>四个特性</strong>：</p><ul><li>自治性</li><li>封闭性</li><li>通信性</li><li>被动性</li></ul><h4 id="类"><a class="anchor" href="#类">#</a> 类</h4><p><strong>定义</strong>：类是对象的模板。即类是对一组有相同数据和相同操作的对象的定义，一个类所包含的方法和数据描述一组对象的共同属性和行为。</p><p><strong>对类四个角度的理解</strong></p><ul><li>类是面向对象程序中的构造单位</li><li>类是面向对象程序设计语言的基本成分</li><li>类是抽象数据类型的具体表现</li><li>类刻画了一组相似对象的共同特性</li></ul><h4 id="抽象"><a class="anchor" href="#抽象">#</a> 抽象</h4><p>揭示一个事物区别于其他事物的本质特征，是从去除某一个角度看来不重要的细节行为。</p><h4 id="封装"><a class="anchor" href="#封装">#</a> 封装</h4><p>是一种信息隐蔽技术，对用户隐藏对象的属性和实现细节，仅对外公开接口，并控制在程序中属性的读和修改的访问级别。</p><h4 id="独立"><a class="anchor" href="#独立">#</a> 独立</h4><p>指对象是一个不可分割的整体，它继承了事物全部的属性和操作，并且它的存在不依赖于外部事物。</p><h4 id="封装-2"><a class="anchor" href="#封装-2">#</a> 封装</h4><p><strong>定义</strong>：指与外部的事物通信时，对象要尽量地隐藏其内部的实现细节，它的内部信息对外界来说是隐蔽的，外界不能直接访问对象的内部信息，而只能通过有限的接口与对象发生联系。</p><p><strong>功能</strong></p><ul><li>将对象的属性和行为结合成一个独立的单位。</li><li>隐蔽对象的内部细节，防止数据遭到破坏。</li></ul><h4 id="泛化"><a class="anchor" href="#泛化">#</a> 泛化</h4><p><strong>定义</strong>：是类元的一般描述和具体描述之间的关系。</p><ul><li>实现泛化关系的机制为继承。</li><li>继承性实现了软件模块的可重用性、独立性，缩短了开发周期，提高了软件开发的效率，同时使软件易于维护和修改。</li></ul><p><strong>多态</strong></p><p><strong>定义</strong>：指相同的操作可作用于多种类型的对象上并获得不同的结果。</p><ul><li>多态的前提是继承。</li><li>实现多态的二种方式：覆盖，重载。指相同的操作可作用于多种类型的对象上并获得不同的结果。</li></ul><h3 id="面向对象技术的优点"><a class="anchor" href="#面向对象技术的优点">#</a> 面向对象技术的优点</h3><ul><li>更符合人类的思维习惯。</li><li>提高软件稳定性。</li><li>提高代码的复用率。</li></ul><h1 id="uml"><a class="anchor" href="#uml">#</a> UML</h1><h2 id="uml的简介"><a class="anchor" href="#uml的简介">#</a> UML 的简介</h2><p><strong>定义</strong>：统一建模语言，是对软件密集型系统中的制品进行可视化、详述、构造和文档化的语言。</p><ul><li>UML 是一种可视化的语言</li><li>UML 是一种用于构造的语言</li></ul><h2 id="uml的历史"><a class="anchor" href="#uml的历史">#</a> UML 的历史</h2><p><strong>“方法大战”</strong>：</p><ul><li><strong>Booch</strong>: 在项目的设计和构造阶段的表达力极强。</li><li><strong>OMT</strong>: 对分析和数据密集型信息系统最为有用。</li><li>OOSE: 对以用例驱动需求获取、分析和高层设计的开发过程提供了极好的支持。</li></ul><p><strong>早期方法统一的尝试</strong>：Fushion 方法，结合了 OMT、Booch、CRC</p><p><strong>UML 的发展阶段</strong>：</p><ul><li>1996 年 6 月，三位创始人发布 UML 0.9。</li><li>1997 年 11 月，OMG 正式采纳 UML 1.1 作为建模语言规范。</li><li>2005 年 7 月，最终的 UML 2.0 规范发布。</li><li>2012 年，UML 2.4.1 被 ISO 正式确定为国际标准</li></ul><p><img data-src="/UML-image/image1.png" alt="UML发展阶段"></p><p><strong>UML2 的重大改变</strong></p><ul><li>大部分的类元都可以嵌套</li><li>行为建模进行了改进</li><li>改善了结构模型和行为模型之间的关系</li></ul><p><img data-src="/UML-image/image2.png" alt=""></p><h2 id="uml的目标与应用范围"><a class="anchor" href="#uml的目标与应用范围">#</a> UML 的目标与应用范围</h2><h3 id="uml的目标"><a class="anchor" href="#uml的目标">#</a> UML 的目标</h3><ul><li>为建模者提供可用、富有表达力、可视化的建模语言，以开发和交换有意义的模型。</li><li>提供可扩展性和特殊化机制以延申核心概念</li><li>支持独立于编程语言和开发过程的规范</li><li>为理解建模语言提供正式的基础</li><li>推动面向对象建模工具市场的增长</li><li>支持更高级的开发概念</li></ul><h3 id="uml的应用范围"><a class="anchor" href="#uml的应用范围">#</a> UML 的应用范围</h3><ul><li>UML 以面向对象的方式来描述系统</li><li>在需求分析阶段，可以通过用例捕获需求</li></ul><h1 id="初识uml"><a class="anchor" href="#初识uml">#</a> 初识 UML</h1><h2 id="uml构造块"><a class="anchor" href="#uml构造块">#</a> UML 构造块</h2><p>构造块（building block):UML 基本建模元素。</p><p><strong>构造块的类型：</strong></p><ul><li>事物（things): the abstractions of first-class citizens in a model．</li><li>关系（relationships):tying the things together</li><li>图（diagrams): grouping interesting collections of things</li></ul><h3 id="事物"><a class="anchor" href="#事物">#</a> 事物</h3><p><strong>事物</strong>：是对模型中关键元素的抽象。描述的是关键部件。<br><strong>事物分为</strong>：结构事物、行为事物、分组事物、注释事物。</p><h4 id="结构事物"><a class="anchor" href="#结构事物">#</a> <strong>结构事物</strong></h4><p>概念：描述模型的静态结构<br><strong>结构事物的分类</strong>：<br><img data-src="/UML-image/image3.png" alt=""></p><h5 id="类-2"><a class="anchor" href="#类-2">#</a> 类</h5><p>图形为多层矩形<br>包括：</p><ul><li>类名</li><li>属性</li><li>方法</li></ul><h5 id="接口"><a class="anchor" href="#接口">#</a> 接口</h5><p>图形为多层矩形<br>包括：</p><ul><li>接口名</li><li>方法</li></ul><h5 id="协作"><a class="anchor" href="#协作">#</a> 协作</h5><p>表示多个元素间的交互动作<br>图形为虚线椭圆<br>包括：协作名称</p><h5 id="用例"><a class="anchor" href="#用例">#</a> 用例</h5><p>图形为实线椭圆<br>包括：动作名称</p><h5 id="组件"><a class="anchor" href="#组件">#</a> 组件</h5><p>封装好的模块化部件，仅将外部接口暴露出来<br>图形为矩形框＋两个小矩形<br>包括：组件名称</p><h5 id="结点"><a class="anchor" href="#结点">#</a> 结点</h5><p>物理元素名称，如计算机资源<br>图形为立方体<br>包括：结点名称</p><h4 id="行为事物"><a class="anchor" href="#行为事物">#</a> 行为事物</h4><p>概念：描述模型中的动态元素，又称为动作事物。</p><p><strong>行为事物分类：</strong></p><ul><li><strong>交互（Interaction)</strong>：对象间消息交换的行为，或为完成指定目标而设置的相关规则。包含消息、状态和连接。</li><li><strong>状态机（state machine)</strong>：对象在生命周期内的状态序列及转移规则。包含状态、转移、条件（事物）和活动。</li><li><strong>活动（activity)</strong>：一个计算过程包含的动作（action）序列。</li></ul><h5 id="交互"><a class="anchor" href="#交互">#</a> 交互</h5><p>图形为实箭头，从发出者到接收者<br>包括：操作名称<br><img data-src="/UML-image/image4.png" alt=""></p><h5 id="状态机"><a class="anchor" href="#状态机">#</a> 状态机</h5><p>图形为圆角矩形<br>包括：状态名称<br><img data-src="/UML-image/image5.png" alt=""></p><h5 id="活动"><a class="anchor" href="#活动">#</a> 活动</h5><p>表示操作的过程信息<br>图形为圆角矩形<br>包括：活动名称<br><img data-src="/UML-image/image6.png" alt=""></p><h4 id="分组事物"><a class="anchor" href="#分组事物">#</a> 分组事物</h4><p>描述模型中的组织结构，用于组织设计本身，而非组织构建（constructs)。<br>分组事物包括：包（packages)、子系统 (subsystems)、层（layers)。</p><h5 id="包"><a class="anchor" href="#包">#</a> 包</h5><p>图形为小矩形＋大矩形<br>包括：</p><ul><li>名称</li><li>包含的元素<br><img data-src="/UML-image/image7.png" alt=""></li></ul><h4 id="注释事物annotation-things"><a class="anchor" href="#注释事物annotation-things">#</a> 注释事物（annotation things)</h4><p>模型中的注解元素，用于描述、说明和标注任何模型元素。<br><strong>注解（notes)</strong>：是最主要的注释事物实例，是对单个或一组元素进行约束或解释的文本。</p><h3 id="关系"><a class="anchor" href="#关系">#</a> 关系</h3><p>关系是模型元素之间具体化的语义连接。</p><h4 id="关联关系"><a class="anchor" href="#关联关系">#</a> 关联关系</h4><p>描述一个事物的对象与另一个事物的对象的联系，表示一种结构关系。关联关系包括聚合和组合。</p><h5 id="聚合aggregations"><a class="anchor" href="#聚合aggregations">#</a> 聚合（aggregations)</h5><p>概念：整体与局部的包含、从属关系。在 UML 中使用带空心菱形的实心线表示，菱形指向整体。<br><img data-src="/UML-image/Pasted%20image%2020231207192450.png" alt=""></p><h5 id="组合composition"><a class="anchor" href="#组合composition">#</a> 组合（composition)</h5><p>概念：强依赖的特殊聚合关系。在 UML 中带使用实心菱形的实线表示，菱形指向整体。<br><img data-src="/UML-image/Pasted%20image%2020231207192656.png" alt=""></p><h4 id="依赖关系"><a class="anchor" href="#依赖关系">#</a> 依赖关系</h4><p>一个元素（independent element）的变化影响另一元素的语义。</p><p><strong>依赖关系代表：</strong></p><ul><li>带箭头的虚线，箭头指向被使用者。</li><li>表示一种使用的关系。<br><img data-src="/UML-image/Pasted%20image%2020231207193058.png" alt=""></li></ul><h4 id="泛化关系"><a class="anchor" href="#泛化关系">#</a> 泛化关系</h4><p>描述特殊到一般的归纳和分类关系。</p><p><strong>泛化关系代表：</strong></p><ul><li>带三角箭头的实线，箭头指向父类。</li><li>继承关系（inherit)：指定了子类如何特化父类的所有特征和行为。<br><img data-src="/UML-image/Pasted%20image%2020231207193601.png" alt=""></li></ul><h4 id="实现关系realization"><a class="anchor" href="#实现关系realization">#</a> 实现关系（realization):</h4><p>一个元素定义规格说明，另一元素按照规格具体实现。</p><p><strong>实现关系代表：</strong></p><ul><li>带三角箭头的虚线，箭头指向接口。</li><li>接口与实现接口功能的类或组件。</li><li>用例与实现该用例的协作<br><img data-src="/UML-image/Pasted%20image%2020231207193816.png" alt=""></li></ul><h3 id="图diagram"><a class="anchor" href="#图diagram">#</a> 图（diagram)</h3><p>一组模型元素的图形化表示，一般由事物与各种关系构成。</p><p><strong>图的类型：</strong></p><p><strong>结构图</strong>：捕获事物与事物之间的静态关系，用来描述系统的静态结构模型。</p><p><strong>行为图</strong>：捕获事物的交互过程如何产生系统的行为，用来描述系统的动态行为模型。<br><img data-src="/UML-image/Pasted%20image%2020231207194150.png" alt=""></p><p><img data-src="/UML-image/Pasted%20image%2020231207194240.png" alt=""></p><p><img data-src="/UML-image/Pasted%20image%2020231207194342.png" alt=""></p><table><thead><tr><th><strong>UML1.4</strong></th><th><strong>UML2</strong></th><th><strong>对比说明</strong></th></tr></thead><tbody><tr><td></td><td>包图</td><td>用于展示由模型本身分解而成的组织单元以及他们的依赖关系，展示了软件系统的分层结构。</td></tr><tr><td>状态图</td><td>状态机图</td><td>只是名称不同，技术上完全相同。</td></tr><tr><td>活动图</td><td>活动图</td><td>UML2 的活动图独立于状态机存在。</td></tr><tr><td></td><td>组合结构图</td><td>显示结构化类元或协作的内部结构，和普通类图之间没有严格界限。</td></tr><tr><td></td><td>外廊图</td><td>展示构造型、元类等扩展机制的结构。</td></tr><tr><td>协作图</td><td>通信图</td><td>UML2 中多用更加精确的通信图来代替协作图的大部分功能。</td></tr><tr><td></td><td>交互概览图</td><td>活动图的变体，合并了序列图片段和控制流构造。</td></tr><tr><td></td><td>时间图</td><td>是一种特殊的序列图形式，显式地表示了生命线上的状态变化和标度时间。</td></tr></tbody></table><h2 id="通用机制"><a class="anchor" href="#通用机制">#</a> 通用机制</h2><p><strong>作用</strong>：用于对建模元素进行补充，从而完善 UML 的语义表达。</p><ul><li>建模可以遵循不同的模式 —— 建筑具有不同的风格。</li><li>模型的 “风格” 与 “模式” 必须进行补充语义说明。</li></ul><p>UML 提供四种通用机制：规格说明、修饰、通用划分、扩展机制</p><h3 id="规格说明-specifications"><a class="anchor" href="#规格说明-specifications">#</a> 规格说明 (Specifications):</h3><p>概念：文本维度的模型描述。</p><ul><li>规格说明使可视化视图和文字视图的分离。</li><li>规格说明通常不在图中直接显示， 而是通过工具来获得。</li></ul><p><img data-src="/UML-image/Pasted%20image%2020231209150115.png" alt=""></p><h3 id="修饰adornments"><a class="anchor" href="#修饰adornments">#</a> 修饰 (Adornments)</h3><p>描述建模元素的细节信息。</p><ul><li>修饰是对规格说明的文字的或图形的表示。</li></ul><p><img data-src="/UML-image/Pasted%20image%2020231209150212.png" alt=""></p><h3 id="通用划分1commondivisions"><a class="anchor" href="#通用划分1commondivisions">#</a> 通用划分 (1CommonDivisions):</h3><ul><li>建模时对事物的划分方法。 是一种保证不同抽象层次建模的机制。</li></ul><p><strong>通用划分的类型：</strong></p><ul><li>类型与实例、 接口与实现、 用例与协作、 类型与角色。<br><img data-src="/UML-image/Pasted%20image%2020231209150323.png" alt=""></li></ul><h4 id="类型-实例type-instance"><a class="anchor" href="#类型-实例type-instance">#</a> 类型－实例 (type-instance)</h4><p>通用描述与某个特定元素的对应。</p><ul><li>类型：通用元素。</li><li>实例：特定元素。</li><li>例：类／对象 、 用例／场景 、 组件／组件实例、 节点／节点实例<br><img data-src="/UML-image/Pasted%20image%2020231209150548.png" alt=""></li></ul><h4 id="接口-实现-interf-aces-imp-i-e-mentati-on"><a class="anchor" href="#接口-实现-interf-aces-imp-i-e-mentati-on">#</a> 接口－实现 (interf aces-imp I e mentati on)</h4><p>强制规范与实现的对应。</p><ul><li>接口：声明了服务的约定， 行为的契约。</li><li>实例：负责执行接口的全部语义井实现该项服务。</li><li>例：接口／类 、 用例／协作、 操作／方法</li></ul><p><img data-src="/UML-image/Pasted%20image%2020231209150640.png" alt=""></p><h3 id="扩展机制extensibility-mechanisms"><a class="anchor" href="#扩展机制extensibility-mechanisms">#</a> 扩展机制 (Extensibility Mechanisms)</h3><p><strong>类型：</strong></p><ul><li>构造型 (stereotype) : 基千已有的建模元素引入新的建模元素。</li><li>标记值 (tagged value) : 扩展 UML 构造型的特性， 可以用来创建构造型的详述信息。</li><li>约束 (constraint) : 扩展 UML 构造块的语义， 可以用来增加新的规则或修改现有的规则。</li></ul><p><img data-src="/UML-image/Pasted%20image%2020231209150827.png" alt=""></p><h4 id="构造型"><a class="anchor" href="#构造型">#</a> 构造型</h4><ul><li>将一个已有的元素模型进行修改或精化， 创造出一种新的模型元素。</li><li>构造型的信息内容和形式与已存在的基本模型元素相同， 但拥有不同的含义与用法。</li><li>表示方法：一个双尖括号内附构造型名称，一般放在已有的基本模型元素符号上方。</li></ul><p><img data-src="/UML-image/Pasted%20image%2020231209150950.png" alt=""></p><h4 id="标记值"><a class="anchor" href="#标记值">#</a> 标记值</h4><p>关于模型元素本身的一个属性的定义， 即一个元属性的定义。 是用来为事物添加新特性、 新信息。</p><p>标记定义被构造型所拥有。 标记可以用来存储元素的任意信息， 它是一个名称－值组合 ， 表现为形如 “property = value&quot; 的字符串形式。</p><p><img data-src="/UML-image/Pasted%20image%2020231209151106.png" alt=""></p><h4 id="约束"><a class="anchor" href="#约束">#</a> 约束</h4><p>使用某种文本语言中的陈述句表达的语义条件或者限制。 是施加在元素上的限制。</p><ul><li>约束包括一个约束体与一种解释语言。</li><li>约束使用大括号｛｝中的文本串表示。</li><li><img data-src="/UML-image/Pasted%20image%2020231209151156.png" alt=""></li><li>若要精确地详述约束， 可以使用 UML 的对象约束语言 (ObjectConstraint Language , OCL) 来表达。</li><li><img data-src="/UML-image/Pasted%20image%2020231209151239.png" alt=""></li></ul><h2 id="41架构"><a class="anchor" href="#41架构">#</a> &quot;4+'1&quot; 架构</h2><h3 id="41架构的概念和组成"><a class="anchor" href="#41架构的概念和组成">#</a> &quot;4+'1&quot; 架构的概念和组成</h3><p><strong>组成：</strong></p><ul><li>逻辑视图 (LogicalView)</li><li>过程视图 (ProcessView)</li><li>物理视图 (PhysicalView)</li><li>开发视图 (DevelopmentView)</li><li>场景视图 (ScenariosView))</li></ul><p><strong>概念</strong>：</p><ul><li>RUP 统一软件开发过程，是一个面向对象且基于网络的程序开发方法论。RUP 是 Rational 软件公司创造的软件工程方法，后来 Rational 公司被 IBM 井购。</li><li>&quot;4+1&quot; 架构方法采用用例驱动，在软件生命周期的各个阶段对软件进行建模， 从不同视角对系统进行解读， 从而形成统一软件过程架构描述</li></ul><h4 id="逻辑视图-l1ogic-view"><a class="anchor" href="#逻辑视图-l1ogic-view">#</a> 逻辑视图 (L1og'ic View)</h4><p>主要用来描述系统的功能需求 ， 反应出系统内部是如何组织和协作来实现功能的，不涉及具体的编译即输出和部署。</p><p><strong>主要对应 UML 中的类图和对象图。</strong></p><ul><li>构件：类、 类服务、 参数化类。</li><li>连接件：关联、 包含、 使用、 继承、实例化。</li></ul><p><img data-src="/UML-image/Pasted%20image%2020231209151816.png" alt=""></p><h4 id="开发视图developmentmodule-view"><a class="anchor" href="#开发视图developmentmodule-view">#</a> 开发视图（Development/Module View）</h4><p>主要用来描述软件模块的组织与管理（通过程序库或子系统）。</p><p>主要对应 UML 中的组件图。</p><p>・	构件：模块、 子系统、 层。<br>・	连接件：参照相关性、 模块／过程调用。</p><p><img data-src="/UML-image/Pasted%20image%2020231209151956.png" alt=""></p><h4 id="进程视图-pro1cessview"><a class="anchor" href="#进程视图-pro1cessview">#</a> 进程视图 (Pro1cess'View)</h4><p>主要描述系统的运行特性， 侧重系统的性能和稳定性， 主要关注进程、线程、 对象、 井发、 同步、 通信等运行时概念。 服务千系统集成人员 ， 方便后续性能测试。</p><p>主要对应 UML 中的顺序图、 协作图、 状态机图。</p><p><img data-src="/UML-image/Pasted%20image%2020231209152032.png" alt=""></p><ul><li>构件：进程、 简化进程、 循环进程。</li><li>连接件：未指定， 消息、 远程过程调用 (RPC) 、双向消息、 事件广播。</li></ul><h4 id="物理视图physicalview"><a class="anchor" href="#物理视图physicalview">#</a> 物理视图 (Physicalview)</h4><p>主要描述硬件配置。 服务千系统工程人员 ， 解决系统的拓扑结构、 系统安装、通信等问题。</p><p><strong>主要对应 UML 中的部署图。</strong></p><ul><li>构件：处理器、 计算机、 其它设备。</li><li>连接件：通信协议。</li></ul><p><img data-src="/UML-image/Pasted%20image%2020231209152156.png" alt=""></p><h4 id="场景视图scenarios-view"><a class="anchor" href="#场景视图scenarios-view">#</a> 场景视图（Scenarios View）</h4><p>用于刻画构件之间的相互关系， 将四个视图有机地联系起来。</p><p><strong>主要对应 UML 中的用例图和活动图。</strong></p><ul><li>构件：用例、 活动等。</li><li>连接件：关联、 泛化、 依赖等。</li></ul><p><img data-src="/UML-image/Pasted%20image%2020231209152325.png" alt=""></p><h4 id="视图间的关系"><a class="anchor" href="#视图间的关系">#</a> 视图间的关系：</h4><ul><li>逻辑视图， 设计的对象模型（使用面向对象的设计方法时）。</li><li>进程视图， 捕捉设计的井发和同步特征。</li><li>物理视图， 描述了软件到硬件的映射， 反映了分布式特性。</li><li>开发视图， 描述了在开发环境中软件的静态组织结构。</li><li>场景视图， 描述最终用户需求，为整个技术架构的上线文环境。</li></ul><p><img data-src="/UML-image/Pasted%20image%2020231209152404.png" alt=""></p><h3 id="运用41架构"><a class="anchor" href="#运用41架构">#</a> 运用 “4+1” 架构</h3><p><strong>步骤</strong></p><ol><li>分而治之，其策略有分层法、模块法等。</li><li>对于模块化而言，对于每个模块实行不同的较为单一的操作，透明化模块内部的信息，是一种重要的方法论。</li><li>“4+1” 视图方法是一种架构设计的多重视图方法，属于一种特殊的模块法。</li></ol><p>&quot;4+1&quot; 视图方法特点有：用例驱动、 以架构为中心、 迭代和增量过程。</p><ul><li>首要问题：需求</li><li>首要问题：需求</li></ul><h4 id="场景视图"><a class="anchor" href="#场景视图">#</a> 场景视图</h4><p>场景视图是根据用户的需求可以直接产生和描述， 它是与需求关系最紧密的视图。</p><h4 id="逻辑视图"><a class="anchor" href="#逻辑视图">#</a> 逻辑视图</h4><ul><li>找到场景中的所有关键交互；</li><li>使用软件术语描述出交互逻辑， 注意一些场景可能是基千事件的；</li><li>设计一些更下层的元素， 这些元素的合理组合可以最终实现这个场景。<br><img data-src="/UML-image/Pasted%20image%2020231209152949.png" alt=""></li></ul><h4 id="开发视图"><a class="anchor" href="#开发视图">#</a> 开发视图</h4><p>开发视图关注各种程序包的使用， 进程视图关注运行时概念， 物理视图关注程序和运行库、软件系统对物理机器的要求和配合方式。</p><h1 id="用例图"><a class="anchor" href="#用例图">#</a> 用例图</h1><h2 id="用例图简介"><a class="anchor" href="#用例图简介">#</a> 用例图简介</h2><ul><li>表现一个系统中用例、 参与者以及它们之间关系的图。</li><li>用例图＝ 参与者 ＋用例＋ 关系。</li><li>用例图是系统的蓝图。 它从用户的视角来描述和建模整个系统， 分析系统的功能与行为。</li></ul><p><strong>用例图主要回答</strong></p><ul><li>谁在使用软件系统。</li><li>软件系统提供了什么祥的功能。</li><li>用例图侧重千表示系统向外界提供哪些功能与服务， 而非具体实现。</li><li>作为整个系统开发过程中的开发依据，用于指导和驱动其它模型。</li></ul><p><strong>用例图的功能与作用</strong></p><ul><li>描述系统环境（上下文）：确定系统边界、 参与者。</li><li>捕获井描述用户需求： 确定用例、 用例与参与者间关系。</li></ul><p><img data-src="/UML-image/Pasted%20image%2020231209153424.png" alt=""></p><h2 id="用例图的组成元素"><a class="anchor" href="#用例图的组成元素">#</a> 用例图的组成元素</h2><p>用例图主要由参与者、 用例、 关系构成， 还可以有注解、 约束以及包。</p><h3 id="参与者actorrole"><a class="anchor" href="#参与者actorrole">#</a> 参与者（actor/role）</h3><p><strong>参与者</strong>是与系统主体交互的外部实体类元。 参与者以某种方式参与系统中若干用例的执行， 体现了用户对系统功能的使用。<br><img data-src="/UML-image/Pasted%20image%2020231209153554.png" alt=""></p><ul><li>参与者处千系统边界之外， 不作为系统的一部分。</li><li>参与者是客观世界中人或事物的抽象。</li></ul><h4 id="确定参与者"><a class="anchor" href="#确定参与者">#</a> 确定参与者</h4><p><strong>作用</strong>：通过对参与者进行分析， 可以步的确定系统边界。</p><h5 id="参与者的确定从类别角度"><a class="anchor" href="#参与者的确定从类别角度">#</a> 参与者的确定：从类别角度</h5><ul><li>为系统提供输入／输出的人或物；</li><li>需要接入的第三方系统或设备；</li><li>触发系统事件的因素（时间）；</li><li>负责支持／维护系统的人员。<br><img data-src="/UML-image/Pasted%20image%2020231209153736.png" alt=""></li></ul><h5 id="参与者的确定从角色角度"><a class="anchor" href="#参与者的确定从角色角度">#</a> 参与者的确定：从角色角度</h5><ul><li>主要业务参与者：用例执行中的获益者。</li><li>主要系统参与者：用例的直接交互者。</li><li>外部服务参与者：对用例请求的响应者。</li><li>外部接收参与者：用例产出信息的非主要关联人员。<br><img data-src="/UML-image/Pasted%20image%2020231209153834.png" alt=""></li></ul><h4 id="系统边界"><a class="anchor" href="#系统边界">#</a> 系统边界</h4><p>界定系统的功能范围。</p><p>系统用一个长方框表示， 边几位系统边界， 系统的名字写在方框上或方框里面。</p><p><img data-src="/UML-image/Pasted%20image%2020231209153935.png" alt=""></p><h3 id="用例use-case"><a class="anchor" href="#用例use-case">#</a> 用例（use case）</h3><p>也称为用况：是系统提供的一个内聚的功能单元或服务；该单元对应一组动作序列的执行， 井向参与者提供可观测的结果。</p><ul><li>用例表示：实线椭圆形。名称在椭圆中。</li><li>用例命名方式：简单命名和受限命名。<br><img data-src="/UML-image/Pasted%20image%2020231209154101.png" alt=""></li></ul><p><strong>用例的作用：</strong></p><ul><li>捕获和描述用户需求。 用例描述目标系统的应用场景， 进而捕获和、描述用户需求。</li><li>定义系统的行为。 用例定义系统的行为， 表示系统所提供的服务。但不涉及内部结构与实现细节。</li><li>用例是外部观察者 “看到 “的系统服务， 而非内部观察者定义的功能。</li></ul><h3 id="用例与参与者"><a class="anchor" href="#用例与参与者">#</a> 用例与参与者</h3><ul><li>用例与参与者之间存在关联关系。</li><li>一个用例可以隶属一个或多个参与者，一个参与者也可以参与一个或多个用例。<br><img data-src="/UML-image/Pasted%20image%2020231209154243.png" alt=""></li></ul><p><strong>通过参与者入手来寻找用例：</strong></p><ul><li>参与者的主要任务是什么？</li><li>参与者需要系统的什么信息？</li><li>参与者可以为系统提供什么信息？</li><li>系统需要通知参与者发生的变化和事件吗？</li><li>参与者需要通知系统发生的变化和事件吗？</li></ul><p><strong>用例的特征</strong></p><ul><li>用例是动宾短语。</li><li>用例是相对独立的。</li><li>用例是由参与者启动的。</li><li>用例要有可观测的执行结果。</li><li>一个用例是一个单元。<br><img data-src="/UML-image/Pasted%20image%2020231209154500.png" alt=""></li></ul><p>用例的特征保证用例能够正确地捕捉功能性需求， 同时也是判断用例是否准确的依据。</p><p><strong>用例的粒度 (granularity)</strong> : 用例组织信息的方式和细化程度。<br><strong>原则</strong>：业务建模阶段：每个用例对应一个完整的服务。</p><p><strong>概念建模阶段</strong>：每个用例对应一个完整的事件流。 如第二个图， “修改个人信息” 的粒度相对粗。<br><strong>系统建模阶段</strong>：每个用例对应一个完整的交互。 如第一个图，“修改密码 “的粒度相对细致。<br><img data-src="/UML-image/Pasted%20image%2020231209154652.png" alt=""></p><p><strong>参与者的泛化关系</strong>：</p><ul><li>当系统中的几个参与者既扮演自身的角色， 同时也有更一般化的角色时， 可以通过建立泛化关系来进行描述。<br><img data-src="/UML-image/Pasted%20image%2020231209154744.png" alt=""></li><li>如果父参与者是抽象的， 可以用斜体表示， 这是父参与者必须明确相应的子参与者。<br><img data-src="/UML-image/Pasted%20image%2020231209154826.png" alt=""></li></ul><p><strong>参与者与用例间的关联关系</strong>：参与者与用例间的信息交互（消息、 调用）。<br><img data-src="/UML-image/Pasted%20image%2020231209154901.png" alt=""></p><p><strong>用例间关系</strong>：</p><ul><li>泛化 generalization)</li><li>依赖 (depende1ncy)<br><img data-src="/UML-image/Pasted%20image%2020231209154913.png" alt=""></li></ul><p><strong>用例间的泛化关系 (generalization)</strong></p><ul><li>子用例继承父用例的行为和属性，子用例可增加或替换父用例行为。</li><li>子用例的实例可替代父用例实例 ，父用例同样可以定义为抽象用例。<br><img data-src="/UML-image/Pasted%20image%2020231209155029.png" alt=""></li></ul><p><strong>依赖（dependency ）</strong></p><ul><li>包含 (include)</li><li>扩展 (extend)</li></ul><p><strong>包含关系 (include)</strong></p><ul><li>一个用例（基用例）包含其他用例（包含用例）的行为。</li><li>基用例一定要使用包含用例 ， 而且是无条件的使用。</li><li>包含关系用千描述复用：多个基用例复用一个包含用例。</li><li>包含关系中 ， 基用例与包含用例间有明显的整体 — 局部关系， 不具有可替代性。<br><img data-src="/UML-image/Pasted%20image%2020231209155203.png" alt=""><br><strong>作用：</strong></li><li>提供用例的利用率。</li><li>提高用例模型维护的效率。</li></ul><p><strong>扩展关系（extend）</strong><br>一个用例（扩展用例）对另一个用例（基用例）行为的增强。</p><ul><li>基用例对千扩展的存在不知情。</li><li>扩展用例的执行是有条件的。</li></ul><p><strong>扩展用例的使用包括</strong>：基用例 、 扩展用例 、 扩展关系 、 扩展点。</p><ul><li>扩展点表示基用例中的一个或多个位置， 表示在该位置会根据某条件来决定是否要中断基用例的执行从而执行扩展用例中的片段。<br><img data-src="/UML-image/Pasted%20image%2020231209155458.png" alt=""></li></ul><p><strong>包含关系与扩展关系的区别</strong></p><table><thead><tr><th>特征</th><th>include</th><th>extend</th></tr></thead><tbody><tr><td>作用</td><td>增强基用例的行为</td><td>增强基用例的行为</td></tr><tr><td>执行过程</td><td>包含用例一定会执行</td><td>扩展用例可能被执行</td></tr><tr><td>对基用例的要求</td><td>在没有包含用例的情况下， 基用例可以是也可以不是良构的</td><td>在没有扩展用例的情况下， 基用例一定是良构的</td></tr><tr><td>表示法</td><td>箭头指向包含用例</td><td>箭头指向基用例</td></tr><tr><td>基用例对增强行为的可见性</td><td>基用例可以看到包含用例， 井决定包含用例的执行</td><td>基用例对扩展用例一无所知</td></tr><tr><td>基用例每执行一次，增强行为的执行次数</td><td>只执行一次</td><td>取决于条件（0 到多次）</td></tr></tbody></table><h2 id="用例描述与文档"><a class="anchor" href="#用例描述与文档">#</a> 用例描述与文档</h2><h3 id="什么是用例描述"><a class="anchor" href="#什么是用例描述">#</a> 什么是用例描述</h3><p>用例描述， 通过文字详细的描述用例的细节内容， 全面表达用户需求和系统功能。</p><p><strong>用例描述的主要内容</strong></p><ul><li>用例名称</li><li>用例编号</li><li>参与者</li><li>用例描述</li><li>触发器</li><li>前置条件</li><li>基本事件流</li><li>扩展事件流</li><li>结论</li><li>后置条件</li><li>补充约束</li></ul><p><strong>用例描述的主要内容</strong></p><ul><li>用例名称：描述用例的意图或实现的目标。</li><li>用例编号：用例的唯一标识符， 在其他位置可以使用该标识符来引用用例。</li><li>参与者：描述用例的参与者， 包括主要参与者和其他参与者。</li><li>用例描述：对用例的一段简单的概括描述。</li><li>触发器：触发用例执行的一个事件。</li><li>前置条件：用例执行前， 系统和参与者应处的状态， 是用例得以执行的必要条件。</li><li>后置条件：用例执行结束后系统所处的状态， 以及明确的结果（反馈给参与者）。</li></ul><h3 id="事件流"><a class="anchor" href="#事件流">#</a> 事件流</h3><p>在特定场景下系统与参与者与交互过程的抽象， 包括用例何时以及怎样开始和结束，用例如何与参与者交互 ， 该过程的基本流和可选择的流。</p><p><strong>事件流需要说明</strong></p><ul><li>用例因何开始、 何时开始</li><li>用例何时与用户交互</li><li>用例与用户交换了什么信息</li><li>用例与外部交互的行为流程</li></ul><p><strong>分类</strong></p><ul><li>基本事件流</li><li>扩展事件流</li></ul><h4 id="基本事件流"><a class="anchor" href="#基本事件流">#</a> 基本事件流</h4><p>用例中最核心的、 大部分时间所进行的 ， 最理想的执行场景。<br>&quot;S-&quot; 表示 subflow。</p><ol><li>参与者将订单信息提交至系统。</li><li>系统验证用户信息及订单信息合法后作出响应。</li><li>对千订单中的每种产品， 系统根据订单中的数昼检查产品库存数 m。 4 系统统计订单中产品的总价格。</li><li>系统从会员的系统账户余额中扣除相应金额。</li><li>系统生成井保存订单信息并将订单发送至分销中心。</li><li>系统生成订单确认页面井发送给会员。</li></ol><h4 id="可选事件流"><a class="anchor" href="#可选事件流">#</a> 可选事件流</h4><p>记录基本事件流出现异常或变化时的用例行为。 表示分支的、 异常情况下的、 备选的执行步骤。 用 &quot;A-&quot; 表示。</p><p>A-2 如果订单信息非法， 系统通知会员井提示重新提交订单。<br>A-3 如果订单中产品数量超过产品库存昼， 则提示会员库存不足， 暂无法购买， 取消订单同时终止用例。<br>A-5 如果会员账户余额不足， 系统给出相应提示， 取消订单井终止用例。</p><h3 id="结论与补充约束"><a class="anchor" href="#结论与补充约束">#</a> 结论与补充约束</h3><p>补充约束：用来描述用例在系统功能之外的内容。</p><ul><li>数据需求 (D -) : 用例相关数据项的说明</li><li>业务规则 (B -) : 业务相关的逻辑和操作规则</li><li>非功能性需求：性能、 时效、 稳定性等指标</li><li>设计约束：与后期分析、 设计相关的一些约定</li></ul><p>D-1 订单信息包括订单号、 参与者的会员账户名、 商品种类数量、商品种类名称以及每种商品的数量。<br>B-1 只有当订单中商品信息确认无误后才能要求会员进行支付。</p><h2 id="使用用例图建模"><a class="anchor" href="#使用用例图建模">#</a> 使用用例图建模</h2><p><strong>对系统的用例视图建模方式</strong></p><ul><li>对系统的语境建模</li><li>对系统的需求建模</li></ul><h3 id="对系统的语境建模"><a class="anchor" href="#对系统的语境建模">#</a> 对系统的语境建模：</h3><p>主要是为了说明参与者的身份 、 以及他所扮演角色的含义。</p><p><strong>对系统的语境建模遵循的策略</strong></p><ul><li>识别系统边界。</li><li>识别参与者。</li><li>如果需要 ， 将具有相同特征的参与者使用泛化关系加以组织。</li><li>如果需要 ， 对某些参与者应用 一个构造型以便加深理解。</li><li>识别参与者。 针对某个参与者 ， 考虑其期望系统提供的行为或与系统的交互。</li><li>提炼用例。 将系统行为提炼成用例。</li><li>完善其他用例。 分解用例中的公共行为与扩展行为。</li><li>创建用例图。 如果需要 ， 在用例图中添加一些注解或约束来陈述系统的非功能需求。</li></ul><p><strong>用例图构建需要注意以下要点：</strong></p><ul><li>用例图中应该只包含对系统而言必不可少的用例与相关参与者。</li><li>用例的名称不应该简化到使读者误解其主要语义的程度。</li><li>摆放元素时应尽量减少连接线的交叉 ， 以提供更好的可视化效果。</li><li>组织元素时应使在语义上接近的用例和参与者在位置上也同样接近 ， 便千读者理解用例图。</li><li>可以使用注解或给元素添加颜色等方式突出图中相对重要的内容。</li><li>用例图中不应该有太多的关系种类。</li></ul><h1 id="类图class-diagram"><a class="anchor" href="#类图class-diagram">#</a> 类图（class diagram）</h1><h2 id="类图的简介"><a class="anchor" href="#类图的简介">#</a> 类图的简介</h2><ul><li>类图是显示一组类、 接口 、 协作以及它们之间关系的图。</li><li>通过系统中的类以及各个类之间的关系来描述系统的静态结构。</li></ul><p><strong>类图的功能与作用：</strong></p><ul><li><p>系统开发模型的核心模型。</p></li><li><p>实现系统功能的静态结构建模。</p></li><li><p>是通过正向和逆向工程构建可执行系统的基础。</p></li><li><p>*<strong> 正向工程</strong>：通过语言间的映射将模型转换为代码的过程。</p></li><li><p><strong>逆向工程</strong>：通过语言间的映射将代码转换为模型的过程。</p></li></ul><h2 id="类图的组成元素"><a class="anchor" href="#类图的组成元素">#</a> 类图的组成元素</h2><h3 id="类-3"><a class="anchor" href="#类-3">#</a> 类</h3><p>拥有相同属性、 操作、 方法、 关系和行为（语义）的一组对象的抽象。</p><p><strong>类的特征主要有三个</strong></p><ul><li>名称， 由字符串进行唯一表示。</li><li>状态， 由属性和关联来描述。</li><li>行为， 由操作来实现。</li></ul><h4 id="类名"><a class="anchor" href="#类名">#</a> 类名</h4><p>用千区别其他类的字符串， 命名应来自问题域的词汇表。</p><ul><li>简单名 (simplename)</li><li>限制名 (qualified name)<br><img data-src="/UML-image/Pasted%20image%2020231209161644.png" alt=""></li></ul><h4 id="属性"><a class="anchor" href="#属性">#</a> 属性</h4><p>描述了类的所有对象所共有的一些特性。 表达了特性的实例可以取值的范围。</p><p><strong>语法</strong>：可见性<sub> opt</sub> 属性名 ⌊ : 类型⌋<sub>opt</sub> 多重性。<sub>opt</sub> ⌊= 初始值⌋<sub>opt</sub> ⌊{特性}⌋<sub>opt</sub><br><strong>可见性</strong>：访问范围 (public,protected,private,package/implementation)<br><img data-src="/UML-image/Pasted%20image%2020231209162417.png" alt=""></p><p><strong>属性名</strong>：属性的标识。<br><strong>类型</strong>：决定属性所以可能取值的范围。<br><strong>初始值</strong>：作为创建该类对象是这个属性的默认值。<br><strong>多重性</strong>：数组。<br><strong>特性</strong>：｛可变性的约束｝<br>可变 (changeable) 、单增 (addonly) 、冻结 (frozen) 。<br>例如： Pl: 3.14 {frozen}<br><img data-src="/UML-image/Pasted%20image%2020231209162546.png" alt=""></p><h4 id="操作operationfunction"><a class="anchor" href="#操作operationfunction">#</a> 操作 (operation&amp;function)</h4><p>由类定义 ， 被类的任一对象请求的服务。</p><p><strong>语法</strong><br>可见性<sub> opt</sub> 操作名⌊(参数列表）⌋<sub>opt</sub>⌊: 返回类型⌋<sub>opt</sub>⌊{特性｝⌋<sub>opt</sub></p><ul><li><strong>可见性</strong>：访问范围 (public,protected,private,package/implementation)。</li><li><strong>操作名</strong>：操作的标识符。</li></ul><p><strong>参数列表</strong>：是一些按照顺序排列的属性定义了操作的输入。<br><strong>返回类型</strong>：回送调用对象消息的类型。</p><p><strong>特征</strong>：｛约束说明｝</p><ul><li>抽象 (abstract) : 无实现。</li><li>叶子 (leaf) : 不能在派生类中重写此操作。</li><li>查询 (isQuery) : 不会改变系统状态。</li><li>顺序 (sequential) : 要求外部互斥访问该操作， 不支持多控制流。</li><li>监护 (guarded): 被声明为监护特征的操作， 可保证多控制流访问的顺序性（互斥）以及对象的语义正确及完整性（互斥性由外部线程间合作保证）。</li><li>并发 (concurrent): 操作是原子性的， 支持多控制流井发访问（互斥性由类提供）。</li><li>静态 (static): 对同类多个对象， 具有全局性（不区分具体对象）。</li></ul><h4 id="职责"><a class="anchor" href="#职责">#</a> 职责</h4><p>职责是类的契约或责任。 采用自由形式的文本表示， 不是必须项目。 主要说明类要负责的工作。<br><img data-src="/UML-image/Pasted%20image%2020231209163000.png" alt=""></p><h3 id="接口-2"><a class="anchor" href="#接口-2">#</a> 接口</h3><p>是一个被命名的操作集合，用于描述类或组件的一个服务。</p><p><strong>接口的特征</strong></p><ul><li>接口一般只有一些操作。</li><li>接口的所有内容都是公有的。</li><li>接口代表了一份契约， 实现该接口的类元必须履行它。</li></ul><p><strong>接口的表述</strong></p><ul><li>表示为带有 &lt;&lt;interface&gt;&gt; 构造型的类。</li><li>表示为一个带名称的小圆圈。</li></ul><p><img data-src="/UML-image/Pasted%20image%2020231209163248.png" alt=""></p><p><strong>供接口</strong>：表示类所提供的服务 ， 表示为与类框连接的小圆圈。<br><img data-src="/UML-image/Pasted%20image%2020231209163318.png" alt=""></p><p>接口由名称和操作构成</p><h3 id="类图中的关系"><a class="anchor" href="#类图中的关系">#</a> 类图中的关系</h3><ul><li>关联</li><li>泛化</li><li>依赖</li><li>实现</li></ul><h4 id="关联"><a class="anchor" href="#关联">#</a> 关联</h4><p>表示类元直接的链接 (link) 的抽象或类元间交互的抽象。</p><p><strong>关联端</strong>：关联关系靠近被关联元素的端点。</p><p><strong>二元关联</strong>：具有二个关联端的关联关系。</p><p><strong>自关联</strong>：同一类的实例间的关联关系。<br><img data-src="/UML-image/Pasted%20image%2020231210113456.png" alt=""></p><p><strong>N 元关联</strong>：具有 N 个关联端的关联关系。<br><img data-src="/UML-image/Pasted%20image%2020231210113530.png" alt=""></p><p><strong>关联关系的表示：实线 +[箭头]</strong></p><p>关联关系的内容：</p><ul><li>名称：字符串， 可选。</li><li>角色：关联端元素承担的职责。<br><img data-src="/UML-image/Pasted%20image%2020231210113635.png" alt=""></li><li>多重性：关联端有多少对象与另一关联端的一个对象关联。<br><img data-src="/UML-image/Pasted%20image%2020231210113718.png" alt=""><br><img data-src="/UML-image/Pasted%20image%2020231210113727.png" alt=""></li><li>导航性：一个关联类对另一关联类信息传递的方向。<br><img data-src="/UML-image/Pasted%20image%2020231210113735.png" alt=""></li><li>限定 (qualification): 给定一个关联端对象（受限对象）， 根据关联属性（限定符， qualifier) 确定另一关联端的一个或一组对象 （目标对象）。 是对属性的限制。<br><img data-src="/UML-image/Pasted%20image%2020231210113813.png" alt=""></li><li>约束用来表示两个关联之间的关系。 是对关联关系的限制。</li><li>约束表示：两个关联关系路径的虚线＋｛约束文字｝。<br><img data-src="/UML-image/Pasted%20image%2020231210113911.png" alt=""></li></ul><h5 id="聚合aggregation"><a class="anchor" href="#聚合aggregation">#</a> 聚合（aggregation）</h5><p>描述整体与部分关系的特殊关联。整体与部分间具有明确的导航特性。整体与部分是 ''has - a'' 关系。 整体与部分的生存期无关。</p><p>聚合的表示： 实线＋空心要形。<br><img data-src="/UML-image/Pasted%20image%2020231210114059.png" alt=""></p><h5 id="组合-composition"><a class="anchor" href="#组合-composition">#</a> 组合 (composition)</h5><p>强聚合关联关系。</p><ul><li>在某个时刻， 局部对象只能属于一个整体对象。</li><li>整体对象与局部对象的生存期重合（相同或包含）。、</li><li>组合关系中的部分要完全依赖千整体。</li></ul><p>组合表示为：实线＋实心要形。<br><img data-src="/UML-image/Pasted%20image%2020231210114159.png" alt=""></p><h4 id="泛化关系generalization"><a class="anchor" href="#泛化关系generalization">#</a> 泛化关系（generalization）</h4><p>基于一般化元素 (parent) 而构建特化元素 (child) 的一种关系。</p><p>特化元素共享一般元素的结构与行为特征。</p><p><strong>泛化的表示</strong>：使用空心三角形＋实线表示。 箭头指向一般类。<br><img data-src="/UML-image/Pasted%20image%2020231210114339.png" alt=""></p><p><strong>泛化关系的特征</strong></p><ul><li>泛化是一种 &quot;is a kind of&quot; 关系。</li><li>子类对象可替代父类对象的任何出现，反之不成立。</li><li>传递性。</li><li>反对称性。<br><img data-src="/UML-image/Pasted%20image%2020231210114351.png" alt=""></li></ul><p><strong>泛化关系的两种情况</strong></p><ul><li>单泛化是指每个类只能有一个父类；</li><li>多重泛化是指类可以有多个父类<br><img data-src="/UML-image/Pasted%20image%2020231210114454.png" alt=""></li></ul><h4 id="依赖关系dependency"><a class="anchor" href="#依赖关系dependency">#</a> 依赖关系（dependency）</h4><p>一个事物使用另一事物的信息或服务。</p><p>类图中的依赖关系主要描述一个类调用另一个类的操作， 或以变量／参数的方式使用另一个类。</p><p>依赖的表示：使用虚线箭头表示。<br><img data-src="/UML-image/Pasted%20image%2020231210114647.png" alt=""></p><p><strong>对千类图而言 ， 主要有以下需要使用依赖的情况：</strong></p><ul><li>使用者类向提供者类发送消息。</li><li>提供者类是使用者类的属性类型。</li><li>提供者类是使用者类操作的参数类型。<br><img data-src="/UML-image/Pasted%20image%2020231210114705.png" alt=""></li></ul><h4 id="实现关系realization-2"><a class="anchor" href="#实现关系realization-2">#</a> 实现关系（realization）</h4><p>类元间的一种语义关系：一个类元定义规范 (contact) , 另一类元负责实现。</p><p><strong>实现关系的二种表示：</strong></p><ul><li>当接口元素以带构造型的类的方式表示时，用虚线三角形箭头表示。</li><li>当接口元素以小圆圈方式表示时，用实线表示。<br><img data-src="/UML-image/Pasted%20image%2020231210114814.png" alt=""></li></ul><h3 id="类的高级概念"><a class="anchor" href="#类的高级概念">#</a> 类的高级概念</h3><h4 id="抽象类abstract-class"><a class="anchor" href="#抽象类abstract-class">#</a> 抽象类（abstract class）</h4><ul><li>不可实例化的类。 当 一些类聚于共同的属性和操作时 ， 可定义抽象基类。</li><li>没有直接的实例。</li></ul><p><strong>抽象类表示</strong>：对类名添加 “斜体” 修饰。类的操作也有抽象性。<br><img data-src="/UML-image/Pasted%20image%2020231210115109.png" alt=""></p><h4 id="模板类template"><a class="anchor" href="#模板类template">#</a> 模板类（template）</h4><p>模板又称为参数化元素， 是对一类带有一个或者多个未绑定的形式参数的元素的描述。 模板应用在类上时称为模板类。</p><p>对应概念： C++ 中的模板与 Java 中的泛型。</p><p>通过《 bind 》构造性的依赖关系表示从模板类创建新类。<br><img data-src="/UML-image/Pasted%20image%2020231210115230.png" alt=""></p><h4 id="关联类association-class"><a class="anchor" href="#关联类association-class">#</a> 关联类（association class）</h4><p>具有类的特性的关联关系。</p><p>关联类具有关联和类二者的特性， 它既可以关联类元素 ， 也可以拥有属性和操作。</p><p><strong>关联类表示</strong>：<br>一个类符号 ， 井通过一条虚线连接到关联路径。<br><img data-src="/UML-image/Pasted%20image%2020231210115347.png" alt=""></p><h4 id="分析类"><a class="anchor" href="#分析类">#</a> 分析类</h4><p>用千从业务需求向系统分析设计转化过程中的 “职责 ＂ 逻辑化（参见 MVC 开发模式）。</p><p><strong>包括：</strong><br>边界类 、 控制类 、 实体类。</p><p><strong>边界类</strong></p><p>用于对系统外部环境与其内部运作之间的交互进行建模的类。</p><p><strong>控制类</strong></p><p>对一个或多个用例所特有的控制行为进行建模的类。</p><p><strong>实体类</strong></p><p>用于对必须存储的信息和相关行为建模的类。</p><p><img data-src="/UML-image/Pasted%20image%2020231210115553.png" alt=""></p><ul><li>用户界面类：帮助与系统用户进行通信的类。</li><li>系统接口类：帮助与其他系统进行通信的类。</li><li>设备接口类：为用来监测外部事件的设备（如传感器）提供接口的类。</li><li>边界类：描述外部与系统内部交互的类；</li><li>控制类：控制其他类的类；</li><li>实体类：存储信息和相关行为的类。</li></ul><h2 id="应用类图建模"><a class="anchor" href="#应用类图建模">#</a> 应用类图建模</h2><h3 id="类图建模技术"><a class="anchor" href="#类图建模技术">#</a> 类图建模技术</h3><p>类图用于对系统的静态设计视图建模。类图主要用千支持系统的功能需求， 即系统提供给用户的服务。</p><p><strong>常用方式</strong></p><ul><li>对系统词汇建模</li><li>对简单协作建模</li><li>对逻辑数据库模式建模</li></ul><h4 id="对系统词汇建模"><a class="anchor" href="#对系统词汇建模">#</a> 对系统词汇建模</h4><ul><li>识别用户或系统开发人员用千描述问题或解决问题的那些实体井抽象。 可以使用基千用例分析的技术帮助用户发现这些抽象。</li><li>对千每个抽象， 识别一个职责集。 要明确地定义每个类， 而且这些职责要在所有的类之间很好的均衡。</li><li>提供为实现每个类的职责所需的属性和操作。</li></ul><h4 id="对简单协作建模"><a class="anchor" href="#对简单协作建模">#</a> 对简单协作建模</h4><ul><li>识别要建模的机制。 机制描述了正在建模的部分系统的一些功能和行为， 这些功能起因于类 、 接口以及其他一些事物所组成的群体的相互作用。</li><li>识别元素及其关系。 对于每一种机制， 分别识别参与协作的类 、 接口和其他协作， 井识别这些事物之间的关系。</li><li>用脚本排演这些事物。 通过这种方法， 可发现模型的哪些部分被遗珊以及哪些部分有明显语义错误。</li><li>把元素和其包含的内容娶集在一起。 对千类而言， 要做好职责的平均分配， 然后逐渐把它们转换成具体的属性和操作。<br><img data-src="/UML-image/Pasted%20image%2020231210120203.png" alt=""></li></ul><h4 id="对逻辑数据库模式建模"><a class="anchor" href="#对逻辑数据库模式建模">#</a> 对逻辑数据库模式建模</h4><ul><li>识别模型中那些状态必须超过应用程序生存时间的类作为需要作为永久数据存储的类。</li><li>创建一个包含这些类的类图。 可以自己定义相关的构造型和标记值组合。</li><li>对类的结构细节进行细化。 包括属性的细节、 类之间的关联及其多重性。</li><li>注意那些增加数据库设计复杂化的公共模式并尽量简化， 如循环关联、一对一的关联和 N 元关联等。</li><li>考虑类的行为。 这些行为主要包括对数据存取和数据完整性约束重要的操作。一般情况下， 这些业务规则应该被封装在这些永久类的上一层中。</li></ul><h3 id="面向对象的设计原则"><a class="anchor" href="#面向对象的设计原则">#</a> 面向对象的设计原则</h3><h4 id="开闭原则ocp"><a class="anchor" href="#开闭原则ocp">#</a> 开闭原则 (OCP)</h4><p>基本思想：软件实体应当对扩展开放， 对修改封闭。</p><p>优点：在扩展系统功能的同时，不影响现有代码。 易于维护，适合迭代式开发。</p><p>设计原则：类图中使用接口和泛化， 井且通过使用多态机制进行调用。</p><h4 id="里氏替换原则lsp"><a class="anchor" href="#里氏替换原则lsp">#</a> 里氏替换原则（LSP）</h4><p><strong>基本思想</strong>：子类对千父类是完全可替换的。</p><p><strong>优点</strong>：主张使用抽象和多态将设计中的静态结构改为动态结构， 维持设计的封闭性。</p><p><strong>设计原则</strong>：类鼓励使用继承与多态， 以提高代码复用及代码扩展性；但严格限制多态与重载必须是父子完全可替换的。</p><h4 id="依赖倒置原则"><a class="anchor" href="#依赖倒置原则">#</a> 依赖倒置原则</h4><p><strong>基本思想</strong>：高层次模块不应该依赖于低层次模块， 二者都应该依赖千抽象；抽象不应该依赖于具体，具体应该依赖于抽象。</p><p><strong>优点</strong>：降低层次间的耦合性。</p><p><strong>设计原则</strong>：高层次类－＞抽象层－＞低层次类。</p><h4 id="接口分离原则isp"><a class="anchor" href="#接口分离原则isp">#</a> 接口分离原则（ISP）</h4><p><strong>基本思想</strong>：采用多个与特定客户类有关的接口， 而不是采用一个通用的接口， 以避免客户类被迫依赖千不需要的接口。</p><p><strong>优点</strong>：避免接口擁肿和接口污染。</p><p><strong>设计原则</strong>：针对不同客户类， 分别定义接口。</p><h4 id="单一职责原则srp"><a class="anchor" href="#单一职责原则srp">#</a> 单一职责原则 (SRP)</h4><p><strong>基本思想</strong>：每个类只含有单一的职责， 且该职责应由这个类完全封装。</p><p><strong>优点</strong>：避免类间的高耦合。</p><p><strong>设计原则</strong>：避免一个类包含多职责， 或一个职责涉及多个类。</p><h1 id="对象图"><a class="anchor" href="#对象图">#</a> 对象图</h1><h2 id="对象图简介"><a class="anchor" href="#对象图简介">#</a> 对象图简介</h2><p>对象图 (object diagram) 显示了某一时刻的一组对象及它们之间的关系。</p><p><strong>对象图的作用</strong>：主要用于说明系统在某一特定时刻的具体运行状态， 一般在论证类模型设计时使用。</p><h2 id="对象图的组成元素"><a class="anchor" href="#对象图的组成元素">#</a> 对象图的组成元素</h2><h3 id="对象-2"><a class="anchor" href="#对象-2">#</a> 对象</h3><p>对象， 是一个封装了状态和行为的具有良好边界和标识符的离散实体。</p><p><strong>对象名</strong>：是一串字符串， 类似于类的名称，对象名也可以有简单名和路径名之分。<br><img data-src="/UML-image/Pasted%20image%2020231210121251.png" alt=""></p><ul><li>stu : Student 标准表示法</li><li>*: Student 匿名表示法</li><li>stu 省略类名的表示法</li></ul><p><strong>状态</strong>：由对象的所有属性以及运行时的当前值组成。</p><h3 id="链"><a class="anchor" href="#链">#</a> 链</h3><ul><li>链 (link) 是两个或多个对象之间的独立连接。</li><li>链主要用来导航。</li><li>链使用一根实线段来表示。</li></ul><h2 id="应用对象图建模"><a class="anchor" href="#应用对象图建模">#</a> 应用对象图建模</h2><h3 id="对象图建模技术"><a class="anchor" href="#对象图建模技术">#</a> 对象图建模技术</h3><p>对象图通常用来对系统的对象结构建模。</p><p>类图可以完整表述系统类及其之间的关系， 对象图不能详细的描述系统完整的对象结构。</p><p><strong>对象图建模步骤</strong></p><ol><li>识别建模机制。</li><li>识别参与的类和接口等元素， 以及这些元素之间的关系。</li><li>识别井选择对象。</li><li>按需要显示每个对象的状态。</li><li>识别井显示出对象之间的链即对象的类目之间关联的实例。</li></ol><h3 id="对象图使用要点"><a class="anchor" href="#对象图使用要点">#</a> 对象图使用要点</h3><ul><li>注重千表达系统静态设计视图或静态交互视图的一个方面。</li><li>表示由一个交互图描绘的动态场景的一个画面。</li><li>只包含对理解该方面不可缺少的那些元素。</li><li>提供与它的抽象层次相一致的细节， 应该只显露出对理解是不可缺少的那些属性值和其他修饰。</li><li>不要过分的简化， 这样会使读者对重要的语义产生误解。</li></ul><h1 id="包图package-diagram"><a class="anchor" href="#包图package-diagram">#</a> 包图（package diagram）</h1><h2 id="包图简介"><a class="anchor" href="#包图简介">#</a> 包图简介</h2><p><strong>包图 (package diagram)</strong> , 是用来描述模型层次和分组结构的一种通用机制。 包图主要组成包括包以及包的依赖关系。<br><img data-src="/UML-image/Pasted%20image%2020231210121940.png" alt=""></p><p><strong>包图的作用</strong></p><ul><li>将语义关系紧密的一组建模元素组织为包，有利于理解这些元素的作用。</li><li>通过包的嵌套， 可将模型组织为层次结构。</li><li>有助千理解模型中各组块间的访问控制。</li></ul><h2 id="包图的组成元素"><a class="anchor" href="#包图的组成元素">#</a> 包图的组成元素</h2><h3 id="包-2"><a class="anchor" href="#包-2">#</a> 包</h3><ul><li>用于把模型本身组织成层次结构的通用机制 ，它不能执行。</li><li>通过使用包， 可方便描述系统组织结构、 各组块间的访问控制。</li></ul><p>包的表示：小矩形＋大矩形</p><ul><li>包名称</li><li>包内模型元素</li><li>可见性</li></ul><p><strong>包名称</strong></p><ul><li>一般以大写字母开头， 大小写混合， 每个单词首字母大写， 避免使用特殊符号。</li><li>包有简单名与路径名两种命名方法。 同一层级下包名必须唯一。<br><img data-src="/UML-image/Pasted%20image%2020231210122202.png" alt=""></li></ul><p><strong>包内元素</strong></p><ul><li>包中可以容纳各种高级的模型元素， 甚至是一个完整的 UML 图。</li><li>包中可以含有包， 这被称为包的嵌套。</li></ul><p><strong>包内元素的显示方式</strong>：</p><ul><li>表示在包内</li><li>表示在包外<br><img data-src="/UML-image/Pasted%20image%2020231210122351.png" alt=""></li></ul><p><strong>包内元素的可见性</strong></p><ul><li>Public (+): 对包外引用可见， 相当千包的对外接口。</li><li>Protected (#) : 对派生类、友元类可见。</li><li>Private (-) : 对友元类可见。</li><li>Package (~) : 仅对当前包可见。<br><img data-src="/UML-image/Pasted%20image%2020231210122403.png" alt=""></li></ul><p><strong>包的构造型</strong></p><ul><li>《 system》：表示整个系统。</li><li>《subsystem》：表示一个子系统。</li><li>《facade》：表示一个只引用其他包中元素的包， 用千提供简略视图。</li><li>《stub》：代理包， 表示服务于另一包的公共内容， 常用千分布式系统建模。</li><li>《framework 》：表示一个包含可重用设计模式的包。<br><img data-src="/UML-image/Pasted%20image%2020231210122511.png" alt=""></li></ul><p><strong>包的作用</strong></p><ul><li>组织模型中的元素。</li><li>控制元素的可见性。</li><li>在外部观察包时， 可以将内部元素视作一个整体， 方便将多个元素一同处理。</li><li>包内部的元素应该保证有相似、 相同的语义，或者其元素有同时更改和变化的性质。</li></ul><p><strong>元素的分包原则</strong></p><ul><li>包与其所含模型元素间是一种从属关系， 该关系是唯一的 ， 且二者生存期一致。</li><li>包内模型元素不能重名。</li><li>包内元素语义上紧密相关。</li><li>包间尽可能独立、 尽可能减少耦合度。</li></ul><h3 id="包的依赖关系"><a class="anchor" href="#包的依赖关系">#</a> 包的依赖关系</h3><p>如果不同包内模型元素间存在依赖关系， 则称包间存在依赖关系。</p><p><strong>依赖关系的表示</strong>：带箭头的虚线。 可以《》添加构造型。<br><img data-src="/UML-image/Pasted%20image%2020231210122727.png" alt=""></p><p><strong>循环依赖</strong>：依赖是广泛存在的。<br><img data-src="/UML-image/Pasted%20image%2020231210122800.png" alt=""></p><p><strong>包的依赖关系特征</strong></p><ul><li>不同包内模型元素间依赖关系的统一描述。</li><li>依赖关系需要包中元素的外部可见性。</li><li>包内对外部可见的元素构成了包的公共命名空间。</li><li>通过导入 (import) , 可将一个包的公共元素追加到另一包的公共命名空间。</li></ul><h2 id="包的建模技术"><a class="anchor" href="#包的建模技术">#</a> 包的建模技术</h2><ul><li>对成组元素建模</li><li>对体系结构视图建模</li></ul><h3 id="对成组元素建模"><a class="anchor" href="#对成组元素建模">#</a> 对成组元素建模</h3><p>把建模元素分成一个个的小组。</p><p><strong>对成组元 素建模的策略</strong></p><ul><li>浏览模型中的元素， 找出概念或语义上接近的元素分组。</li><li>将分好组的元素组织在一个包里， 同时考虑包的嵌套。</li><li>对每一个包， 区分哪些元素需要在包外被访问， 进而确定包内元素的可见性。</li><li>使用引入依赖显式地在包之间建立关系。</li></ul><h3 id="对体系结构视图建模"><a class="anchor" href="#对体系结构视图建模">#</a> 对体系结构视图建模</h3><p>用包表示 &quot;4+1&quot; 体系结构视图。</p><p><strong>对体系结构视图建模的策略</strong></p><ul><li>识别对目标系统建模有意义的那些体系结构视图。</li><li>识别那些对千准确表述这些视图充分而且必要的模型元素， 将其组织到包中。</li><li>如果有必要 ， 将这些模型元素进一步组织到子包中。</li></ul><p><img data-src="/UML-image/Pasted%20image%2020231210123256.png" alt=""></p><h1 id="顺序图"><a class="anchor" href="#顺序图">#</a> 顺序图</h1><p>对系统动态过程视图建模的一种表示方法，通过对象， 对象间关系、 消息传递等建模元素对交互过程建模。</p><p><strong>交互图分类：</strong></p><ul><li>顺序图</li><li>通信图</li><li>时间图</li></ul><h2 id="顺序图简介"><a class="anchor" href="#顺序图简介">#</a> 顺序图简介</h2><p>按时间顺序显示对象交互的图。 一种特殊的交互图。</p><p><strong>顺序图的主要作用</strong></p><ul><li>细化用例的表达。 将需求和服务转化为详细的交互过程。</li><li>有效描述类职责。 根据顺序图中各对象之间的交互关系和发送的消息来进一步明确对象所属类的职责。</li></ul><h2 id="顺序图的组成元素"><a class="anchor" href="#顺序图的组成元素">#</a> 顺序图的组成元素</h2><h3 id="基本结构"><a class="anchor" href="#基本结构">#</a> 基本结构</h3><ul><li>横轴：类元轴， 描述参与交互的对象／角色。</li><li>纵轴：时间轴， 描述对象的生命线及交互过程。</li></ul><h3 id="对象-3"><a class="anchor" href="#对象-3">#</a> 对象</h3><p>对象：系统参与者与构成系统的类实体。</p><ul><li>矩形框表示 ， 对象名：类名。</li><li>横向排列 ， 主要参与者在左 ， 次要参与者在右。</li><li>经常出现在图的顶端。<br><img data-src="/UML-image/Pasted%20image%2020231210123632.png" alt=""></li></ul><h3 id="生命线"><a class="anchor" href="#生命线">#</a> 生命线</h3><p>代表一次交互中的参与对象的生存周期。</p><p>表示为由对象头符号向下引出井延伸的虚线。<br><img data-src="/UML-image/Pasted%20image%2020231210123715.png" alt=""></p><p>”X“表示生命线的结束。</p><h3 id="激活"><a class="anchor" href="#激活">#</a> 激活</h3><p>激活， 又称为控制焦点， 表示一个对象执行一个动作所经历的时间段。</p><ul><li>激活的开始一般对应收到另一对象的消息。</li><li>激活的结束一般对应发出一个消息。</li><li>表示：显示在生命线上的细长矩形。<br><img data-src="/UML-image/Pasted%20image%2020231210124300.png" alt=""></li></ul><h3 id="消息"><a class="anchor" href="#消息">#</a> 消息</h3><p>由一个对象（发送者) 向另一对象（接收者）发送的信号，或一个对象（调用者) 调用另一对象（接收者) 的操作。</p><p>消息表示为从一个对象的生命线指向另一个对象的生命线的箭头。<br><img data-src="/UML-image/Pasted%20image%2020231210124507.png" alt=""></p><p><strong>消息的类型：</strong></p><ul><li>简单消息：泛指任何交互。<br><img data-src="/UML-image/Pasted%20image%2020231210124527.png" alt=""></li><li>调用：调用接收者对象的<br><img data-src="/UML-image/Pasted%20image%2020231210124552.png" alt=""></li><li>返回：一个操作的结束，或对某一消息的回应。<br><img data-src="/UML-image/Pasted%20image%2020231210124606.png" alt=""></li><li>创建：创建一个接收者对象。</li><li>销毁：销毁一个对象。<br><img data-src="/UML-image/Pasted%20image%2020231210124913.png" alt=""></li></ul><p><strong>消息的同步特性</strong></p><ul><li>同步消息：发送者与接收者的事务执行具有时间上的协调一致性。</li><li>异步消息：发送者与接收者的事务各自执行， 不具有协调一致性。<br><img data-src="/UML-image/Pasted%20image%2020231210124949.png" alt=""></li></ul><h2 id="顺序图中的结构化控制"><a class="anchor" href="#顺序图中的结构化控制">#</a> 顺序图中的结构化控制</h2><p>传统顺序图可以描述单一、线性控制流，但不能描述循环、分支、多控制流并发。UML2 通过 “片段机制” 来表达更加复杂的动作序列。</p><p><strong>控制符的表示</strong></p><ul><li>片段：控制符的作用区域， 对应一个消息子序列。 矩形区域。</li><li>标签：控制符类型。 小五边形。</li><li>监护条件：分支、 循环的条件， 决定某个片段是否执行。［布尔表达式］。<br><img data-src="/UML-image/Pasted%20image%2020231210125142.png" alt=""></li></ul><p><strong>控制符类型</strong></p><ul><li>可选片段 (opt) : 监护条件成立时，该片段执行。</li><li>井行执行 (par) : 控制符被水平分割为多个子片段， 这些子片段在时间上可重叠执行， 即井发。<br><img data-src="/UML-image/Pasted%20image%2020231210125215.png" alt=""></li><li>循环执行 (loop) : 在监护条件成立时， 控制符重复执行。<br><img data-src="/UML-image/Pasted%20image%2020231210125259.png" alt=""></li><li>条件片段 (alt) : 控制符被垂直分割为多个子片段， 对应监护条件的多个分支， 满足条件的分支被执行。<br><img data-src="/UML-image/Pasted%20image%2020231210125317.png" alt=""></li><li>交互片段 (ref) : 表示对一段交互的引用。<br><img data-src="/UML-image/Pasted%20image%2020231210125349.png" alt=""></li></ul><h2 id="顺序图建模技术"><a class="anchor" href="#顺序图建模技术">#</a> 顺序图建模技术</h2><p><strong>使用顺序图的目的</strong>：按时间顺序对系统、 子系统、 用例等的控制流建模。</p><p><strong>顺序图建模的步骤</strong></p><ul><li>设定交互的上下文：系统、 子系统、 类、 操作、 用例。</li><li>设定交互的场景：识别参与交互的对象， 按重要性在顺序图中从左至右依次列出。</li><li>设定对象的生命线。</li><li>按时间顺序排列消息， 标注其属性、 语义。</li><li>设定控制焦点：使用激活（期）修饰生命线。</li><li>设定时间、 空间约束：如有必要， 给消息添加标注以修饰其时间或空间约束。</li><li>设定前、 后置条件：如有必要， 使用结构化控制符描述控制流的前、 后置条件细节。<br><img data-src="/UML-image/Pasted%20image%2020231210125559.png" alt=""></li></ul><h2 id="时间图"><a class="anchor" href="#时间图">#</a> 时间图</h2><p>对象间交互过程以时间轴上状态变迁方式描述的一种建模方法。</p><p><strong>时间图特点</strong></p><ul><li>有明确的时间标度。</li><li>采用状态而非控制焦点（动作）描述生命线。</li></ul><p><strong>时间图的组成</strong></p><ul><li>生命线：是一个命名元素， 代表交互中的单个参与者。、<br><img data-src="/UML-image/Pasted%20image%2020231210125709.png" alt=""></li><li>状态或条件时间线：随时间变化， 一个单项状态的改变。<br><img data-src="/UML-image/Pasted%20image%2020231210125752.png" alt=""></li><li>期间约束：设置某一时间区域发生。<br><img data-src="/UML-image/Pasted%20image%2020231210125813.png" alt=""></li><li>时间约束：设置某一时间点发生。<br><img data-src="/UML-image/Pasted%20image%2020231210125825.png" alt=""></li><li>销毁：表示生命线终止。<br><img data-src="/UML-image/Pasted%20image%2020231210125848.png" alt=""></li></ul><p><strong>时间图与顺序图的不同之处</strong></p><ul><li>时间轴与对象轴交换了位置。 在时间图中， 纵向表示不同对象， 横向表示时间的延伸。</li><li>不同对象的生命线在独立的矩形框中显示， 矩形框纵向堆砌成整个图。</li><li>对象可以有不同的状态。 每个对象的状态在其生命线的最左侧纵向排列，生命线通过上下起伏来表示对象当前所处的状态。</li><li>可以显示一个时间标尺。 时间标尺上有时间刻度， 用来表示时间间隔。</li><li>不同对象生命线上的时间是同步的。</li></ul><h1 id="通信图"><a class="anchor" href="#通信图">#</a> 通信图</h1><h2 id="通信图简介"><a class="anchor" href="#通信图简介">#</a> 通信图简介</h2><ul><li><p>表现对象协作关系的图。</p></li><li><p>对用例内部对象或角色间交互和消息传递的结构化组织特性进行分析、 描述的建模表示方法。</p></li><li><p>通信图：数据结构＋数据流 + 控制流。</p></li><li><p>从结构方面来看 ， 通信图包含了一个对象的集合井且定义了它们之间的行为方面的关系， 表达了系统的一些静态内容。</p></li><li><p>从行为方面来看， 通信图包含了在各个对象之间进行传递交换的列的消息集合， 以完成协作的目的。</p></li><li><p>UML 1 中称为协作图</p></li><li><p>UML2.0 后称为通信图<br><img data-src="/UML-image/Pasted%20image%2020231210140722.png" alt=""></p></li></ul><p><strong>通信图和顺序图的异同</strong></p><ul><li>相同：<br>都是对用例的实现进行描述。</li><li>不同：<br>顺序图强调交互的时序。<br>通信图强调交互的组织特性及消息流的数据结构。</li></ul><p><strong>通信图的作用：</strong></p><ul><li>通过描绘对象之间的传递情况来反映使用语境的逻辑表达。</li><li><img data-src="/UML-image/Pasted%20image%2020231210140927.png" alt=""></li><li>显示了在交互过程中各个对象之间的组织交互关系以及对象彼此之间的链接。</li><li><img data-src="/UML-image/Pasted%20image%2020231210141018.png" alt=""></li><li>可以说明类操作中使用到的参数、局部变量以及返回值等。</li><li><img data-src="/UML-image/Pasted%20image%2020231210141028.png" alt=""></li></ul><h2 id="通信图的组成元素"><a class="anchor" href="#通信图的组成元素">#</a> 通信图的组成元素</h2><ul><li>对象／角色 (object)</li><li>消息 (message)</li><li>链 (Link)</li></ul><p><img data-src="/UML-image/Pasted%20image%2020231210141108.png" alt=""></p><h3 id="对象-4"><a class="anchor" href="#对象-4">#</a> 对象</h3><p>是一个封装了状态和行为的具有良好边界和标识符的离散实体。</p><p><strong>对象的表示</strong>：矩形框表示， 对象名：类名。<br><img data-src="/UML-image/Pasted%20image%2020231210141200.png" alt=""></p><p><strong>通信图中对象的特点</strong></p><ul><li>无孤立对象。</li><li>无生命线。</li></ul><h3 id="链-2"><a class="anchor" href="#链-2">#</a> 链</h3><p>两个（或多个）对象之间的独立连接，是关联的实例。 用一条实线表示。</p><p><img data-src="/UML-image/Pasted%20image%2020231210141326.png" alt=""></p><p><strong>链的特点</strong>：动态关联的实例。</p><h3 id="消息-2"><a class="anchor" href="#消息-2">#</a> 消息</h3><p>由一个对象（发送者）向另一对象（接收者）发送的信号， 或一个对象（调用者）调用另一对象（接收者）的操作。</p><p><img data-src="/UML-image/Pasted%20image%2020231210141423.png" alt=""></p><p><strong>消息的编号</strong></p><ul><li>最高层级的消息用阿拉伯数字 1 编号。 下一级的消息注明为 1 .1，1.2 。</li><li>井发消息用加字母的方式表示。例如： 1a1, 1b1 。<br><img data-src="/UML-image/Pasted%20image%2020231210141433.png" alt=""></li></ul><p><strong>控制流建模</strong><br>迭代表示：如 *[i:=1 .. n] 。<br><img data-src="/UML-image/Pasted%20image%2020231210141526.png" alt=""></p><p>条件表示消息执行与否取决于一个布尔表达式的值。</p><p>条件建模是在消息的名称前增加一个条件字句， 如 [x&gt; 0], 表示根据表达式的不同执行不同的消息。</p><p><img data-src="/UML-image/Pasted%20image%2020231210141717.png" alt=""></p><h2 id="通信图与顺序图"><a class="anchor" href="#通信图与顺序图">#</a> 通信图与顺序图</h2><p><img data-src="/UML-image/Pasted%20image%2020231210141726.png" alt=""></p><p><strong>共同点</strong></p><ul><li>主要元素相同</li><li>表达语义相同</li><li>对象责任相同</li></ul><p><strong>不同点</strong></p><ul><li>侧重点不同</li><li>对象状态不相同</li><li>激活情况不相同</li></ul><h2 id="通信图建模技术"><a class="anchor" href="#通信图建模技术">#</a> 通信图建模技术</h2><p><strong>目标</strong>：描述一个用例实现过程中各个对象之间的交互和消息传递。</p><p><strong>绘制通讯图思路和步骤</strong>：</p><ul><li>识别交互的语境；</li><li>识别相应的对象；</li><li>识别对象之间的关系；</li><li>设置对象之间的消息<br><img data-src="/UML-image/Pasted%20image%2020231210141944.png" alt=""></li></ul><h1 id="状态机图"><a class="anchor" href="#状态机图">#</a> 状态机图</h1><h2 id="状态机图简介"><a class="anchor" href="#状态机图简介">#</a> 状态机图简介</h2><p>状态机图 (state diagram, statechart diagram, state machine diagram) : 显示状态机的图，表示单个对象从一个状态到另外一个状态的控制流。</p><p>状态机是一种行为， 它说明对象在其生命周期中响应事件所经历的状态变化序列以及对那些事件的响应。</p><p><strong>状态机的构成</strong></p><ul><li>状态 (state)</li><li>转换 (transition)</li><li>事件 (event)</li><li>活动 (activity)</li><li>动作 (action)</li></ul><p><strong>功能与作用</strong></p><ul><li>状态机图描述了状态转换时所需的触发事件和监护条件等因素。</li><li>状态机图清楚地描述了状态之间的转换及其顺序。</li><li>清晰的事件顺序有利千开发人员在开发程序时避免出现事件错序的情况。</li><li>状态机图通过判定可以更好地描述工作流在不同的条件下而出现的分支。</li></ul><h2 id="状态机图的组成部分"><a class="anchor" href="#状态机图的组成部分">#</a> 状态机图的组成部分</h2><p>状态机图的核心元素</p><ul><li><strong>状态 (state)</strong> 简单状态、伪状态、复合状态</li><li>转换 (transition)</li></ul><h3 id="状态"><a class="anchor" href="#状态">#</a> 状态</h3><p>描述了一个对象稳定处千的某个持续的、可区分的过程。</p><ul><li>简单状态</li><li>复合状态<br><img data-src="/UML-image/Pasted%20image%2020231210142501.png" alt=""></li></ul><p><strong>状态的构成</strong></p><ul><li>名称： 一个合法的标识符， 用千区分不同状态；当某个状态可明显区分千其他状态时， 名称可以省略。</li><li>入口／出口动作：由其他状态转移到当前状态， 或从当前状态转移到其他状态时要附带执行的动作， 用千描述状态的外部动态特性。</li><li>表示为 &quot;entry / 动作表达式” 和&quot;exit / 动作表达式”</li><li>内部活动：实体进入当前状态后持续执行的一系列动作。 内部活动的结束一般会对应当前状态的结束和触发到另一状态的转换。</li><li>内部转换：是一种不导致状态改变的特殊转换， 与普通转换相比 ， 内部转换只有源状态而没有目标状态。（内部转换一般表示为：事件名称＋活动表达式）</li><li>可推迟事件：是一种特殊的事件， 表示对象在某个特定状态下对此类事件的处理会被推迟， 但不会丢失， 也不会触发状态的转换。（表示为” 事件名称 /defer''）<br><img data-src="/UML-image/Pasted%20image%2020231210142551.png" alt=""></li></ul><h3 id="转换"><a class="anchor" href="#转换">#</a> 转换</h3><p>转换是两种状态间的一种关系。</p><p><strong>转换表示</strong>：从源状态指向目标状态的实线箭头， 井附有转换的标签。</p><p>⌊ 转换名称⌋ : opt 事件名称 opt ⌊(参数列表)⌋ opt ⌊[监护条件]⌋ opt ⌊/ 效果列表⌋ opt<br><img data-src="/UML-image/Pasted%20image%2020231210142833.png" alt=""></p><h4 id="事件"><a class="anchor" href="#事件">#</a> 事件</h4><ul><li>是在某一时间与空间下所发生的有意义的事情 ，是系统执行中发生的值得建模的事物。</li><li>一般被状态或转换所发送和接收。</li><li>是状态转换的触发器。</li><li>用事件名称＋参数列表的形式表示一个事件 ， 参数列表用千描述向事件接收者传递的信息。</li></ul><p><strong>能够在触发器中接收的事件</strong></p><ul><li>调用事件：表示对象接收到一个调用操作的请求。 其期待的结果是事件的接收者触发一个转换井执行相应的操作。</li><li>改变事件：表示发生了依赖千某个逻辑表达式所描述条件的事件。 一般用 when+ 逻辑表达式的方式来表示。</li><li><img data-src="/UML-image/Pasted%20image%2020231210143330.png" alt=""></li><li>信号事件：表示由一个对象发送给另一个或一组对象的异步信号， 他是对象间通信的一种重要方式。</li><li><img data-src="/UML-image/Pasted%20image%2020231210143413.png" alt=""></li><li>时间事件：状态转换依赖千事件中的一个时间表达式。 一般使用 after 来辅助表示。</li></ul><h4 id="监护条件guard-condition"><a class="anchor" href="#监护条件guard-condition">#</a> 监护条件 (guard condition)</h4><ul><li>一个转换被激发必须满足的条件。</li><li>表现形式为逻辑表达式， 该表达式可以根据触发器事件的参数、 属性等写成。</li><li>当对象接收到触发事件时， 只有监护条件为真，转换才能被激活。</li><li>对监护条件的检验是触发器计算过程的一部分。当一个事件发生时， 对监护条件的检查进行一次且仅进行一次。</li></ul><h4 id="效果列表-effect-list"><a class="anchor" href="#效果列表-effect-list">#</a> 效果列表 (effect list)</h4><ul><li>效果列表是一个过程表达式， 在转换被激活时执行， 表示转换附加的效果。</li><li>效果列表包括多个动作， 可以根据操作、属性、 拥有对象的连接、 触发器事件的参数等写成。</li><li>效果的表达语法与其实现的具体内容有关。</li></ul><p><img data-src="/UML-image/Pasted%20image%2020231210143715.png" alt=""></p><h3 id="伪状态"><a class="anchor" href="#伪状态">#</a> 伪状态</h3><ul><li>在状态机中具有状态的形式， 却具有特殊行为的顶点。</li><li>伪状态实际上是一个瞬间的状态。</li><li>最常见的伪状态包括初态、 选择、 分叉与结合、历史状态等。</li><li>初态。 表示一个状态机的入口和开始位置。</li><li>选择。 状态机中的一个伪状态节点， 用千表示状态机中的分支结构。<br><img data-src="/UML-image/Pasted%20image%2020231210143838.png" alt=""></li></ul><h3 id="复合状态composite-state"><a class="anchor" href="#复合状态composite-state">#</a> 复合状态 (composite state)</h3><p>指包含有一个或多个嵌套状态机的状态。 复合状态中包含的状态称为子状态。 分类：顺序复合状态、 井发复合状态。</p><h4 id="顺序复合状态"><a class="anchor" href="#顺序复合状态">#</a> 顺序复合状态</h4><p>顺序复合状态是仅含顺序子状态的一种复合状态。 复合状态的特点是， 在对象处千复合状态的任一时刻， 只有一个子状态是活跃的。</p><p><img data-src="/UML-image/Pasted%20image%2020231210143950.png" alt=""></p><h4 id="并发复合状态"><a class="anchor" href="#并发复合状态">#</a> 并发复合状态</h4><p>井发复合状态是含井发子状态的复合状态。在对象处千复合状态的任一时刻， 有多个子状态同时是活跃状态。</p><h4 id="历史复合状态"><a class="anchor" href="#历史复合状态">#</a> 历史复合状态</h4><p>历史状态是应用与复合状态的一种伪状态。</p><p>用与表示最近一次离开该复合状态时所处的子状态。</p><p><img data-src="/UML-image/Pasted%20image%2020231210144121.png" alt=""></p><h2 id="状态机图建模技术"><a class="anchor" href="#状态机图建模技术">#</a> 状态机图建模技术</h2><p>状态机图建模的目标是对那些在不同条件下对外反应不同的对象的生命周期建模。</p><p><strong>状态图建模的条件</strong></p><ul><li>对象处千可知的若干稳定状态：状态图建模的基础。</li><li>存在确定的事件使对象所处状态相互转换：状态机建模的合理性。</li><li>对不同状态而言 ， 对象对外的接口 、 行为特征各不相同：状态机建模的必要性。</li></ul><p><strong>状态机图建模的固定流程</strong></p><ol><li>确定状态机的语境。</li><li>设置状态机的初态和终态。</li><li>决定该对象的状态机中可能需要响应的事件。</li><li>从初态到终态，列出这个对象可能处于的所有顶层状态。用转移将这些状态连接起来，明确转移的触发器和监护条件，接着向转移中添加效果动作。</li><li>识别状态是否需要有入口动作和出口动作。如果需要，使用子状态来对顶层状态进行嵌套。</li><li>检查状态机中提供的事件是否与所期望的相匹配；检查所有事件是否都已经被状态机所处理。</li><li>检查状态机中的动作是否能由类或对象的关系、操作等支持。</li><li>跟踪状态机，确保状态机是良构的，即不存在无法到达的状态，也不会发生停机。</li></ol><h1 id="活动图"><a class="anchor" href="#活动图">#</a> 活动图</h1><h2 id="活动图简介"><a class="anchor" href="#活动图简介">#</a> 活动图简介</h2><p>对系统动态过程视图建模的一种表示方法，通过活动、 控制流、 判定、 分叉与结合等元素对系统工作流建模。</p><p>活动图本质上说是一个流程图， 展示从活动到活动之间转移的控制流。</p><p><strong>活动图的作用</strong></p><ul><li>对计算过程中的步骤及时序建模；</li><li>对活动序列中的数据流建模；</li><li>对一组对象间的交互过程建模；</li><li>对单个操作的控制流程建模。</li></ul><h2 id="活动图的组成元素"><a class="anchor" href="#活动图的组成元素">#</a> 活动图的组成元素</h2><p>活动图的核心元素是活动和控制流， 活动与活动之间通过控制流进行连接 ， 构成有意义的动作网络。</p><p>活动图主要包括：<strong>动作；活动结点；控制流；泳道</strong>等。</p><h3 id="动作"><a class="anchor" href="#动作">#</a> 动作</h3><ul><li>可执行的、 原子性的计算行为。</li><li>动作描述：表达式的计算、 调用操作、 发送消息、 创建或删除对象等。</li></ul><h3 id="活动-2"><a class="anchor" href="#活动-2">#</a> 活动</h3><ul><li>一组动作序列的执行过程。</li><li>活动结点是动作序列的简化表示。</li><li>表示方式：左右两端为圆弧的 ＂ 矩形框 ＂</li></ul><h3 id="开始符号"><a class="anchor" href="#开始符号">#</a> 开始符号</h3><ul><li>表示业务流程的起始位置</li><li>一个活动图仅有一个开始符号</li><li>表示方式：黑色实心圆点</li></ul><h3 id="终止符号"><a class="anchor" href="#终止符号">#</a> 终止符号</h3><ul><li>表示业务流程的结束位置。</li><li>一个活动图可以包含多个终止符号。</li><li>表示方式：内有一个黑色实心小圆点的空心圆圈。</li></ul><h3 id="控制流"><a class="anchor" href="#控制流">#</a> 控制流</h3><ul><li>用于表示业务流程从一个活动向另一个活动过渡的路径。</li><li>控制流既表示一个活动的结束 ， 也表示另 一活动的立即开始， 无需其他约束或事件的触发。</li><li>表示方式：简单箭头</li></ul><h3 id="判断节点"><a class="anchor" href="#判断节点">#</a> 判断节点</h3><ul><li>表示基千某个条件判断的多个控制流选择。</li><li>一个进入控制流， 两个或多个导出控制流。</li><li>导出控制流的箭头上附加控制条件。</li><li>表示方式：萎形。</li></ul><h3 id="合并节点merging"><a class="anchor" href="#合并节点merging">#</a> 合并节点 (merging)</h3><ul><li>多个控制流的合井 ， 统一导出到 一个离开控制流。</li><li>仅定义统一的出口 ， 无同步语义。</li><li>至少有两个指向它的控制流 ， 仅有一个输出控制流。</li></ul><h3 id="分叉节点forking"><a class="anchor" href="#分叉节点forking">#</a> 分叉节点 (forking)</h3><ul><li>表示多个控制流井发执行。</li><li>一个进入控制流， 两个或多个导出控制流。</li><li>分叉节点是从线性流程进入井发过程的过渡节点。</li><li>表示方式：水平或垂直的粗线。</li></ul><h3 id="结合节点joining"><a class="anchor" href="#结合节点joining">#</a> 结合节点 (joining)</h3><ul><li>多个控制流的在结合点处相互等待， 直至全部完成后， 合井为一个离开控制流。</li><li>表示方式：水平或垂直的粗线。</li></ul><h3 id="泳道swimlanes"><a class="anchor" href="#泳道swimlanes">#</a> 泳道 (swimlanes)</h3><ul><li>将活动图中的活动按照其业务参与者分组，称为泳道。</li><li>每个活动只能属于一个泳道， 转移可以跨越泳道。</li><li>表示方式：垂直的实线。</li></ul><h3 id="对象流"><a class="anchor" href="#对象流">#</a> 对象流</h3><ul><li>对象可出现在活动图中 ， 表示某些活动会产生 、 访问 、 修改这些对象。</li><li>对象流是连接两个节点的活动边。</li></ul><p><strong>对象流的表示</strong></p><ul><li>表示方式：简单箭头。</li><li>活动节点到对象节点：创建、 生成对象。</li><li>对象节点到活动节点：访问 、 激活动作。</li></ul><h3 id="扩展区域"><a class="anchor" href="#扩展区域">#</a> 扩展区域</h3><ul><li>扩展区域表示在一组数据元素上的迭代执行。</li><li>扩展区域的输入输出都是值的集合。<br>输入：一个或多个值序列（集合）；<br>输出：无输出， 或多个值序列（集合）。</li><li>表示方式：虚线圈起来的区域。</li></ul><h2 id="活动图建模技术"><a class="anchor" href="#活动图建模技术">#</a> 活动图建模技术</h2><p><strong>建模语境</strong></p><ul><li>系统</li><li>子系统</li><li>类</li><li>操作</li><li>用例</li><li>协作</li></ul><h3 id="对工作流建模"><a class="anchor" href="#对工作流建模">#</a> 对工作流建模</h3><p>工作流是系统参与者感知到的活动序列，它可以描述参与者与系统交互发生时的业务流程。</p><p><strong>工作流建模主要步骤</strong></p><ul><li>设定工作流建模焦点（选择重要的工作流）。</li><li>选定工作流中承担高层职责的业务对象， 井在活动图中建立泳道。</li><li>识别工作流的前置、 后置条件， 以便确定工作流边界。</li><li>从工作流的初始状态开始， 按时间顺序在活动图中安排活动序列。</li><li>针对复杂的、 重复出现的活动， 创建单独的活动图。</li><li>确定连接这些活动序列的流：顺序、 分支、 井发等。</li><li>对千工作流中的重要对象， 安排对象流， 井显示其状态变化。</li></ul><h3 id="对操作建模"><a class="anchor" href="#对操作建模">#</a> 对操作建模</h3><p>将活动图附加到任意建模元素上 ， 其中最常见的是向一个操作附加活动图。</p><p>作为控制流图 ， 对某些计算过程的执行细节描述、 建模。</p><p><strong>操作建模主要步骤</strong></p><ul><li>搜集这个操作涉及的抽象， 包括：参数、 返回值类型、 所属类的属性、关联的类。</li><li>识别这个操作初态的前置条件和终态的后置条件， 以及其所属类中不受该操作影响的量。</li><li>从初态开始， 按时间顺序依次识别活动井表示为活动结点。</li><li>若有必要， 使用分支结点表示条件路径和迭代。</li><li>对具有控制流的类， 若有必要， 可使用分叉表示井发。</li></ul><h1 id="组件图"><a class="anchor" href="#组件图">#</a> 组件图</h1><h2 id="组件图简介"><a class="anchor" href="#组件图简介">#</a> 组件图简介</h2><ul><li>对系统静态设计与实现视图建模的一种表示方法 ， 通过接口、 端口、 组件及连接等元素对系统的物理实现建模。</li><li>描述组件与组件关系的图。</li></ul><p><strong>组件图的作用</strong></p><ul><li>通过小的部件描述一个复杂系统的物理构成。</li><li>组件图体现面向对象思想的核心。</li><li>有助千明确系统设计、 降低沟通成本。</li></ul><h2 id="组件图的组成元素"><a class="anchor" href="#组件图的组成元素">#</a> 组件图的组成元素</h2><p>组件图的主要元素包括组件、 接口和端口。<br><img data-src="/UML-image/Pasted%20image%2020231210150250.png" alt=""></p><h3 id="组件-2"><a class="anchor" href="#组件-2">#</a> 组件</h3><ul><li>系统设计的一个模块化部分， 它隐藏了内部的实现， 对外提供了一组组接口。</li><li>组件具有可替换性。</li><li>组件的表示：矩形框＋相应标识。</li></ul><p><strong>组件与类的区别</strong></p><ul><li>类是一种逻辑抽象， 而组件是一种物理抽象。</li><li>类具有直接属性与操作， 而组件一般只有操作且仅通过接口访问。</li><li>类与组件间存在依赖关系。</li></ul><p><strong>组件的类型</strong></p><ul><li>配置组件：指系统运行时需配詈的组件。</li><li>工作产品组件：指开发过程中产生的、用于生成配置组件的中间产品。</li><li>执行组件：系统运行而创建的组件实例。<br><img data-src="/UML-image/Pasted%20image%2020231210150429.png" alt=""></li></ul><h3 id="接口-3"><a class="anchor" href="#接口-3">#</a> 接口</h3><ul><li>类或组件所提供服务的抽象。</li><li>一组操作的集合。</li><li>接口表示一种约定， 不涉及具体实现。<br><img data-src="/UML-image/Pasted%20image%2020231210150534.png" alt=""></li></ul><p><strong>接口分类</strong><br>供给接口 (provide interface)、 需求接口 (required interface)<br><img data-src="/UML-image/Pasted%20image%2020231210150543.png" alt=""></p><h3 id="端口"><a class="anchor" href="#端口">#</a> 端口</h3><ul><li>端口是组件的对外窗口， 是组件外部可见行为的总和。</li><li>端口允许把组件的接口划分为离散的井且可以独立使用的几部分。</li><li>跨立在组件边界上的方块。</li><li>每个端口都有一个名字。</li></ul><p><img data-src="/UML-image/Pasted%20image%2020231210150655.png" alt=""></p><p><strong>端口的特征</strong></p><ul><li>端口具有身份， 是可区分的。</li><li>接口是针对端口定义的操作集， 因此接口可被分组井独立地被引用。</li><li>端口是组件的部件 (part) , 具有多重性。</li></ul><p><strong>依赖关系</strong>使用虚线箭头表示 ， 主要用千组件与需求接口之间的依赖和组件之间的依赖。<br><strong>实现关系</strong>使用虚线三角箭头表示 ， 主要用千组件与提供接口之间的实现。<br><img data-src="/UML-image/Pasted%20image%2020231210150744.png" alt=""></p><h3 id="部件"><a class="anchor" href="#部件">#</a> 部件</h3><ul><li>部件：是组件实现所必须的内部单元。 部件有名字和类型， 也有多重性。</li></ul><h3 id="内部连接"><a class="anchor" href="#内部连接">#</a> 内部连接</h3><ul><li>内部连接：表现了内部部件间的依赖关系。</li></ul><p><strong>内部连接的类型</strong></p><ul><li>端口相连：部件间具有明确的依赖关系。</li><li>接口相连：部件间具有兼容的接口。</li><li>委托连接：内部端口与外部端口间的连接。<br><img data-src="/UML-image/Pasted%20image%2020231210151011.png" alt=""></li></ul><h2 id="组件图建模技术"><a class="anchor" href="#组件图建模技术">#</a> 组件图建模技术</h2><p>组件图表现的是系统的物理层次或实现层次上的静态结构， 能够帮助开发团队加深对系统组成的理解。</p><p><strong>组件图对源代码结构建模应湮循的策略</strong></p><ul><li>识别出感兴趣的源代码文件集合， 井建模为组件。</li><li>如果系统规模较大 ， 使用包对组件进行分组。</li><li>可以使用约束或注解来表示源代码的作者心 版本号等信息。</li><li>使用接口和依赖关系来表示这些源代码文件之间的关系。</li><li>检查组件图的合理性 ， 井识别源代码文件的优先级以便进行开发工作。<br><img data-src="/UML-image/Pasted%20image%2020231210151106.png" alt=""></li></ul><p><strong>对可执行程序结构进行建模时， 应逜循的策略</strong></p><ul><li>识别出相关的运行组件集合。</li><li>考虑集合中每个组件的类型。</li><li>如果系统规模较大， 可以使用包对组件进行分组。 这里包的使用可以对应千相应文件的文件存储结构。</li><li>分析组件之间的关系， 使用接口和依赖关系建模这些关系。</li><li>考量建模结果是否实现了组件的各个特性， 对建模的结果进行细化。<br><img data-src="/UML-image/Pasted%20image%2020231210151150.png" alt=""></li></ul><h1 id="部署图"><a class="anchor" href="#部署图">#</a> 部署图</h1><p>软件开发过程中，不同角色的关注点不同</p><p><strong>软件开发人员</strong></p><ul><li>关注软件的静态结构</li><li>关注软件的配置</li><li>关注软件的动态特性</li></ul><p><strong>系统工程师</strong></p><ul><li>关注系统中硬件与软件的构成与配置</li><li>关注软、 硬件间的折中和分工</li></ul><h2 id="部署图简介"><a class="anchor" href="#部署图简介">#</a> 部署图简介</h2><ul><li>是一种展示运行时进行处理的节点和在节点上存在的制品的配置的图。</li><li>对系统硬件配置及拓扑结构相关静态特征进行建模的一种表示方法。</li></ul><p><strong>部著图的作用</strong></p><ul><li>通过硬件配置及拓扑结构描述一个系统的物理构成。</li><li>确认软件的运行环境、 约束及性能瓶颈。</li><li>有助于软件开发人员与系统集成工程师间的沟通。</li></ul><h2 id="部署图的组成元素"><a class="anchor" href="#部署图的组成元素">#</a> 部署图的组成元素</h2><h3 id="节点node"><a class="anchor" href="#节点node">#</a> 节点（node）</h3><ul><li>系统运行时的一个硬件对象（计算资源）。</li><li>节点的类型：处理器：具有计算能力的节点设备：外围 I/O 设备</li></ul><h3 id="连接connection"><a class="anchor" href="#连接connection">#</a> 连接（connection）</h3><ul><li>节点间的关联关系。</li><li>使用关联关系来表示节点之间的通信路径。</li><li>使用构造型来区分不同类型的通信路径或通信的实现方式。</li></ul><h2 id="部署图建模技术"><a class="anchor" href="#部署图建模技术">#</a> 部署图建模技术</h2><p>部署图的意义在千对各种系统的静态部署视图进行建模 ， 无论是 C/S 结构 、 B/S 结构、嵌入式系统或分布式系统均可以使用部署图来有效表达。</p><h3 id="对嵌入式系统建模"><a class="anchor" href="#对嵌入式系统建模">#</a> 对嵌入式系统建模</h3><ul><li>识别目标系统中的设备和物理节点。</li><li>提供清晰的视觉描述：使用 UML 扩展机制描述特定的设备类型， 能够保证通过图标清楚区分不同类型的设备。</li><li>确定这些物理节点间的关系；确定实现视图中的软件制品与部署视图中物理节点间的关系。</li></ul><p><img data-src="/UML-image/Pasted%20image%2020231210151832.png" alt=""></p><h3 id="对cs-系统建模"><a class="anchor" href="#对cs-系统建模">#</a> 对 C/S 系统建模</h3><ul><li>识别出代表客户和服务器的节点。</li><li>重点标注出与系统行为关系紧密的设备。</li><li>使用构造型描述这些节点， 以便清晰提供视觉线索。</li><li>确定节点间的拓扑关系；确定软件制品与物理节点间配置关系。</li></ul><p><img data-src="/UML-image/Pasted%20image%2020231210151923.png" alt=""></p><h3 id="对全分布式系统建模"><a class="anchor" href="#对全分布式系统建模">#</a> 对全分布式系统建模</h3><p>分布式系统一般是由多级服务器组成的，建立在网络之上的软件系统。</p><p><strong>对全分布式系统建模步骤</strong></p><ul><li>识别出系统中的处理机和设备节点。</li><li>若考虑系统网络性能及拓扑结构变化带来的影响， 需对通信设备的细节进行充分描述。</li><li>使用包对这些节点进行逻辑分组。</li><li>可以引进用例图描述所感兴趣的行为类型。<br><img data-src="/UML-image/Pasted%20image%2020231210152031.png" alt=""></li></ul></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-12-10 15:45:30" itemprop="dateModified" datetime="2023-12-10T15:45:30+08:00">2023-12-10</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="KangKang 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="KangKang 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>kangkang <i class="ic i-at"><em>@</em></i>KangKang</li><li class="link"><strong>本文链接：</strong> <a href="https://blog.0kangkang0.top/2023/12/10/UML%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E3%80%81%E5%BB%BA%E6%A8%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1/" title="UML面向对象分析、建模与设计">https://blog.0kangkang0.top/2023/12/10/UML面向对象分析、建模与设计/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" itemprop="url" rel="prev" data-background-image="&#x2F;img&#x2F;00043-4079796899.png" title="计算机网络"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>计算机网络</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">软件工程与面向对象方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">软件工程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E5%8E%86%E5%8F%B2"><span class="toc-number">1.1.1.</span> <span class="toc-text">软件工程的历史</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">软件危机</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%BB%BA%E6%A8%A1"><span class="toc-number">1.1.2.</span> <span class="toc-text">软件建模</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">面向对象方法简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2"><span class="toc-number">1.2.2.</span> <span class="toc-text">面向对象发展历史</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.3.</span> <span class="toc-text">面向对象方法的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">抽象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">独立</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85-2"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%8C%96"><span class="toc-number">1.2.3.7.</span> <span class="toc-text">泛化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%8A%80%E6%9C%AF%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.2.4.</span> <span class="toc-text">面向对象技术的优点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#uml"><span class="toc-number">2.</span> <span class="toc-text">UML</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#uml%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.</span> <span class="toc-text">UML 的简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uml%E7%9A%84%E5%8E%86%E5%8F%B2"><span class="toc-number">2.2.</span> <span class="toc-text">UML 的历史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#uml%E7%9A%84%E7%9B%AE%E6%A0%87%E4%B8%8E%E5%BA%94%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">2.3.</span> <span class="toc-text">UML 的目标与应用范围</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#uml%E7%9A%84%E7%9B%AE%E6%A0%87"><span class="toc-number">2.3.1.</span> <span class="toc-text">UML 的目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uml%E7%9A%84%E5%BA%94%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">2.3.2.</span> <span class="toc-text">UML 的应用范围</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E8%AF%86uml"><span class="toc-number">3.</span> <span class="toc-text">初识 UML</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#uml%E6%9E%84%E9%80%A0%E5%9D%97"><span class="toc-number">3.1.</span> <span class="toc-text">UML 构造块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E7%89%A9"><span class="toc-number">3.1.1.</span> <span class="toc-text">事物</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BA%8B%E7%89%A9"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">结构事物</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB-2"><span class="toc-number">3.1.1.1.1.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.1.1.1.2.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%8F%E4%BD%9C"><span class="toc-number">3.1.1.1.3.</span> <span class="toc-text">协作</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B"><span class="toc-number">3.1.1.1.4.</span> <span class="toc-text">用例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6"><span class="toc-number">3.1.1.1.5.</span> <span class="toc-text">组件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E7%82%B9"><span class="toc-number">3.1.1.1.6.</span> <span class="toc-text">结点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E4%B8%BA%E4%BA%8B%E7%89%A9"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">行为事物</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92"><span class="toc-number">3.1.1.2.1.</span> <span class="toc-text">交互</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">3.1.1.2.2.</span> <span class="toc-text">状态机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8"><span class="toc-number">3.1.1.2.3.</span> <span class="toc-text">活动</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E4%BA%8B%E7%89%A9"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">分组事物</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">3.1.1.3.1.</span> <span class="toc-text">包</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A%E4%BA%8B%E7%89%A9annotation-things"><span class="toc-number">3.1.1.4.</span> <span class="toc-text">注释事物（annotation things)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB"><span class="toc-number">3.1.2.</span> <span class="toc-text">关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">关联关系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%9A%E5%90%88aggregations"><span class="toc-number">3.1.2.1.1.</span> <span class="toc-text">聚合（aggregations)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E5%90%88composition"><span class="toc-number">3.1.2.1.2.</span> <span class="toc-text">组合（composition)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">依赖关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BB"><span class="toc-number">3.1.2.3.</span> <span class="toc-text">泛化关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BBrealization"><span class="toc-number">3.1.2.4.</span> <span class="toc-text">实现关系（realization):</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BEdiagram"><span class="toc-number">3.1.3.</span> <span class="toc-text">图（diagram)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.</span> <span class="toc-text">通用机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E6%A0%BC%E8%AF%B4%E6%98%8E-specifications"><span class="toc-number">3.2.1.</span> <span class="toc-text">规格说明 (Specifications):</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0adornments"><span class="toc-number">3.2.2.</span> <span class="toc-text">修饰 (Adornments)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%88%92%E5%88%861commondivisions"><span class="toc-number">3.2.3.</span> <span class="toc-text">通用划分 (1CommonDivisions):</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B-%E5%AE%9E%E4%BE%8Btype-instance"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">类型－实例 (type-instance)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-%E5%AE%9E%E7%8E%B0-interf-aces-imp-i-e-mentati-on"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">接口－实现 (interf aces-imp I e mentati on)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6extensibility-mechanisms"><span class="toc-number">3.2.4.</span> <span class="toc-text">扩展机制 (Extensibility Mechanisms)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%9E%8B"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">构造型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0%E5%80%BC"><span class="toc-number">3.2.4.2.</span> <span class="toc-text">标记值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-number">3.2.4.3.</span> <span class="toc-text">约束</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41%E6%9E%B6%E6%9E%84"><span class="toc-number">3.3.</span> <span class="toc-text">&quot;4+&#39;1&quot; 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41%E6%9E%B6%E6%9E%84%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%BB%84%E6%88%90"><span class="toc-number">3.3.1.</span> <span class="toc-text">&quot;4+&#39;1&quot; 架构的概念和组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%A7%86%E5%9B%BE-l1ogic-view"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">逻辑视图 (L1og&#39;ic View)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E8%A7%86%E5%9B%BEdevelopmentmodule-view"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">开发视图（Development&#x2F;Module View）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%A7%86%E5%9B%BE-pro1cessview"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">进程视图 (Pro1cess&#39;View)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E8%A7%86%E5%9B%BEphysicalview"><span class="toc-number">3.3.1.4.</span> <span class="toc-text">物理视图 (Physicalview)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E8%A7%86%E5%9B%BEscenarios-view"><span class="toc-number">3.3.1.5.</span> <span class="toc-text">场景视图（Scenarios View）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.3.1.6.</span> <span class="toc-text">视图间的关系：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%94%A841%E6%9E%B6%E6%9E%84"><span class="toc-number">3.3.2.</span> <span class="toc-text">运用 “4+1” 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E8%A7%86%E5%9B%BE"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">场景视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%A7%86%E5%9B%BE"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">逻辑视图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E8%A7%86%E5%9B%BE"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">开发视图</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E5%9B%BE"><span class="toc-number">4.</span> <span class="toc-text">用例图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E5%9B%BE%E7%AE%80%E4%BB%8B"><span class="toc-number">4.1.</span> <span class="toc-text">用例图简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E5%9B%BE%E7%9A%84%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0"><span class="toc-number">4.2.</span> <span class="toc-text">用例图的组成元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E4%B8%8E%E8%80%85actorrole"><span class="toc-number">4.2.1.</span> <span class="toc-text">参与者（actor&#x2F;role）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AE%E5%AE%9A%E5%8F%82%E4%B8%8E%E8%80%85"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">确定参与者</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E4%B8%8E%E8%80%85%E7%9A%84%E7%A1%AE%E5%AE%9A%E4%BB%8E%E7%B1%BB%E5%88%AB%E8%A7%92%E5%BA%A6"><span class="toc-number">4.2.1.1.1.</span> <span class="toc-text">参与者的确定：从类别角度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E4%B8%8E%E8%80%85%E7%9A%84%E7%A1%AE%E5%AE%9A%E4%BB%8E%E8%A7%92%E8%89%B2%E8%A7%92%E5%BA%A6"><span class="toc-number">4.2.1.1.2.</span> <span class="toc-text">参与者的确定：从角色角度</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%BE%B9%E7%95%8C"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">系统边界</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BE%8Buse-case"><span class="toc-number">4.2.2.</span> <span class="toc-text">用例（use case）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E4%B8%8E%E5%8F%82%E4%B8%8E%E8%80%85"><span class="toc-number">4.2.3.</span> <span class="toc-text">用例与参与者</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BE%8B%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%96%87%E6%A1%A3"><span class="toc-number">4.3.</span> <span class="toc-text">用例描述与文档</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%A8%E4%BE%8B%E6%8F%8F%E8%BF%B0"><span class="toc-number">4.3.1.</span> <span class="toc-text">什么是用例描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">4.3.2.</span> <span class="toc-text">事件流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">基本事件流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%80%89%E4%BA%8B%E4%BB%B6%E6%B5%81"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">可选事件流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA%E4%B8%8E%E8%A1%A5%E5%85%85%E7%BA%A6%E6%9D%9F"><span class="toc-number">4.3.3.</span> <span class="toc-text">结论与补充约束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%94%A8%E4%BE%8B%E5%9B%BE%E5%BB%BA%E6%A8%A1"><span class="toc-number">4.4.</span> <span class="toc-text">使用用例图建模</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AF%AD%E5%A2%83%E5%BB%BA%E6%A8%A1"><span class="toc-number">4.4.1.</span> <span class="toc-text">对系统的语境建模：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9B%BEclass-diagram"><span class="toc-number">5.</span> <span class="toc-text">类图（class diagram）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9B%BE%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">5.1.</span> <span class="toc-text">类图的简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9B%BE%E7%9A%84%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0"><span class="toc-number">5.2.</span> <span class="toc-text">类图的组成元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB-3"><span class="toc-number">5.2.1.</span> <span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%90%8D"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">类名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9Coperationfunction"><span class="toc-number">5.2.1.3.</span> <span class="toc-text">操作 (operation&amp;function)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%8C%E8%B4%A3"><span class="toc-number">5.2.1.4.</span> <span class="toc-text">职责</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-2"><span class="toc-number">5.2.2.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9B%BE%E4%B8%AD%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">5.2.3.</span> <span class="toc-text">类图中的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">关联</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%9A%E5%90%88aggregation"><span class="toc-number">5.2.3.1.1.</span> <span class="toc-text">聚合（aggregation）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E5%90%88-composition"><span class="toc-number">5.2.3.1.2.</span> <span class="toc-text">组合 (composition)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%8C%96%E5%85%B3%E7%B3%BBgeneralization"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">泛化关系（generalization）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BBdependency"><span class="toc-number">5.2.3.3.</span> <span class="toc-text">依赖关系（dependency）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BBrealization-2"><span class="toc-number">5.2.3.4.</span> <span class="toc-text">实现关系（realization）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5"><span class="toc-number">5.2.4.</span> <span class="toc-text">类的高级概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BBabstract-class"><span class="toc-number">5.2.4.1.</span> <span class="toc-text">抽象类（abstract class）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BBtemplate"><span class="toc-number">5.2.4.2.</span> <span class="toc-text">模板类（template）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E7%B1%BBassociation-class"><span class="toc-number">5.2.4.3.</span> <span class="toc-text">关联类（association class）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E7%B1%BB"><span class="toc-number">5.2.4.4.</span> <span class="toc-text">分析类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%B1%BB%E5%9B%BE%E5%BB%BA%E6%A8%A1"><span class="toc-number">5.3.</span> <span class="toc-text">应用类图建模</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9B%BE%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF"><span class="toc-number">5.3.1.</span> <span class="toc-text">类图建模技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%B3%BB%E7%BB%9F%E8%AF%8D%E6%B1%87%E5%BB%BA%E6%A8%A1"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">对系统词汇建模</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%AE%80%E5%8D%95%E5%8D%8F%E4%BD%9C%E5%BB%BA%E6%A8%A1"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">对简单协作建模</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E9%80%BB%E8%BE%91%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%BC%8F%E5%BB%BA%E6%A8%A1"><span class="toc-number">5.3.1.3.</span> <span class="toc-text">对逻辑数据库模式建模</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">5.3.2.</span> <span class="toc-text">面向对象的设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99ocp"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">开闭原则 (OCP)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99lsp"><span class="toc-number">5.3.2.2.</span> <span class="toc-text">里氏替换原则（LSP）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99"><span class="toc-number">5.3.2.3.</span> <span class="toc-text">依赖倒置原则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%88%86%E7%A6%BB%E5%8E%9F%E5%88%99isp"><span class="toc-number">5.3.2.4.</span> <span class="toc-text">接口分离原则（ISP）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99srp"><span class="toc-number">5.3.2.5.</span> <span class="toc-text">单一职责原则 (SRP)</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%9B%BE"><span class="toc-number">6.</span> <span class="toc-text">对象图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%9B%BE%E7%AE%80%E4%BB%8B"><span class="toc-number">6.1.</span> <span class="toc-text">对象图简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%9B%BE%E7%9A%84%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0"><span class="toc-number">6.2.</span> <span class="toc-text">对象图的组成元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1-2"><span class="toc-number">6.2.1.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE"><span class="toc-number">6.2.2.</span> <span class="toc-text">链</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%9B%BE%E5%BB%BA%E6%A8%A1"><span class="toc-number">6.3.</span> <span class="toc-text">应用对象图建模</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%9B%BE%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF"><span class="toc-number">6.3.1.</span> <span class="toc-text">对象图建模技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%9B%BE%E4%BD%BF%E7%94%A8%E8%A6%81%E7%82%B9"><span class="toc-number">6.3.2.</span> <span class="toc-text">对象图使用要点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%85%E5%9B%BEpackage-diagram"><span class="toc-number">7.</span> <span class="toc-text">包图（package diagram）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E5%9B%BE%E7%AE%80%E4%BB%8B"><span class="toc-number">7.1.</span> <span class="toc-text">包图简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E5%9B%BE%E7%9A%84%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0"><span class="toc-number">7.2.</span> <span class="toc-text">包图的组成元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85-2"><span class="toc-number">7.2.1.</span> <span class="toc-text">包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">7.2.2.</span> <span class="toc-text">包的依赖关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E7%9A%84%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF"><span class="toc-number">7.3.</span> <span class="toc-text">包的建模技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%88%90%E7%BB%84%E5%85%83%E7%B4%A0%E5%BB%BA%E6%A8%A1"><span class="toc-number">7.3.1.</span> <span class="toc-text">对成组元素建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E8%A7%86%E5%9B%BE%E5%BB%BA%E6%A8%A1"><span class="toc-number">7.3.2.</span> <span class="toc-text">对体系结构视图建模</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%9B%BE"><span class="toc-number">8.</span> <span class="toc-text">顺序图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%9B%BE%E7%AE%80%E4%BB%8B"><span class="toc-number">8.1.</span> <span class="toc-text">顺序图简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%9B%BE%E7%9A%84%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0"><span class="toc-number">8.2.</span> <span class="toc-text">顺序图的组成元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">8.2.1.</span> <span class="toc-text">基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1-3"><span class="toc-number">8.2.2.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E7%BA%BF"><span class="toc-number">8.2.3.</span> <span class="toc-text">生命线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BF%80%E6%B4%BB"><span class="toc-number">8.2.4.</span> <span class="toc-text">激活</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF"><span class="toc-number">8.2.5.</span> <span class="toc-text">消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%9B%BE%E4%B8%AD%E7%9A%84%E7%BB%93%E6%9E%84%E5%8C%96%E6%8E%A7%E5%88%B6"><span class="toc-number">8.3.</span> <span class="toc-text">顺序图中的结构化控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%9B%BE%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF"><span class="toc-number">8.4.</span> <span class="toc-text">顺序图建模技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%9B%BE"><span class="toc-number">8.5.</span> <span class="toc-text">时间图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E5%9B%BE"><span class="toc-number">9.</span> <span class="toc-text">通信图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E5%9B%BE%E7%AE%80%E4%BB%8B"><span class="toc-number">9.1.</span> <span class="toc-text">通信图简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E5%9B%BE%E7%9A%84%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0"><span class="toc-number">9.2.</span> <span class="toc-text">通信图的组成元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1-4"><span class="toc-number">9.2.1.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE-2"><span class="toc-number">9.2.2.</span> <span class="toc-text">链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF-2"><span class="toc-number">9.2.3.</span> <span class="toc-text">消息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E5%9B%BE%E4%B8%8E%E9%A1%BA%E5%BA%8F%E5%9B%BE"><span class="toc-number">9.3.</span> <span class="toc-text">通信图与顺序图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E5%9B%BE%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF"><span class="toc-number">9.4.</span> <span class="toc-text">通信图建模技术</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E5%9B%BE"><span class="toc-number">10.</span> <span class="toc-text">状态机图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E5%9B%BE%E7%AE%80%E4%BB%8B"><span class="toc-number">10.1.</span> <span class="toc-text">状态机图简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E5%9B%BE%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">10.2.</span> <span class="toc-text">状态机图的组成部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81"><span class="toc-number">10.2.1.</span> <span class="toc-text">状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2"><span class="toc-number">10.2.2.</span> <span class="toc-text">转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">10.2.2.1.</span> <span class="toc-text">事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E6%8A%A4%E6%9D%A1%E4%BB%B6guard-condition"><span class="toc-number">10.2.2.2.</span> <span class="toc-text">监护条件 (guard condition)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%88%E6%9E%9C%E5%88%97%E8%A1%A8-effect-list"><span class="toc-number">10.2.2.3.</span> <span class="toc-text">效果列表 (effect list)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E7%8A%B6%E6%80%81"><span class="toc-number">10.2.3.</span> <span class="toc-text">伪状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%8A%B6%E6%80%81composite-state"><span class="toc-number">10.2.4.</span> <span class="toc-text">复合状态 (composite state)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%A4%8D%E5%90%88%E7%8A%B6%E6%80%81"><span class="toc-number">10.2.4.1.</span> <span class="toc-text">顺序复合状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%A4%8D%E5%90%88%E7%8A%B6%E6%80%81"><span class="toc-number">10.2.4.2.</span> <span class="toc-text">并发复合状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%E5%A4%8D%E5%90%88%E7%8A%B6%E6%80%81"><span class="toc-number">10.2.4.3.</span> <span class="toc-text">历史复合状态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA%E5%9B%BE%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF"><span class="toc-number">10.3.</span> <span class="toc-text">状态机图建模技术</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E5%9B%BE"><span class="toc-number">11.</span> <span class="toc-text">活动图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E5%9B%BE%E7%AE%80%E4%BB%8B"><span class="toc-number">11.1.</span> <span class="toc-text">活动图简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E5%9B%BE%E7%9A%84%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0"><span class="toc-number">11.2.</span> <span class="toc-text">活动图的组成元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E4%BD%9C"><span class="toc-number">11.2.1.</span> <span class="toc-text">动作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8-2"><span class="toc-number">11.2.2.</span> <span class="toc-text">活动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E7%AC%A6%E5%8F%B7"><span class="toc-number">11.2.3.</span> <span class="toc-text">开始符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2%E7%AC%A6%E5%8F%B7"><span class="toc-number">11.2.4.</span> <span class="toc-text">终止符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number">11.2.5.</span> <span class="toc-text">控制流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E8%8A%82%E7%82%B9"><span class="toc-number">11.2.6.</span> <span class="toc-text">判断节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E8%8A%82%E7%82%B9merging"><span class="toc-number">11.2.7.</span> <span class="toc-text">合并节点 (merging)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8F%89%E8%8A%82%E7%82%B9forking"><span class="toc-number">11.2.8.</span> <span class="toc-text">分叉节点 (forking)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%90%88%E8%8A%82%E7%82%B9joining"><span class="toc-number">11.2.9.</span> <span class="toc-text">结合节点 (joining)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%B3%E9%81%93swimlanes"><span class="toc-number">11.2.10.</span> <span class="toc-text">泳道 (swimlanes)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="toc-number">11.2.11.</span> <span class="toc-text">对象流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%8C%BA%E5%9F%9F"><span class="toc-number">11.2.12.</span> <span class="toc-text">扩展区域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BB%E5%8A%A8%E5%9B%BE%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF"><span class="toc-number">11.3.</span> <span class="toc-text">活动图建模技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%BB%BA%E6%A8%A1"><span class="toc-number">11.3.1.</span> <span class="toc-text">对工作流建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%93%8D%E4%BD%9C%E5%BB%BA%E6%A8%A1"><span class="toc-number">11.3.2.</span> <span class="toc-text">对操作建模</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%9B%BE"><span class="toc-number">12.</span> <span class="toc-text">组件图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%9B%BE%E7%AE%80%E4%BB%8B"><span class="toc-number">12.1.</span> <span class="toc-text">组件图简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%9B%BE%E7%9A%84%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0"><span class="toc-number">12.2.</span> <span class="toc-text">组件图的组成元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6-2"><span class="toc-number">12.2.1.</span> <span class="toc-text">组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3-3"><span class="toc-number">12.2.2.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3"><span class="toc-number">12.2.3.</span> <span class="toc-text">端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E4%BB%B6"><span class="toc-number">12.2.4.</span> <span class="toc-text">部件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E8%BF%9E%E6%8E%A5"><span class="toc-number">12.2.5.</span> <span class="toc-text">内部连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%9B%BE%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF"><span class="toc-number">12.3.</span> <span class="toc-text">组件图建模技术</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E5%9B%BE"><span class="toc-number">13.</span> <span class="toc-text">部署图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%AE%80%E4%BB%8B"><span class="toc-number">13.1.</span> <span class="toc-text">部署图简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E5%9B%BE%E7%9A%84%E7%BB%84%E6%88%90%E5%85%83%E7%B4%A0"><span class="toc-number">13.2.</span> <span class="toc-text">部署图的组成元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9node"><span class="toc-number">13.2.1.</span> <span class="toc-text">节点（node）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5connection"><span class="toc-number">13.2.2.</span> <span class="toc-text">连接（connection）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%83%A8%E7%BD%B2%E5%9B%BE%E5%BB%BA%E6%A8%A1%E6%8A%80%E6%9C%AF"><span class="toc-number">13.3.</span> <span class="toc-text">部署图建模技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1"><span class="toc-number">13.3.1.</span> <span class="toc-text">对嵌入式系统建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9cs-%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1"><span class="toc-number">13.3.2.</span> <span class="toc-text">对 C&#x2F;S 系统建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%85%A8%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1"><span class="toc-number">13.3.3.</span> <span class="toc-text">对全分布式系统建模</span></a></li></ol></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="KangKang" data-src="/images/avatar.jpg"><p class="name" itemprop="name">KangKang</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">10</span> <span class="name">文章</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tLzBrYW5na2FuZzA=" title="https:&#x2F;&#x2F;github.com&#x2F;0kangkang0"><i class="ic i-github"></i></span> <span class="exturl item csdn" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MTY2NjU1" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_15166655"><i class="ic i-csdn"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9rYW5na2FuZy02OC0xOC04OQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;kangkang-68-18-89"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTE2MjE4MTczMjA=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;1621817320"><i class="ic i-cloud-music"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/23/SSM%E6%A1%86%E6%9E%B6/" title="SSM框架">SSM框架</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/12/Java/" title="Java">Java</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/11/spring%E9%AB%98%E7%BA%A7/" title="spring高级">spring高级</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/23/JavaWeb/" title="JavaWeb">JavaWeb</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/11/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/11/MybatisPlus/" title="MybatisPlus">MybatisPlus</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/12/10/UML%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E3%80%81%E5%BB%BA%E6%A8%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1/" title="UML面向对象分析、建模与设计">UML面向对象分析、建模与设计</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/11/06/AJAX+Node.js+Webpack/" title="AJAX+Node.js+Webpack">AJAX+Node.js+Webpack</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/09/02/SpringBoot%E8%AE%B2%E4%B9%89/" title="springboot2">springboot2</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">KangKang @ kangkang</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div><div class="beian"><a href="https://beian.miit.gov.cn/" target="_blank">闽ICP备2023012662号</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/12/10/UML面向对象分析、建模与设计/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="/js/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->