<!-- build time:Mon Jan 01 2024 00:36:31 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="KangKang" href="https://blog.0kangkang0.top/rss.xml"><link rel="alternate" type="application/atom+xml" title="KangKang" href="https://blog.0kangkang0.top/atom.xml"><link rel="alternate" type="application/json" title="KangKang" href="https://blog.0kangkang0.top/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://blog.0kangkang0.top/2023/12/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"><title>软件测试基本原理与实践 | kangkang = KangKang</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">软件测试基本原理与实践</h1><div class="meta"><span class="item" title="创建时间：2023-12-25 16:23:05"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-12-25T16:23:05+08:00">2023-12-25</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">kangkang</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="/img/00044-4079796900.png"></li><li class="item" data-background-image="/img/00045-4079796901.png"></li><li class="item" data-background-image="/img/00041-166261796.png"></li><li class="item" data-background-image="/img/00043-4079796899.png"></li><li class="item" data-background-image="/img/00023-3349926003.png"></li><li class="item" data-background-image="/img/00039-3604723839.png"></li></ul></div><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div></header><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.0kangkang0.top/2023/12/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="KangKang"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="KangKang"></span><div class="body md" itemprop="articleBody"><h1 id="软件测试概述"><a class="anchor" href="#软件测试概述">#</a> 软件测试概述</h1><h2 id="软件测试产生的背景"><a class="anchor" href="#软件测试产生的背景">#</a> 软件测试产生的背景</h2><p>软件生存期分为六个步骤：计划（Planning）、需求分析（Requirement Analysis）、设计（Design）、程序编写（Coding）、测试（Testing）、运行和维护（Run and Maintenance）。<br><img data-src="/testing-img/IMG_20231223_224420.jpg" alt=""></p><h2 id="软件质量与质量模型"><a class="anchor" href="#软件质量与质量模型">#</a> 软件质量与质量模型</h2><p><strong>重点是 ISO</strong><br><img data-src="/testing-img/IMG_20231223_224831.jpg" alt=""><br><img data-src="/testing-img/IMG_20231223_224907.jpg" alt=""></p><h2 id="软件测试过程模型"><a class="anchor" href="#软件测试过程模型">#</a> 软件测试过程模型</h2><ul><li><strong>V 模型</strong><br><img data-src="/testing-img/IMG_20231223_225639.jpg" alt=""></li><li>W 模型<br><img data-src="/testing-img/IMG_20231223_225626.jpg" alt=""></li><li>H 模型<br><img data-src="/testing-img/IMG_20231223_225744.jpg" alt=""></li><li>X 模型<br><img data-src="/testing-img/IMG_20231223_225804.jpg" alt=""></li></ul><h1 id="软件测试分类及流程"><a class="anchor" href="#软件测试分类及流程">#</a> 软件测试分类及流程</h1><h2 id="软件测试分类"><a class="anchor" href="#软件测试分类">#</a> 软件测试分类</h2><h3 id="按照测试方法分类"><a class="anchor" href="#按照测试方法分类">#</a> 按照测试方法分类</h3><ol><li><strong>白盒测试</strong>：白盒测试又称结构测试或逻辑驱动测试，指通过对程序内部结构的分析、检测来寻找问题。</li><li><strong>黑盒测试</strong>：黑盒测试又称功能测试或数据驱动测试，指通过软件的外部表现来发现缺陷和错误。</li><li><strong>灰盒测试</strong>：灰盒测试介于白盒测试和黑盒测试之间，主要关注输出对于输入的正确性；同时也关注内部表现，但这种关注不像盒测试那么详细、完整，只是通过一些表征性的现象、事件、标志来判断内部的运行状态。</li></ol><h3 id="按照测试方式分类"><a class="anchor" href="#按照测试方式分类">#</a> 按照测试方式分类</h3><ol><li><strong>静态测试</strong>：不运行被测程序本身，仅通过分析或检查源程序的语法、结构、过程、接口等来检查程序的正确性。</li><li><strong>动态测试</strong>：通过运行被测程序，检查运行结果与预期结果的差异，并分析运行效率、正确性和健壮性等性能指标。</li></ol><h3 id="按照测试过程分类"><a class="anchor" href="#按照测试过程分类">#</a> 按照测试过程分类</h3><ol><li><strong>单元测试</strong>：单元测试又称模块测试、逻辑测试或结构测试，是针对软件设计的最小单位 —— 程序模块或功能模块，进行正确性检验的测试工作。</li><li><strong>集成测试</strong>：集成测试又称组装测试、综合测试或联合测试。通常在单元测试的基础上，将所有的程序模块进行有序的、递增的测试。集成测试是检验程序单元或部件的接口关系，逐步集成为符合概要设计要求的程序部件或整个系统。</li><li><strong>系统测试</strong>：系统测试为验证和确认系统是否达到其原始目标，而对集成的硬件和软件系统进行的测试。</li><li><strong>验收测试</strong>：验收测试又称交付测试，是软件在完成了单元测试、集成测试、系统测试之后，产品发布之前进行的软件测试活动。</li></ol><h3 id="按照测试目的分类"><a class="anchor" href="#按照测试目的分类">#</a> 按照测试目的分类</h3><ol><li><strong>功能测试</strong>：功能测试主要针对产品需求规格说明书对软件进行测试，逐项验证软件功能是否符合要求，包括对原定功能的检验和测试软件是否有冗余功能、遗漏功能。</li><li><strong>接口测试</strong>：接口测试指对各个模块进行系统联调的测试，包含程序内接口和程序外接口测试。</li><li><strong>用户界面测试</strong>：用户界面测试主要检查用户界面的风格是否满足客户的要求、界面是否友好、软件是否方便易用、系统设计是否合理、界面位置是否正确等问题。</li><li><strong>健壮性测试</strong>：健壮性测试侧重于对程序容错能力的测试，主要是验证程序在各种异常情况下是否能正确运行，包括数据边界测试、非法数据测试、异常中断测试等。</li><li><strong>性能测试</strong>：性能测试主要测试系统的性能是否满足用户要求，即在特定的运行条件下验证系统的能力状况。</li><li><strong>强度测试</strong>：强度测试是一种性能测试，强度测试总是迫使系统在异常的资源配置下运行，目的是找出因资源不足或资源争用而导致的错误</li><li><strong>压力测试</strong>：压力测试是一种性能测试，指在超负荷环境中，检验程序是否能够正常运行，检验系统的稳定性。</li><li><strong>负载测试</strong>：负载测试是一种性能测试，是通过测试系统在资源超负荷情况下的表现，以发现设计上的错误或验证系统的负载能力。</li><li><strong>安全性测试</strong>：安全测试主要测试系统防止非法侵入的能力，例如测试系统在没有授权的内部或者外部用户对系统进行攻击或者恶意破坏时如何运行，是否能够保证数据的安全。</li><li><strong>可靠性测试</strong>：可靠性测试是指在真实的或仿真的环境中，为了保证和验证软件的可靠性水平是否满足用户的要求而进行的测试，即确定软件是否满足软件规格说明书中规定的可靠性指标。</li><li><strong>恢复测试</strong>：恢复测试主要测试当出现系统崩溃、硬件错误或其他灾难性问题时系统的表现情况，以及系统从故障中恢复的能力。</li><li><strong>安装／卸载测试</strong>：安装测试主要检验软件是否可以正确安装，安装过程是否符合安装规程，安装文件的各项设置是否有效，安装后是否影响整个计算机系统；卸载测试是逆过程，测试软件是否被删除干净，删除后软件是否影响整个计算机系统等。</li><li><strong>兼容性测试</strong>：兼容性测试主要测试软件产品在不同的平台、不同的工具软件或相同工具软件的不同版本下的兼容性，其目的是测试系统与其他软件、硬件兼容的能力。</li><li><strong>文档测试</strong>：文档测试主要检查内部／外部文档的清晰性和准确性，对外部文档而言，测试工作主要针对用户的文档，以需求说明、用户手册、安装手册等为主，检验文档是否和实际应用存在差别，而且还必须考虑文档是否简单明了，相关的技术术语是否解释清楚等问题。</li></ol><h3 id="按照执行过程是否需要人工干预分类"><a class="anchor" href="#按照执行过程是否需要人工干预分类">#</a> 按照执行过程是否需要人工干预分类</h3><ol><li><strong>手工测试</strong>：测试人员按照事先为覆盖被测软件需求而编写的测试用例，根据测试大纲中所描述的测试步骤和方法，手工地一个一个地输入执行，包括与被测软件进行交互（如输入测试数据、记录测试结果等），然后观察测试结果，看被测程序是否存在问题，或在执行过程中是否会有异常发生，属于比较原始但是必须执行的一个步骤。</li><li><strong>自动测试</strong>：自动测试是将大量的重复性的测试工作交给计算机去完成，通常是使用自动测试工具来模拟手动测试步骤，执行用某种程序设计语言编写的过程（全自动测试就是指在自动测试过程中，不需要人工干预，由程序自动完成测试的全过程；半自动测试就是指在自动测试过程中，需要手动输人测试用例或选择测试路径，再由自动测试程序按照人工指定的要求完成自动测试）。</li></ol><h2 id="软件测试原则"><a class="anchor" href="#软件测试原则">#</a> 软件测试原则</h2><ol><li>尽早测试</li><li>全面测试</li><li>全过程测试</li><li>独立的、迭代的测试</li><li>Pareto 原则</li><li>对测试出的错误一定要有一个确认的过程</li><li>制定严格的测试计划</li><li>完全测试是不可能的，测试需要终止</li><li>注意回归测试的关联性</li><li>妥善保管一切测试过程的文档</li></ol><h2 id="软件测试用例"><a class="anchor" href="#软件测试用例">#</a> 软件测试用例</h2><p><strong>定义</strong>：测试用例作为测试工作的指导，是软件测试必须遵守的准则，是软件测试质量稳定的根本保障。</p><h3 id="测试用例设计原则"><a class="anchor" href="#测试用例设计原则">#</a> 测试用例设计原则</h3><ol><li><strong>基于测试需求的原则</strong>：按照测试类别的不同要求设计测试用例。</li><li><strong>用成熟测试用例设计方法来指导设计</strong>：在设计测试用例时，不能只凭借一些主观或直观的想法来设计测试用例，应该以些比较成熟的测试用例设计方法为指导，再加上设计人员个人的经验积累来设计测试用例，将测试设计思想与丰富的实践经验相融合才能设计出高品质的测试用例。</li><li><strong>兼顾测试充分性和效率的原则</strong>：测试用例集应兼顾测试的充分性和测试的效率，测试用例的内容都应完整，具有可操作性。</li><li><strong>测试执行的可再现性原则</strong>：应保证测试用例执行的可再现性。</li><li><strong>足够详细、准确和清晰的步骤</strong>：即使是一个对所要测试的内容根本不了解的新手，也能准确的按照所写的测试用例完成测试。</li></ol><h3 id="测试设计说明"><a class="anchor" href="#测试设计说明">#</a> 测试设计说明</h3><ol><li><strong>标识符</strong>：标识符是用于引用和定位测试设计说明的唯一标识。</li><li><strong>被测试的特性</strong>：被测试的特性指明所有要被测试的软件特性及其组合，指明与每个特性或特性组合有关的测试设计说明。</li><li><strong>方法</strong>：描述测试的总体方法，规定测试指定特性组所需的主要活动、技术和工具。</li><li><strong>测试用例信息</strong>：在这部分不定义实际测试用例，主要用于描述测试用例的相关信息。</li><li><strong>通过 / 失败规则</strong>：规定各测试项通过测试的标准，即描述用来判定某项特性的测试结果是通过还是失败的准则。</li></ol><h3 id="测试用例设计应避免的问题"><a class="anchor" href="#测试用例设计应避免的问题">#</a> 测试用例设计应避免的问题</h3><ol><li>把测试用例等同于测试输入数据的设计。</li><li>强调测试用例设计的 “越详细越好”</li><li>追求测试用例设计” 一步到位 “</li><li>将多个测试用例混在一个用例中</li><li>让没有测试经验的人员测试用例</li></ol><h3 id="测试用例分类"><a class="anchor" href="#测试用例分类">#</a> 测试用例分类</h3><ol><li>功能测试用例</li><li>性能测试用例</li><li>集成测试用例</li><li>安全性测试用例</li><li>用户界面测试用例</li><li>安装 / 反安装测试用例</li></ol><h1 id="黑盒测试"><a class="anchor" href="#黑盒测试">#</a> 黑盒测试</h1><h2 id="等价划分类"><a class="anchor" href="#等价划分类">#</a> 等价划分类</h2><h3 id="等价类分类"><a class="anchor" href="#等价类分类">#</a> 等价类分类</h3><ol><li><strong>有效等价类</strong>：对于程序规格说明而言，由合理的、有意义的输入数据构成的集合。</li><li><strong>无效等价类</strong>：对于程序规格说明而言，由不合理的、无意义的输入数据构成的集合。</li></ol><h3 id="等价类划分原则"><a class="anchor" href="#等价类划分原则">#</a> 等价类划分原则</h3><ol><li>在输入条件规定了取值范围或值的个数的情况下，可以确立一个有效等价类和两个无效等价类。</li><li>输入条件规定了输入值的集合或者规定了 &quot;必须如何&quot; 的条件的情况下，可确立一个有效等价类和一个无效等价类。</li><li>在输入条件是一个布尔量的情况下，可确定一个有效等价类和一个无效等价类。</li><li>在规定了输入数据的一组值（假定 n 个），并且程序要对每一个输入值分别处理的情况下，可以确认 n 个有效等价类和一个无效等价类</li><li>在规定了输入数据必须遵守的规则的情况下，可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）</li><li>在确知已划分的等价类中各元素在程序处理中的方式不同的情况下，则应再将该等价类进一步划分为更小的等价类。</li></ol><h2 id="边界值分析法"><a class="anchor" href="#边界值分析法">#</a> 边界值分析法</h2><h3 id="边界值分析法分类"><a class="anchor" href="#边界值分析法分类">#</a> 边界值分析法分类</h3><ol><li><strong>标准边界值测试只考虑有效数据范围内的边界值</strong>。对于一个有 n 个变量的程序，保留其中一个变量，其取值为最小值（Min)、略高于最小值（Min+)、正常值（Normal)、略低于最大值（Max-)、最大值（Max)，让其余变量取正常值，<em><strong>标准边界值分析测试程序会产生 4n+1 个测试用例</strong></em>。</li><li>健壮边界值测试会考虑有效和无效数据范围内的边界值。因此，对于一个含有 n 个变量的程序，保留其中一个变量，其取值为，其取值为略低于最小值（Min-)、最小值 (Min)、略高于最小值（Min+)、正常值（Normal)、略低于最大值（Max-)、最大值 (Max)，略高于最大值（Max+)，让其余变量取正常值，<em><strong>健壮边界值分析测试程序会产生 6n+1 个测试用例。</strong></em></li></ol><h2 id="因果图法"><a class="anchor" href="#因果图法">#</a> 因果图法</h2><h3 id="因果图的基本关系"><a class="anchor" href="#因果图的基本关系">#</a> 因果图的基本关系</h3><ol><li>恒等：若 c_1 是 1，则 e_1 也为 1，否则 e_1 为 0。</li><li>非（~)：若 c_1 是 1，则 e_1 为 0，否则 e_1 为 1。</li><li>或（V)：若 c_1 或 c_2 或 c_3 是 1，则 e_1 为 1，否则 e_1 为 0。</li><li>与（A)：若 c_1 和 c_2 都是 1，则 e_1 为 1，否则 e_1 为 0。<br><img data-src="/testing-img/IMG_20231224_233653.jpg" alt=""></li></ol><h3 id="因果图的约束"><a class="anchor" href="#因果图的约束">#</a> 因果图的约束</h3><h4 id="输入条件的约束有以下4种"><a class="anchor" href="#输入条件的约束有以下4种">#</a> 输入条件的约束有以下 4 种</h4><ol><li>E 约束（异，Exclusive):a 和 b 中至多有一个可能为 1，即 a 和 b 不能同时为 1。</li><li>I 约束（或，Inclusive):a、b 和 e 中至少有一个必须是 1，即 a、b、和 c 不能同时<br>为 0。</li><li>O 约束（唯一，One and Only): a 和 b 必须有一个，且有且仅有 1 个为 1。</li><li>R 约束（要求，Request):a 是 1 时，b 必须是 1，即不可能 a 是 1 时 b 是 0。</li></ol><h4 id="输出条件的约束类型"><a class="anchor" href="#输出条件的约束类型">#</a> 输出条件的约束类型</h4><p>输出条件的约束只有 M 约束（Masks，强制）：若结果 a 是 1，则结果 b 强制为 0</p><p><img data-src="/testing-img/IMG_20231224_233705.jpg" alt=""></p><h2 id="决策表法"><a class="anchor" href="#决策表法">#</a> 决策表法</h2><h2 id="正交测试法"><a class="anchor" href="#正交测试法">#</a> 正交测试法</h2><h2 id="错误推测法"><a class="anchor" href="#错误推测法">#</a> 错误推测法</h2><h2 id="场景法"><a class="anchor" href="#场景法">#</a> 场景法</h2><h1 id="白盒测试"><a class="anchor" href="#白盒测试">#</a> 白盒测试</h1><h2 id="动态白盒测试"><a class="anchor" href="#动态白盒测试">#</a> 动态白盒测试</h2><h3 id="逻辑覆盖测试法"><a class="anchor" href="#逻辑覆盖测试法">#</a> 逻辑覆盖测试法</h3><ol><li><strong>语句覆盖</strong>：语句覆盖要求设计足够多的测试用例，运行被测程序，使得程序中每条语句至少被执行一次。</li><li><strong>判定覆盖</strong>：判定覆盖，又称分支覆盖，要求设计足够多的测试用例，运行被测程序，使得程序中的每个判断的 &quot;真&quot; 和 &quot;假&quot; 分支都至少被执行一次。</li><li><strong>条件覆盖</strong>：条件覆盖要求设计足够多的测试用例，运行被测程序，使得判定中的每个条件获得各种可能的结果，即每个条件至少有一次为真值，有一次为假值。</li><li><strong>判定 —— 条件覆盖</strong>：判定 —— 条件覆盖要求设计足够多的测试用例，运行被测程序，使得被测试程序中的每个判断本身的判定结果（真／假）至少满足一次，同时，每个逻辑条件的可能值也至少被满足一次。</li><li><strong>条件组合覆盖</strong>：条件组合覆盖要求设计足够多的测试用例，运行被测程序，使得被测试程序中每个判定中条件结果的所有可能组合至少执行一次。</li><li><strong>路径测试</strong>：路径测试要求设计足够的测试用例，运行被测程序，覆盖程序中所有可能的路径。</li></ol><h1 id="单元测试"><a class="anchor" href="#单元测试">#</a> 单元测试</h1><p>考 Junit</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Test</td><td>表示方法是测试方法。与 JUnit 4 的 @Test 注释不同，这个注释不声明任何属性，因为 JUnit Jupiter 中的测试扩展基于它们自己的专用注释进行操作。</td></tr><tr><td>@ParameterizedTest</td><td>表示方法是参数化测试。</td></tr><tr><td>@RepeatedTest</td><td>表示方法是重复测试的测试模板。</td></tr><tr><td>@TestFactory</td><td>表示方法是动态测试的测试工厂。</td></tr><tr><td>@TestInstance</td><td>用于为带注释的测试类配置测试实例生命周期。</td></tr><tr><td>@TestTemplate</td><td>表示方法是为测试用例设计的模板，根据注册提供程序返回的调用上下文的数量进行多次调用。</td></tr><tr><td>@DisplayName</td><td>声明测试类或测试方法的自定义显示名称。</td></tr><tr><td>@BeforeEach</td><td>表示在当前类中每个 @Test、@RepeatedTest、@ParameterizedTest 或 @TestFactory 方法之前执行注释的方法；类似于 JUnit 4 的 @Before。</td></tr><tr><td>@AfterEach</td><td>表示在当前类中的每个 @Test、@RepeatedTest、@ParameterizedTest 或 @TestFactory 方法之后，都应该执行带注释的方法；类似于 JUnit 4 的 @After。</td></tr><tr><td>@BeforeAll</td><td>表示应在当前类中的所有 @Test、@RepeatedTest、@ParameterizedTest 和 @TestFactory 方法之前执行带注释的方法；类似于 JUnit 4 的 @BeforeClass。</td></tr><tr><td>@AfterAll</td><td>表示在当前类中，所有 @Test、@RepeatedTest、@ParameterizedTest 和 @TestFactory 方法都应该执行注释的方法；类似于 JUnit 4 的 @AfterClass。</td></tr><tr><td>@Nested</td><td>表示带注释的类是一个嵌套的、非静态的测试类。@BeforeAll 和 @AfterAll 方法不能直接在 @Nested 测试类中使用，除非使用 “每个类” 测试实例生命周期。</td></tr><tr><td>@Tag</td><td>用于在类或方法级别声明过滤测试的标记；类似于 TestNG 中的测试组或 JUnit 4 中的类别。</td></tr><tr><td>@Disabled</td><td>用于禁用测试类或测试方法；类似于 JUnit 4 的 @Ignore。</td></tr><tr><td>@ExtendWith</td><td>用于注册自定义扩展。</td></tr></tbody></table><table><thead><tr><th>方法名称</th><th>方法描述</th></tr></thead><tbody><tr><td>assertEquals</td><td>断言传入的预期值与实际值是相等的。</td></tr><tr><td>assertNotEquals</td><td>断言传入的预期值与实际值是不相等的。</td></tr><tr><td>assertArayEquals</td><td>断言传入的预期数组与实际数组是相等的。</td></tr><tr><td>assertNull</td><td>断言传入的对象是为空。</td></tr><tr><td>assertNotNull</td><td>断言传入的对象是不为空。</td></tr><tr><td>assertTrue</td><td>断言条件为真。</td></tr><tr><td>assertFalse</td><td>断言条件为假。</td></tr><tr><td>assertSame</td><td>断言两个对象引用同一个对象，相当于 &quot;==&quot;。</td></tr><tr><td>assertNotSame</td><td>断言两个对象引用不同的对象，相当于 &quot;!=&quot;。</td></tr><tr><td>assertThat</td><td>断言实际值是否满足指定的条件。</td></tr></tbody></table><h1 id="集成测试"><a class="anchor" href="#集成测试">#</a> 集成测试</h1><h2 id="集成测试方法"><a class="anchor" href="#集成测试方法">#</a> 集成测试方法</h2><h3 id="非增量式集成测试"><a class="anchor" href="#非增量式集成测试">#</a> 非增量式集成测试</h3><h4 id="非增量式集成测试步骤"><a class="anchor" href="#非增量式集成测试步骤">#</a> 非增量式集成测试步骤</h4><ol><li>对软件单元 A 进行测试。</li><li>对软件单元 B 进行测试。</li><li>对软件单元 C 和软件单元 D 进行测试。<br><img data-src="/testing-img/IMG_20231225_154540.jpg" alt=""><br><img data-src="/testing-img/IMG_20231225_154558.jpg" alt=""></li></ol><h4 id="非增量式集成测试的优点"><a class="anchor" href="#非增量式集成测试的优点">#</a> 非增量式集成测试的优点。</h4><ol><li>非增量式集成测试可以并行地测试所有的软件单元，能够加快测试工作的速度，充分利用了人力和物力资源。</li><li>非增量式集成测试需要用到测试用例数量较少，因此，对设计测试用例的工作量相对较小。</li><li>非增量式集成测试的测试方法较为简单，容易执行。</li></ol><h4 id="非增量测试的缺点"><a class="anchor" href="#非增量测试的缺点">#</a> 非增量测试的缺点</h4><ol><li>非增量式集成测试是将软件单元一次性集成起来，如果集成的软件单元数量较多，集成测试过程中可能会出现较多的错误，而且因为一次性集成，很难判断出现错误的位置。而且，在对某个软件单元的某处错误进行修改之后，可能会在系统的其他地方带来新的错误，这样给整个系统的修正会带来较大的难度。</li><li>非增量式集成测试因为是一次性集成，各个软件单元之间的接口没有进行充分的测试，因此，有可能会遗漏一些潜在的接口错误，即使在集成测试通过，这些接口可能也会存在问题。</li></ol><h4 id="非增量式集成测试的适用范围"><a class="anchor" href="#非增量式集成测试的适用范围">#</a> 非增量式集成测试的适用范围</h4><ol><li>适用于功能单一，所组成的软件单元不多，运行逻辑较为简单的，并且每个软件单元都经过充分的单元测试的小型软件项目。</li><li>适用于那些在前期已经有较为稳定的产品的项目，而且只需要修改和增加为数不多的几个软件单元。</li></ol><h3 id="增量式集成测试"><a class="anchor" href="#增量式集成测试">#</a> 增量式集成测试⭐⭐⭐</h3><h4 id="自顶向下集成"><a class="anchor" href="#自顶向下集成">#</a> 自顶向下集成</h4><h5 id="自顶向下集成测试的步骤"><a class="anchor" href="#自顶向下集成测试的步骤">#</a> 自顶向下集成测试的步骤。</h5><ol><li>保证所有需要集成在一起的软件单元都必须已经通过了单元测试。</li><li>将主控模块作为测试用驱动模块，所有与主控模块直接相连的软件单元作为测试用被调用模拟子模块。</li><li>根据集成的方式，深度优先或者是广度优先，逐步使用实际的软件单元替换相应的下层被调用模拟子模块，再用被调用模拟子模块代替它们的下属模块，与已经通过测试的软件单元或子系统组装成新的子系统。</li><li>进行回归测试（重新执行以前做过的全部或部分测试），来确定所有集成新软件单元后没有对整个系统引入新的错误。</li><li>从第③步开始重复执行，一直到所有的软件单元都已经集成到系统中。</li></ol><h5 id="自顶向下增量式集成测试的优点"><a class="anchor" href="#自顶向下增量式集成测试的优点">#</a> 自顶向下增量式集成测试的优点</h5><ol><li>在集成测试的过程当中，可以首先验证主要的控制和判断点，即主控软件单元，在功能划分合理的程序模块结构中，对于较高层次中的主控软件单元，可以首先做出测试，能够提前发现问题，以便及时对程序做出相应的修改，减少人力资源消耗。</li><li>选择深度优先的集成方式，可以首先实现和验证一个完整的软件功能，能够首先对逻辑输入的分支进行组装和测试，检测出潜在的错误和缺陷，验证其功能的正确性，为之后的主要分支的组装和测试提供保证。</li><li>能够较早的验证软件功能的可用性，给软件的开发者和软件的用户奠定了信心。在通常的情况下，几乎不用设计和开发测试用驱动程序，大大减少测试用驱动程序的开发和维护的成本。</li></ol><h5 id="自顶向下增量式集成测试的缺点"><a class="anchor" href="#自顶向下增量式集成测试的缺点">#</a> 自顶向下增量式集成测试的缺点</h5><ol><li>采用自顶向下的集成测试方法，在测试时需要给每个软件单元的下层软件单元设计开发测试用被调用模拟子模块，对于被调用模拟子模块的开发和维护成本较大。</li><li>当底层的软件单元发生变更时，例如，需求发生变化导致软件单元发生变化，这种变更可能会影响到整个软件中的其他软件单元，可能会需要修改整个软件系统中的多个上层软件单元，进而容易破坏之前构造的已经构造好的测试包。</li><li>随着自顶向下集成测试的进行，新的底层软件单元不断加入，这会让整个系统变得越来越复杂，可能会导致之后加入的底层软件单元的测试不够充分。</li></ol><h5 id="自顶向下增量式集成测试的适用范围"><a class="anchor" href="#自顶向下增量式集成测试的适用范围">#</a> 自顶向下增量式集成测试的适用范围</h5><ol><li>被测软件系统的结构较为清晰，控制结构较为稳定</li><li>被测软件系统中的高层模块接口定义较为准确，变化的可能性较小</li><li>被测软件系统中的低层模块接口定义还未清晰或有较大可能会因为需求发生变更等原因而发生变化</li><li>开发者和用户希望尽可能早的看到被测软件系统较为完整的功能</li></ol><h4 id="自底向上集成"><a class="anchor" href="#自底向上集成">#</a> 自底向上集成</h4><h5 id="自底向上集成测试的步骤"><a class="anchor" href="#自底向上集成测试的步骤">#</a> 自底向上集成测试的步骤</h5><ol><li>保证所有需要集成在一起的软件单元，都必须已经通过了单元测试。</li><li>从最底层的软件单元开始组装，组装成一个能够完成软件子功能的构件。</li><li>编写驱动程序。</li><li>测试集成后的构件。</li><li>使用实际的软件单元替换相应的驱动程序，按程序结构向上组装测试后的构件。</li></ol><p>其中，从第③步开始重复执行，一直到所有的最顶层的软件单元都已经集成到系统中<br>为止。</p><h5 id="自底向上增量式集成测试的优点"><a class="anchor" href="#自底向上增量式集成测试的优点">#</a> 自底向上增量式集成测试的优点</h5><ol><li>能够尽早验证底层软件单元的功能。任何一个底层软件单元通过单元测试之后，都可以开始进行集成测试。</li><li>在集成测试开始时，可以同时对系统层次结构中的每个分支集成测试，这样较大提高了测试的效率。</li><li>减少了设计开发测试用被调用模拟子模块的工作量。</li><li>更容易对被测系统的错误进行定位。</li></ol><h5 id="自底向上增量式集成测试的缺点"><a class="anchor" href="#自底向上增量式集成测试的缺点">#</a> 自底向上增量式集成测试的缺点</h5><ol><li>只有在被测系统的最顶层的最后一个软件单元组装起来之后才能看到整个系统的框架。</li><li>测试用驱动模块的开发和维护工作量大。</li><li>由于顶层的软件单元要到集成测试的最后阶段才能进行测试，所以不能及时发现高层模块设计上的错误，对于那些在整个体系结构中控制结构非常关键的产品来说，受到的影响就更大。</li></ol><h5 id="自底向上增量式集成测试的适用范围"><a class="anchor" href="#自底向上增量式集成测试的适用范围">#</a> 自底向上增量式集成测试的适用范围</h5><ol><li>底层模块接口比较稳定的软件系统</li><li>高层模块接口可能会存在变更比较频繁的软件系统</li><li>底层模块开发和单元测试工作完成较早的产品</li></ol><h4 id="三明治集成"><a class="anchor" href="#三明治集成">#</a> “三明治” 集成</h4><h5 id="三明治集成测试方法的基本步骤"><a class="anchor" href="#三明治集成测试方法的基本步骤">#</a> &quot;三明治&quot; 集成测试方法的基本步骤。</h5><ol><li>确定以哪一层作为运用 &quot;三明治&quot; 集成测试方法的分界层。</li><li>对分界层及其所在层下面的各个层次使用自底向上的集成测试方法。</li><li>对分界层上面的各个层次使用自顶向下的集成测试方法。</li><li>对被测系统进行整体测试。</li></ol><h5 id="三明治集成测试的优点"><a class="anchor" href="#三明治集成测试的优点">#</a> &quot;三明治&quot; 集成测试的优点</h5><ol><li>同时具有自顶向下集成测试和自底向上集成策略的优点。</li><li>通过一定集成技巧，可以减少被调用模拟子模块和驱动模块的开发。</li></ol><h5 id="三明治集成测试的缺点"><a class="anchor" href="#三明治集成测试的缺点">#</a> &quot;三明治&quot; 集成测试的缺点</h5><p>在被集成之前，中间层不能够尽早得到充分的测试。</p><h5 id="三明治集成测试的适用范围"><a class="anchor" href="#三明治集成测试的适用范围">#</a> &quot;三明治&quot; 集成测试的适用范围。</h5><p>&quot;三明治&quot; 集成测试适用范围广泛，大多数的软件开发项目都可以应用这种集成测试<br>的方法。</p><h1 id="系统测试"><a class="anchor" href="#系统测试">#</a> 系统测试</h1><p><span class="exturl" data-url="aHR0cHM6Ly9qbWV0ZXIueGluaXVzaHUuY29tLw==">JMeter</span></p><h1 id="验收测试"><a class="anchor" href="#验收测试">#</a> 验收测试</h1><h2 id="α测试"><a class="anchor" href="#α测试">#</a> α 测试</h2><ol><li>它是在开发环境下进行的（不对外发布）</li><li>它不需要测试用例评价软件使用质量</li><li>用户往往没有相关经验，可以是兼职人员，开发者或测试者坐用户旁边</li><li>目的主要评价软件产品的 FLURS－Function、Location、Usability、reliability、Performance、Security 即功能、局域化、可用性、可靠性、性能和技术支持.</li></ol><h2 id="β测试"><a class="anchor" href="#β测试">#</a> β 测试</h2><p>软件的多个用户在一个或多个用户的实际使用环境下进行的测试。开发者通常不在测试现场，Beta 测试不能由程序员或测试员完成。</p><h1 id="其他测试技术"><a class="anchor" href="#其他测试技术">#</a> 其他测试技术</h1><h2 id="功能测试"><a class="anchor" href="#功能测试">#</a> 功能测试</h2><p>Functional testing (功能测试)，又称 behavioral testing (行为测试)，根据产品特性、操作描述和用户场景，测试产品的特征和可操作行为，以确定其满足设计需求。功能测试软件，用来验证应用程序或网站是否能够为目标用户正常工作。</p><h2 id="回归测试"><a class="anchor" href="#回归测试">#</a> 回归测试</h2><p>回归测试是软件开发过程质量控制措施的一个重要方面，用于验证最近对软件的更改或更新是否无意中引入了新错误或对以前的功能方面产生了负面影响。</p><h2 id="性能测试"><a class="anchor" href="#性能测试">#</a> 性能测试</h2><p>性能测试（Performance Test）就是为了发现系统性能问题或获取系统性能相关指标而进行的测试。</p><h3 id="衡量指标"><a class="anchor" href="#衡量指标">#</a> 衡量指标</h3><ol><li>响应时间<ul><li>服务端响应时间</li><li>网络响应时间</li><li>客户端响应时间</li></ul></li><li>吞吐量</li><li>资源使用率</li><li>点击数</li><li>并发用户数</li></ol><h2 id="冒烟测试"><a class="anchor" href="#冒烟测试">#</a> 冒烟测试</h2><p>冒烟测试是软件测试中的一项基础测试，用于快速验证系统的关键功能能是否正常运作。</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-12-25 16:30:29" itemprop="dateModified" datetime="2023-12-25T16:30:29+08:00">2023-12-25</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="KangKang 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="KangKang 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>kangkang <i class="ic i-at"><em>@</em></i>KangKang</li><li class="link"><strong>本文链接：</strong> <a href="https://blog.0kangkang0.top/2023/12/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/" title="软件测试基本原理与实践">https://blog.0kangkang0.top/2023/12/25/软件测试基本原理与实践/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/12/10/UML%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E3%80%81%E5%BB%BA%E6%A8%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="prev" data-background-image="&#x2F;img&#x2F;00048-4079796904.png" title="UML面向对象分析、建模与设计"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>UML面向对象分析、建模与设计</h3></a></div><div class="item right"><a href="/2024/01/01/Linux/" itemprop="url" rel="next" data-background-image="&#x2F;img&#x2F;00051-1748877502.png" title="Linux"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>Linux</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">软件测试概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%BA%A7%E7%94%9F%E7%9A%84%E8%83%8C%E6%99%AF"><span class="toc-number">1.1.</span> <span class="toc-text">软件测试产生的背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E4%B8%8E%E8%B4%A8%E9%87%8F%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">软件质量与质量模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">软件测试过程模型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB%E5%8F%8A%E6%B5%81%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">软件测试分类及流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">软件测试分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.1.</span> <span class="toc-text">按照测试方法分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E6%B5%8B%E8%AF%95%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.2.</span> <span class="toc-text">按照测试方式分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E6%B5%8B%E8%AF%95%E8%BF%87%E7%A8%8B%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.3.</span> <span class="toc-text">按照测试过程分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E6%B5%8B%E8%AF%95%E7%9B%AE%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.4.</span> <span class="toc-text">按照测试目的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E4%BA%BA%E5%B7%A5%E5%B9%B2%E9%A2%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.5.</span> <span class="toc-text">按照执行过程是否需要人工干预分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%8E%9F%E5%88%99"><span class="toc-number">2.2.</span> <span class="toc-text">软件测试原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="toc-number">2.3.</span> <span class="toc-text">软件测试用例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">2.3.1.</span> <span class="toc-text">测试用例设计原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E"><span class="toc-number">2.3.2.</span> <span class="toc-text">测试设计说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1%E5%BA%94%E9%81%BF%E5%85%8D%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.3.3.</span> <span class="toc-text">测试用例设计应避免的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%88%86%E7%B1%BB"><span class="toc-number">2.3.4.</span> <span class="toc-text">测试用例分类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">3.</span> <span class="toc-text">黑盒测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E5%88%92%E5%88%86%E7%B1%BB"><span class="toc-number">3.1.</span> <span class="toc-text">等价划分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%86%E7%B1%BB"><span class="toc-number">3.1.1.</span> <span class="toc-text">等价类分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E4%BB%B7%E7%B1%BB%E5%88%92%E5%88%86%E5%8E%9F%E5%88%99"><span class="toc-number">3.1.2.</span> <span class="toc-text">等价类划分原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E5%80%BC%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text">边界值分析法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C%E5%80%BC%E5%88%86%E6%9E%90%E6%B3%95%E5%88%86%E7%B1%BB"><span class="toc-number">3.2.1.</span> <span class="toc-text">边界值分析法分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%A0%E6%9E%9C%E5%9B%BE%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">因果图法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%A0%E6%9E%9C%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%85%B3%E7%B3%BB"><span class="toc-number">3.3.1.</span> <span class="toc-text">因果图的基本关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%A0%E6%9E%9C%E5%9B%BE%E7%9A%84%E7%BA%A6%E6%9D%9F"><span class="toc-number">3.3.2.</span> <span class="toc-text">因果图的约束</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%9D%A1%E4%BB%B6%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9C%89%E4%BB%A5%E4%B8%8B4%E7%A7%8D"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">输入条件的约束有以下 4 种</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%9D%A1%E4%BB%B6%E7%9A%84%E7%BA%A6%E6%9D%9F%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">输出条件的约束类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%B3%E7%AD%96%E8%A1%A8%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">决策表法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E4%BA%A4%E6%B5%8B%E8%AF%95%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text">正交测试法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%8E%A8%E6%B5%8B%E6%B3%95"><span class="toc-number">3.6.</span> <span class="toc-text">错误推测法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E6%B3%95"><span class="toc-number">3.7.</span> <span class="toc-text">场景法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">4.</span> <span class="toc-text">白盒测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">4.1.</span> <span class="toc-text">动态白盒测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%A6%86%E7%9B%96%E6%B5%8B%E8%AF%95%E6%B3%95"><span class="toc-number">4.1.1.</span> <span class="toc-text">逻辑覆盖测试法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">5.</span> <span class="toc-text">单元测试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="toc-number">6.</span> <span class="toc-text">集成测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">集成测试方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%A2%9E%E9%87%8F%E5%BC%8F%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="toc-number">6.1.1.</span> <span class="toc-text">非增量式集成测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%A2%9E%E9%87%8F%E5%BC%8F%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E6%AD%A5%E9%AA%A4"><span class="toc-number">6.1.1.1.</span> <span class="toc-text">非增量式集成测试步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%A2%9E%E9%87%8F%E5%BC%8F%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">6.1.1.2.</span> <span class="toc-text">非增量式集成测试的优点。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%A2%9E%E9%87%8F%E6%B5%8B%E8%AF%95%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">6.1.1.3.</span> <span class="toc-text">非增量测试的缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%A2%9E%E9%87%8F%E5%BC%8F%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E7%9A%84%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">6.1.1.4.</span> <span class="toc-text">非增量式集成测试的适用范围</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%BC%8F%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="toc-number">6.1.2.</span> <span class="toc-text">增量式集成测试⭐⭐⭐</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E9%9B%86%E6%88%90"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">自顶向下集成</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">6.1.2.1.1.</span> <span class="toc-text">自顶向下集成测试的步骤。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%A2%9E%E9%87%8F%E5%BC%8F%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">6.1.2.1.2.</span> <span class="toc-text">自顶向下增量式集成测试的优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%A2%9E%E9%87%8F%E5%BC%8F%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">6.1.2.1.3.</span> <span class="toc-text">自顶向下增量式集成测试的缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E5%A2%9E%E9%87%8F%E5%BC%8F%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E7%9A%84%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">6.1.2.1.4.</span> <span class="toc-text">自顶向下增量式集成测试的适用范围</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E9%9B%86%E6%88%90"><span class="toc-number">6.1.2.2.</span> <span class="toc-text">自底向上集成</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">6.1.2.2.1.</span> <span class="toc-text">自底向上集成测试的步骤</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E5%A2%9E%E9%87%8F%E5%BC%8F%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">6.1.2.2.2.</span> <span class="toc-text">自底向上增量式集成测试的优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E5%A2%9E%E9%87%8F%E5%BC%8F%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">6.1.2.2.3.</span> <span class="toc-text">自底向上增量式集成测试的缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%87%AA%E5%BA%95%E5%90%91%E4%B8%8A%E5%A2%9E%E9%87%8F%E5%BC%8F%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E7%9A%84%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">6.1.2.2.4.</span> <span class="toc-text">自底向上增量式集成测试的适用范围</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E6%98%8E%E6%B2%BB%E9%9B%86%E6%88%90"><span class="toc-number">6.1.2.3.</span> <span class="toc-text">“三明治” 集成</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%98%8E%E6%B2%BB%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4"><span class="toc-number">6.1.2.3.1.</span> <span class="toc-text">&quot;三明治&quot; 集成测试方法的基本步骤。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%98%8E%E6%B2%BB%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">6.1.2.3.2.</span> <span class="toc-text">&quot;三明治&quot; 集成测试的优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%98%8E%E6%B2%BB%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">6.1.2.3.3.</span> <span class="toc-text">&quot;三明治&quot; 集成测试的缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E6%98%8E%E6%B2%BB%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E7%9A%84%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">6.1.2.3.4.</span> <span class="toc-text">&quot;三明治&quot; 集成测试的适用范围。</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95"><span class="toc-number">7.</span> <span class="toc-text">系统测试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AA%8C%E6%94%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">8.</span> <span class="toc-text">验收测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%CE%B1%E6%B5%8B%E8%AF%95"><span class="toc-number">8.1.</span> <span class="toc-text">α 测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%CE%B2%E6%B5%8B%E8%AF%95"><span class="toc-number">8.2.</span> <span class="toc-text">β 测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%B5%8B%E8%AF%95%E6%8A%80%E6%9C%AF"><span class="toc-number">9.</span> <span class="toc-text">其他测试技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-number">9.1.</span> <span class="toc-text">功能测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E5%BD%92%E6%B5%8B%E8%AF%95"><span class="toc-number">9.2.</span> <span class="toc-text">回归测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-number">9.3.</span> <span class="toc-text">性能测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A1%E9%87%8F%E6%8C%87%E6%A0%87"><span class="toc-number">9.3.1.</span> <span class="toc-text">衡量指标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E7%83%9F%E6%B5%8B%E8%AF%95"><span class="toc-number">9.4.</span> <span class="toc-text">冒烟测试</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="KangKang" data-src="/images/avatar.jpg"><p class="name" itemprop="name">KangKang</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">12</span> <span class="name">文章</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tLzBrYW5na2FuZzA=" title="https:&#x2F;&#x2F;github.com&#x2F;0kangkang0"><i class="ic i-github"></i></span> <span class="exturl item csdn" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MTY2NjU1" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_15166655"><i class="ic i-csdn"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9rYW5na2FuZy02OC0xOC04OQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;kangkang-68-18-89"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTE2MjE4MTczMjA=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;1621817320"><i class="ic i-cloud-music"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/12/10/UML%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E3%80%81%E5%BB%BA%E6%A8%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2024/01/01/Linux/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/11/MybatisPlus/" title="MybatisPlus">MybatisPlus</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/12/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/" title="软件测试基本原理与实践">软件测试基本原理与实践</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/01/01/Linux/" title="Linux">Linux</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/11/06/AJAX+Node.js+Webpack/" title="AJAX+Node.js+Webpack">AJAX+Node.js+Webpack</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/09/02/SpringBoot%E8%AE%B2%E4%B9%89/" title="springboot2">springboot2</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/23/JavaWeb/" title="JavaWeb">JavaWeb</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/12/Java/" title="Java">Java</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/23/SSM%E6%A1%86%E6%9E%B6/" title="SSM框架">SSM框架</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/11/spring%E9%AB%98%E7%BA%A7/" title="spring高级">spring高级</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/11/hello-world/" title="Hello World">Hello World</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2023 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">KangKang @ kangkang</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div><div class="beian"><a href="https://beian.miit.gov.cn/" target="_blank">闽ICP备2023012662号</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/12/25/软件测试基本原理与实践/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="/js/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->