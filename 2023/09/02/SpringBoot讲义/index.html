<!-- build time:Sat Sep 02 2023 16:36:15 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="KangKang" href="https://blog.0kangkang0.top/rss.xml"><link rel="alternate" type="application/atom+xml" title="KangKang" href="https://blog.0kangkang0.top/atom.xml"><link rel="alternate" type="application/json" title="KangKang" href="https://blog.0kangkang0.top/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://blog.0kangkang0.top/2023/09/02/SpringBoot%E8%AE%B2%E4%B9%89/"><title>springboot2 | kangkang = KangKang</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">springboot2</h1><div class="meta"><span class="item" title="创建时间：2023-09-02 15:09:36"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-09-02T15:09:36+08:00">2023-09-02</time></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">kangkang</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="/img/00045-4079796901.png"></li><li class="item" data-background-image="/img/00043-4079796899.png"></li><li class="item" data-background-image="/img/00019-31337.png"></li><li class="item" data-background-image="/img/00049-4079796905.png"></li><li class="item" data-background-image="/img/00009-2312059879.png"></li><li class="item" data-background-image="/img/00038-207222746.png"></li></ul></div><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div></header><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.0kangkang0.top/2023/09/02/SpringBoot%E8%AE%B2%E4%B9%89/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="KangKang"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="KangKang"></span><div class="body md" itemprop="articleBody"><h1 id="springboot"><a class="anchor" href="#springboot">#</a> SpringBoot</h1><h3 id="文档更新日志"><a class="anchor" href="#文档更新日志">#</a> 文档更新日志</h3><table><thead><tr><th>版本</th><th>更新日期</th><th>操作</th><th>描述</th></tr></thead><tbody><tr><td>v1.0</td><td>2021/11/14</td><td>A</td><td>基础篇</td></tr><tr><td>v1.0.1</td><td>2021/11/30</td><td>U</td><td>更新基础篇错别字若干，不涉及内容变更</td></tr><tr><td>v2.0</td><td>2021/12/01</td><td>A</td><td>运维实用篇</td></tr><tr><td>V3.0</td><td>2022/2/21</td><td>A</td><td>开发实用篇</td></tr><tr><td>V4.0</td><td>2022/3/29</td><td>A</td><td>原理篇</td></tr></tbody></table><h3 id="前言"><a class="anchor" href="#前言">#</a> 前言</h3><p>​ 很荣幸有机会能以这样的形式和互联网上的各位小伙伴一起学习交流技术课程，这次给大家带来的是 Spring 家族中比较重要的一门技术课程 ——SpringBoot。一句话介绍这个技术，应该怎么说呢？现在如果开发 Spring 程序不用 SpringBoot 那就是给自己过不去，SpringBoot 为我们开发 Spring 程序提供了太多的帮助，在此借这个机会给大家分享这门课程，希望各位小伙伴学有所得，学有所用，学有所成。</p><p>​ 正如上面提到的，这门技术是用来加速开发 Spring 程序的，因此学习这门技术是有一定的门槛的。你可以理解为你现在是一门传统的手工艺人，现在工艺升级，可以加速你的生产制作过程，但是前提是你要会原始工艺，然后才能学习新的工艺。嗯，怎么说呢？有一定的门槛，至少 Spring 怎么回事，与 Spring 配合在一起工作的一堆技术又是怎么回事，这些搞明白才能来看这个技术，不然就只能学个皮毛，或者学着学着就开始因为其他技术不太过关，然后就学不下去了，然后，就没有然后了，果断弃坑了。不管怎么说，既来之则安之，加油学习吧，投资自己肯定是没毛病的。</p><h3 id="课程内容说明"><a class="anchor" href="#课程内容说明">#</a> 课程内容说明</h3><p>​ SpringBoot 这门技术课程所包含的技术点其实并不是很多，但是围绕着 SpringBoot 的周边知识，也就是 SpringBoot 整合其他技术，这样的知识量很大，例如 SpringBoot 整合 MyBatis 等等。因此为了能够将本课程制作的能够适应于各个层面的学习者进行学习，本套课程会针对小白，初学者，开发者三种不同的人群来设计全套课程。具体这三种人群如何划分，就按照我的描述形式来分吧，各位小伙伴可以对号入座，每种人群看课程的起始位置略有差别。</p><table><thead><tr><th>学习者</th><th>归类方式</th></tr></thead><tbody><tr><td><strong>小白</strong></td><td>完全没有用过 SpringBoot 技术</td></tr><tr><td><strong>初学者</strong></td><td>能使用 SpringBoot 技术完成基础的 SSM 整合</td></tr><tr><td><strong>开发者</strong></td><td>能使用 SpringBoot 技术实现常见的技术整合工作</td></tr></tbody></table><p>​ 简单说就是你能用 SpringBoot 做多少东西，一点不会就是小白，会一点就是初学者，大部分都会就是开发者。其实这个划分也不用过于纠结，这个划分仅仅是为了帮助你对本技术课程所包含的阶段模块划分做一个清晰认知，因为本课程中会将 SpringBoot 技术划分成 4 个单元，每个单元是针对不同的学习者准备的。</p><table><thead><tr><th>学习者</th><th>课程单元</th></tr></thead><tbody><tr><td><strong>小白</strong></td><td><span class="#ff0000 border">基础篇</span></td></tr><tr><td><strong>初学者</strong></td><td><span class="#cc0000 border">应用篇</span>（ 运维实用篇 &amp; 开发实用篇 ）</td></tr><tr><td><strong>开发者</strong></td><td><span class="#990000 border">原理篇</span></td></tr></tbody></table><p>​ 看完这个划分你就应该有这么个概念，我没有用过 SpringBoot 技术，所以从基础篇开始学习；或者我会一点 SpringBoot 技术，那我从实用篇开始学就好了，就是这个意思。</p><p>​ 每个课程单元内容设置不同，目标也不一样，作为学习者如果想达成最佳的学习效果，最好明确自己的学习目标再进行学习，这样目标明确，学习的时候能够更轻松，你就不会在学习的时候纠结如下的问题了。比如学着<span class="#ff0000 border">基础篇</span>在那想，这个东西是个什么原理啊？这个东西是这么用的，那个东西该怎么用啊？因为原理性的内容统一放置到了<span class="#990000 border">原理篇</span>讲解了，应用相关的内容统一放到<span class="#cc0000 border">应用篇</span>里面讲解，你在<span class="#ff0000 border">基础篇</span>阶段纠结也没有用，这一部分不讲这些知识，在<span class="#ff0000 border">基础篇</span>先把 SpringBoot 的基础使用掌握完再说后面的知识吧。</p><p>​ 此外还有一点需要说明的是，目前 SpringBoot 技术发展速度很快，更新速度也很快，因此后续还会对本套课程进行持续更新，特此在三个课程单元的基础上追加一个<strong>番外篇</strong>。番外篇的设置为了解决如下问题：</p><ul><li>持续更新 SpringBoot 后续发展出现的新技术</li><li>讲解部分知识点规模较大的支线知识（例如 WebFlux）</li><li>扩展非实用性知识，扩展学习者视野</li></ul><p>​ 每一个课程单元的学习目标如下，请各位查收，在学习的过程中可以阶段性的给自己提个问题，下面列出来的这些学习目标你是否达成了，可以检验你的学习成果。</p><table><thead><tr><th>课程单元</th><th>学习目标</th></tr></thead><tbody><tr><td><span class="#ff0000 border">基础篇</span></td><td>能够创建 SpringBoot 工程 &lt;br/&gt; 基于 SpringBoot 实现 ssm/ssmp 整合</td></tr><tr><td><span class="#cc0000 border">应用篇</span></td><td>能够掌握 SpringBoot 程序多环境开发 &lt;br/&gt; 能够基于 Linux 系统发布 SpringBoot 工程 &lt; br/&gt; 能够解决线上灵活配置 SpringBoot 工程的需求 &lt; br/&gt; 能够基于 SpringBoot 整合任意第三方技术</td></tr><tr><td><span class="#990000 border">原理篇</span></td><td>掌握 SpringBoot 内部工作流程 &lt;br/&gt; 理解 SpringBoot 整合第三方技术的原理 &lt; br/&gt; 实现自定义开发整合第三方技术的组件</td></tr><tr><td><strong>番外篇</strong></td><td>掌握 SpringBoot 整合非常见的第三方技术 &lt;br/&gt; 掌握相同领域的更多的解决方案，并提升同领域方案设计能力</td></tr></tbody></table><p>​ 整体课程包含的内容就是这些啦，要想完成前面这些内容的学习，顺利的达成学习目标，有些东西还是要提前和大家说清楚的。SpringBoot 课程不像是 Java 基础，不管你有没有基础，都可以听一听，这个课程还真不行，需要一定的前置知识。下面给大家列表一些前置知识，如果还有不太会的，需要想办法快速补救一下。</p><h3 id="课程前置知识说明"><a class="anchor" href="#课程前置知识说明">#</a> 课程前置知识说明</h3><table><thead><tr><th>课程单元</th><th>前置知识</th><th>要求</th></tr></thead><tbody><tr><td><span class="#ff0000 border">基础篇</span></td><td>Java 基础语法</td><td>面向对象，封装，继承，多态，类与接口，集合，IO，网络编程等</td></tr><tr><td><span class="#ff0000 border">基础篇</span></td><td>Spring 与 SpringMVC</td><td>知道 Spring 是用来管理 bean，能够基于 Restful 实现页面请求交互功能</td></tr><tr><td><span class="#ff0000 border">基础篇</span></td><td>Mybatis 与 Mybatis-Plus</td><td>基于 Mybatis 和 MybatisPlus 能够开发出包含基础 CRUD 功能的标准 Dao 模块</td></tr><tr><td><span class="#ff0000 border">基础篇</span></td><td>数据库 MySQL</td><td>能够读懂基础 CRUD 功能的 SQL 语句</td></tr><tr><td><span class="#ff0000 border">基础篇</span></td><td>服务器</td><td>知道服务器与 web 工程的关系，熟悉 web 服务器的基础配置</td></tr><tr><td><span class="#ff0000 border">基础篇</span></td><td>maven</td><td>知道 maven 的依赖关系，知道什么是依赖范围，依赖传递，排除依赖，可选依赖，继承</td></tr><tr><td><span class="#ff0000 border">基础篇</span></td><td>web 技术（含 vue，ElementUI)</td><td>知道 vue 如何发送 ajax 请求，如何获取响应数据，如何进行数据模型双向绑定</td></tr><tr><td><span class="#cc0000 border">应用篇</span></td><td>Linux（CenterOS7）</td><td>熟悉常用的 Linux 基础指令，熟悉 Linux 系统目录结构</td></tr><tr><td><span class="#cc0000 border">应用篇</span></td><td>实用开发技术</td><td>缓存：Redis、MongoDB、……&lt;br/&gt; 消息中间件：RocketMq、RabbitMq、……</td></tr><tr><td><span class="#990000 border">原理篇</span></td><td>Spring</td><td>了解 Spring 加载 bean 的各种方式 &lt;br/&gt; 知道 Spring 容器底层工作原理，能够阅读简单的 Spring 底层源码</td></tr></tbody></table><p>​ 看着略微有点多，其实还好吧，如果个别技术真的不会，在学习课程的时候多用心听就好，基础篇是可以跟着学下来了，后面的实用篇和原理篇就比较难了。比如我要在 Linux 系统下操作，命令我就直接使用了，然后你看不懂可能学习起来就比较心累了。</p><p>​ 课程安排就说到这里了，下面进入到 SpringBoot<span class="#ff0000 border"> 基础篇</span>的学习</p><h1 id="springboot基础篇"><a class="anchor" href="#springboot基础篇">#</a> SpringBoot 基础篇</h1><p>​ 在基础篇中，我给学习者的定位是先上手，能够使用 SpringBoot 搭建基于 SpringBoot 的 web 项目开发，所以内容设置较少，主要包含如下内容：</p><ul><li>SpringBoot 快速入门</li><li>SpringBoot 基础配置</li><li>基于 SpringBoot 整合 SSMP</li></ul><h2 id="jc-1快速上手springboot"><a class="anchor" href="#jc-1快速上手springboot">#</a> JC-1. 快速上手 SpringBoot</h2><p>​ 学习任意一项技术，首先要知道这个技术的作用是什么，不然学完以后，你都不知道什么时候使用这个技术，也就是技术对应的应用场景。SpringBoot 技术由 Pivotal 团队研发制作，功能的话简单概括就是加速 Spring 程序的开发，这个加速要从如下两个方面来说</p><ul><li>Spring 程序初始搭建过程</li><li>Spring 程序的开发过程</li></ul><p>​	通过上面两个方面的定位，我们可以产生两个模糊的概念：</p><ol><li>SpringBoot 开发团队认为原始的 Spring 程序初始搭建的时候可能有些繁琐，这个过程是可以简化的，那原始的 Spring 程序初始搭建过程都包含哪些东西了呢？为什么觉得繁琐呢？最基本的 Spring 程序至少有一个配置文件或配置类，用来描述 Spring 的配置信息，莫非这个文件都可以不写？此外现在企业级开发使用 Spring 大部分情况下是做 web 开发，如果做 web 开发的话，还要在加载 web 环境时加载时加载指定的 spring 配置，这都是最基本的需求了，不写的话怎么知道加载哪个配置文件 / 配置类呢？那换了 SpringBoot 技术以后呢，这些还要写吗？谜底稍后揭晓，先卖个关子</li><li>SpringBoot 开发团队认为原始的 Spring 程序开发的过程也有些繁琐，这个过程仍然可以简化。开发过程无外乎使用什么技术，导入对应的 jar 包（或坐标）然后将这个技术的核心对象交给 Spring 容器管理，也就是配置成 Spring 容器管控的 bean 就可以了。这都是基本操作啊，难道这些东西 SpringBoot 也能帮我们简化？</li></ol><p>​	带着上面这些疑问我们就着手第一个 SpringBoot 程序的开发了，看看到底使用 SpringBoot 技术能简化开发到什么程度。</p><p><span class="#f0f border">温馨提示</span></p><p>​ 如果对 Spring 程序的基础开发不太懂的小伙伴，看到这里可以弃坑了，下面的内容学习需要具备 Spring 技术的知识，硬着头皮学不下去的。</p><h3 id="jc-1-1springboot入门程序制作一"><a class="anchor" href="#jc-1-1springboot入门程序制作一">#</a> JC-1-1.SpringBoot 入门程序制作（一）</h3><p>​ 下面让我们开始做第一个 SpringBoot 程序吧，本课程基于 Idea2020.3 版本制作，使用的 Maven 版本为 3.6.1，JDK 版本为 1.8。如果你的环境和上述环境不同，可能在操作界面和操作过程中略有不同，只要软件匹配兼容即可（说到这个 Idea 和 Maven，它们两个还真不是什么版本都能搭到一起的，说多了都是泪啊）。</p><p>​ 下面使用 SpringBoot 技术快速构建一个 SpringMVC 的程序，通过这个过程体会<span class="#ff0000 border">简化</span>二字的含义。</p><p><strong>步骤①</strong>：创建新模块，选择 Spring Initializr，并配置模块相关基础信息</p><p><img data-src="/img/image-20211116125259385.png" alt="image-20211116125259385"></p><p>​ <span class="#ff0000 border">特别关注</span>：第 3 步点击 Next 时，Idea 需要联网状态才可以进入到后面那一页，如果不能正常联网，就无法正确到达右面那个设置页了，会一直<span class="#ff0000 border">联网</span>转转转。</p><p>​ <span class="#ff0000 border">特别关注</span>：第 5 步选择 java 版本和你计算机上安装的 JDK 版本匹配即可，但是最低要求为 JDK8 或以上版本，推荐使用 8 或 11。</p><p><strong>步骤②</strong>：选择当前模块需要使用的技术集</p><p><img data-src="/img/image-20211116125615728.png" alt="image-20211116125615728"></p><p>​ 按照要求，左侧选择 web，然后在中间选择 Spring Web 即可，选完右侧就出现了新的内容项，这就表示勾选成功了。</p><p>​ <span class="#ff0000 border">关注</span>：此处选择的 SpringBoot 的版本使用默认的就可以了，需要说一点，SpringBoot 的版本升级速度很快，可能昨天创建工程的时候默认版本是 2.5.4，今天再创建工程默认版本就变成 2.5.5 了，差别不大，无需过于纠结，并且还可以到配置文件中修改对应的版本。</p><p><strong>步骤③</strong>：开发控制器类</p><pre><code class="language-JAVA">//Rest模式
@RestController
@RequestMapping(&quot;/books&quot;)
public class BookController &#123;
    @GetMapping
    public String getById()&#123;
        System.out.println(&quot;springboot is running...&quot;);
        return &quot;springboot is running...&quot;;
    &#125;
&#125;
</code></pre><p>​ 入门案例制作的 SpringMVC 的控制器基于 Rest 风格开发，当然此处使用原始格式制作 SpringMVC 的程序也是没有问题的，上例中的 @RestController 与 @GetMapping 注解是基于 Restful 开发的典型注解。</p><p>​ <span class="#ff0000 border">关注</span>：做到这里 SpringBoot 程序的最基础的开发已经做完了，现在就可以正常的运行 Spring 程序了。可能有些小伙伴会有疑惑，Tomcat 服务器没有配置，Spring 也没有配置，什么都没有配置这就能用吗？这就是 SpringBoot 技术的强大之处。关于内部工作流程后面再说，先专心学习开发过程。</p><p><strong>步骤④</strong>：运行自动生成的 Application 类</p><p><img data-src="/img/image-20211116130152452.png" alt="image-20211116130152452"></p><p>​ 使用带 main 方法的 java 程序的运行形式来运行程序，运行完毕后，控制台输出上述信息。</p><p>​ 不难看出，运行的信息中包含了 8080 的端口，Tomcat 这种熟悉的字样，难道这里启动了 Tomcat 服务器？是的，这里已经启动了。那服务器没有配置，哪里来的呢？后面再说。现在你就可以通过浏览器访问请求的路径，测试功能是否工作正常了。</p><pre><code class="language-JAVA">访问路径：	http://localhost:8080/books
</code></pre><p>​ 是不是感觉很神奇？当前效果其实依赖的底层逻辑还是很复杂的，但是从开发者角度来看，目前只有两个文件展现到了开发者面前。</p><ul><li><p>pom.xml</p><p>这是 maven 的配置文件，描述了当前工程构建时相应的配置信息。</p><pre><code class="language-XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.5.4&lt;/version&gt;
    &lt;/parent&gt;

    &lt;groupId&gt;com.itheima&lt;/groupId&gt;
    &lt;artifactId&gt;springboot_01_01_quickstart&lt;/artifactId&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre><p>配置中有两个信息需要关注，一个是 parent，也就是当前工程继承了另外一个工程，干什么用的后面再说，还有依赖坐标，干什么用的后面再说。</p></li><li><p>Application 类</p><pre><code class="language-JAVA">@SpringBootApplication
public class Application &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class, args);
    &#125;
&#125;
</code></pre><p>这个类功能很简单，就一句代码，前面运行程序就是运行的这个类。</p></li></ul><p>​ 到这里我们可以大胆推测一下，如果上面这两个文件没有的话，SpringBoot 肯定没法玩，看来核心就是这两个文件了。由于是制作第一个 SpringBoot 程序，先不要关注这两个文件的功能，后面详细讲解内部工作流程。</p><p>​ 通过上面的制作，我们不难发现，SpringBoot 程序简直太好写了，几乎什么都没写，功能就有了，这也是 SpringBoot 技术为什么现在这么火的原因，和 Spring 程序相比，SpringBoot 程序在开发的过程中各个层面均具有优势。</p><table><thead><tr><th><strong>类配置文件</strong></th><th><strong>Spring</strong></th><th><strong>SpringBoot</strong></th></tr></thead><tbody><tr><td>pom 文件中的坐标</td><td><strong>手工添加</strong></td><td><strong>勾选添加</strong></td></tr><tr><td>web3.0 配置类</td><td><strong>手工制作</strong></td><td><strong>无</strong></td></tr><tr><td>Spring/SpringMVC 配置类</td><td><strong>手工制作</strong></td><td><strong>无</strong></td></tr><tr><td>控制器</td><td><strong>手工制作</strong></td><td><strong>手工制作</strong></td></tr></tbody></table><p>​ 一句话总结一下就是<span class="#ff0000 border">能少写就少写</span>，<span class="#ff0000 border">能不写就不写</span>，这就是 SpringBoot 技术给我们带来的好处，行了，现在你就可以动手做一做 SpringBoot 程序了，看看效果如何，是否真的帮助你简化开发了。</p><p><strong>总结</strong></p><ol><li>开发 SpringBoot 程序在 Idea 工具中基于联网的前提下可以根据向导快速制作</li><li>SpringBoot 程序需要依赖 JDK，版本要求最低为 JDK8</li><li>SpringBoot 程序中需要使用某种功能时可以通过勾选的形式选择技术，也可以手工添加对应的要使用的技术（后期讲解）</li><li>运行 SpringBoot 程序通过运行 Application 程序进行</li></ol><p><strong>思考</strong></p><p>​ 前面制作的时候说过，这个过程必须联网才可以进行，但是有些时候你会遇到一些莫名其妙的问题，比如基于 Idea 开发时，你会发现你配置了一些坐标，然后 Maven 下载对应东西的时候死慢死慢的，甚至还会失败。其实这种现象和 Idea 这款 IDE 工具有关，万一 Idea 不能正常访问网络的话，我们是不是就无法制作 SpringBoot 程序了呢？咱们下一节再说。</p><h3 id="jc-1-2springboot入门程序制作二"><a class="anchor" href="#jc-1-2springboot入门程序制作二">#</a> JC-1-2.SpringBoot 入门程序制作（二）</h3><p>​ 如果 Idea 不能正常联网，这个 SpringBoot 程序就无法制作了吗？开什么玩笑，世上 IDE 工具千千万，难道 SpringBoot 技术还必须基于 Idea 来做了？这是不可能的。开发 SpringBoot 程序可以不基于 IDE 工具进行，在 SpringBoot 官网中可以直接创建 SpringBoot 程序。</p><p>​ SpringBoot 官网和 Spring 的官网是在一起的，都是 <span class="exturl" data-url="aHR0cDovL3NwcmluZy5pbw==">spring.io</span> 。你可以通过项目一级一级的找到 SpringBoot 技术的介绍页，然后在页面中间部位找到如下内容</p><p><img data-src="/img/image-20211122150444816.png" alt=""></p><p><strong>步骤①</strong>：点击<strong> Spring Initializr</strong> 后进入到创建 SpringBoot 程序界面，接下来就是输入信息的过程，和在 Idea 中制作是一样的，只是界面发生了变化，根据自己的要求，在左侧选择对应信息和输入对应的信息。</p><p><img data-src="/img/image-20211122150608039.png" alt=""></p><p><strong>步骤②</strong>：右侧的<strong> ADD DEPENDENCIES</strong> 用于选择使用何种技术，和之前勾选的 Spring WEB 是在做同一件事，仅仅是界面不同而已，点击后打开网页版的技术选择界面。</p><p><img data-src="/img/image-20211122161257361.png" alt=""></p><p><strong>步骤③</strong>：所有信息设置完毕后，点击下面左侧<strong> GENERATE</strong> 按钮，生成一个文件包。</p><p><img data-src="/img/image-202111221615480212.png" alt="image-20211122161548022"></p><p><strong>步骤④</strong>：保存后得到一个压缩文件，这个文件就是创建的 SpringBoot 工程</p><p><img data-src="/img/image-20211122161709478.png" alt="image-20211122161709478"></p><p><strong>步骤⑤</strong>：解压缩此文件得到工程目录，在 Idea 中导入即可直接使用，和之前在 Idea 环境下根据向导创建的工程完全一样，你可以创建一个 Controller 测试一下当前工程是否可用。</p><p><span class="#f0f border">温馨提示</span></p><p>​ 做到这里其实可以透漏一个小秘密，Idea 工具中创建 SpringBoot 工程其实连接的就是 SpringBoot 的官网，还句话说这种方式和第一种方式是一模一样的，只不过 Idea 把界面给整合了一下，读取 Spring 官网信息，然后展示到 Idea 界面中而已，可以通过如下信息比对一下</p><p><strong>Idea 中创建工程时默认选项</strong></p><p><img data-src="/img/image-20211122162443035.png" alt=""></p><p><strong>SpringBoot 官网创建工程时对应的地址</strong></p><p>​ 看看 SpringBoot 官网创建工程的 URL 地址，是不是和 Idea 中使用的 URL 地址是一样的？</p><p><img data-src="/img/image-20211122162820719.png" alt=""></p><p><strong>总结</strong></p><ol><li><p>打开 SpringBoot 官网，选择<strong> Quickstart Your Project</strong> 中的 Spring Initializr。</p><p><img data-src="/img/image-20211122150444816.png" alt=""></p></li><li><p>创建工程。</p><p><img data-src="/img/image-20211122150608039.png" alt=""></p></li><li><p>保存项目文件。</p><p><img data-src="/img/image-20211122161548022.png" alt="image-20211122161548022"></p></li><li><p>解压项目，通过 IDE 导入项目后进行编辑使用。</p></li></ol><p><strong>思考</strong></p><p>​ 现在创建工程靠的是访问国外的 Spring 主站，但是互联网信息的访问是可以被约束的，如果一天这个网站你在国内无法访问了，那前面这两种方式就无法创建 SpringBoot 工程了，这时候又该怎么解决这个问题呢？咱们下一节再说。</p><h3 id="jc-1-3springboot入门程序制作三"><a class="anchor" href="#jc-1-3springboot入门程序制作三">#</a> JC-1-3.SpringBoot 入门程序制作（三）</h3><p>​ 前面提到网站如果被限制访问了，该怎么办？开动脑筋想一想，不管是方式一还是方式二其实走的都是同一个路线，就是通过 SpringBoot 官网创建 SpringBoot 工程，假如国内有这么一个网站也能提供这样的功能，是不是就解决了呢？必然的嘛，新的问题又来了，国内有提供这样功能的网站吗？还真有，阿里提供了一个，下面问题就简单了，网址告诉我们就 OK 了，没错，就是这样。</p><p>​ 创建工程时，切换选择 starter 服务路径，然后手工输入阿里云地址即可，地址：<span class="exturl" data-url="aHR0cDovL3N0YXJ0LmFsaXl1bi54bi0tY29taHR0cHMtYnQ3cA==">http://start.aliyun.com 或 https</span>😕/start.aliyun.com</p><p><img data-src="/img/image-20211122163605950.png" alt="image-20211122163605950"></p><p>​ 阿里为了便于自己公司开发使用，特此在依赖坐标中添加了一些阿里自主的技术，也是为了推广自己的技术吧，所以在依赖选择列表中，你有了更多的选择。此外，阿里提供的地址更符合国内开发者的使用习惯，里面有一些 SpringBoot 官网上没有给出的坐标，大家可以好好看一看。</p><p><img data-src="/img/image-20211122163937408.png" alt="image-20211122163937408"></p><p>​ 不过有一点需要说清楚，阿里云地址默认创建的 SpringBoot 工程版本是<span class="#ff0000 border"> 2.4.1</span>，所以如果你想更换其他的版本，创建项目后在 pom 文件中手工修改即可，别忘了刷新一下，加载新版本信息。</p><p>​ <span class="#ff0000 border">注意</span>：阿里云提供的工程创建地址初始化完毕后和使用 SpringBoot 官网创建出来的工程略有区别，主要是在配置文件的形式上有区别，这个信息在后面讲解 SpringBoot 程序的执行流程时给大家揭晓。</p><p><strong>总结</strong></p><ol><li>选择 start 来源为自定义 URL</li><li>输入阿里云 starter 地址</li><li>创建项目</li></ol><p><strong>思考</strong></p><p>​ 做到这里我们已经有了三种方式创建 SpringBoot 工程，但是每种方式都要求你必须能上网才能创建工程。假如有一天，你加入了一个保密级别比较高的项目组，整个项目组没有外网，这个事情是不是就不能做了呢？咱们下一节再说。</p><h3 id="jc-1-4springboot入门程序制作四"><a class="anchor" href="#jc-1-4springboot入门程序制作四">#</a> JC-1-4.SpringBoot 入门程序制作（四）</h3><p>​ 不能上网，还想创建 SpringBoot 工程，能不能做呢？能做，但是你要先问问自己联网和不联网到底差别是什么？这个差别找到以后，你就发现，你把联网要干的事情都提前准备好，就无需联网了。</p><p>​ 联网做什么呢？首先 SpringBoot 工程也是基于 Maven 构建的，而 Maven 工程中如果加载一些工程需要使用又不存在的东西时，就要联网去下载。其实 SpringBoot 工程创建的时候就是要去下载一些必要的组件。如果把这些东西提前准备好呢？是的，就是这样。</p><p>​ 下面就手工创建一个 SpringBoot 工程，如果需要使用的东西提前保障在 maven 仓库中存在，整个过程就可以不依赖联网环境了。不过咱们已经用 3 种方式创建了 SprongBoot 工程了，所以下面也没什么东西需要下载了。</p><p><strong>步骤①</strong>：创建工程时，选择创建普通 Maven 工程。</p><p><img data-src="/img/image-20211122165341684.png" alt=""></p><p><strong>步骤②</strong>：参照标准 SpringBoot 工程的 pom 文件，书写自己的 pom 文件即可。</p><pre><code class="language-XML">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.5.4&lt;/version&gt;
    &lt;/parent&gt;

    &lt;groupId&gt;com.itheima&lt;/groupId&gt;
    &lt;artifactId&gt;springboot_01_04_quickstart&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

&lt;/project&gt;
</code></pre><p>​ 用什么写什么，不用的都可以不写。当然，现在小伙伴们可能还不知道用什么和不用什么，最简单的就是复制粘贴了，随着后面的学习，你就知道哪些可以省略了。此处我删减了一些目前不是必须的东西，一样能用。核心的内容有两条，一个是继承了一个父工程，另外添加了一个依赖。</p><p><strong>步骤③</strong>：之前运行 SpringBoot 工程需要一个类，这个缺不了，自己手写一个就行了，建议按照之前的目录结构来创建，先别玩花样，先学走后学跑。类名可以自定义，关联的名称同步修改即可。</p><pre><code class="language-JAVA">@SpringBootApplication
public class Application &#123;
    public static void main(String[] args) &#123;
        SpringApplication.run(Application.class);
    &#125;
&#125;
</code></pre><p>​ <span class="#ff0000 border">关注</span>：类上面的注解 @SpringBootApplication 千万别丢了，这个是核心，后面再介绍。</p><p>​ <span class="#ff0000 border">关注</span>：类名可以自定义，只要保障下面代码中使用的类名和你自己定义的名称一样即可，也就是 run 方法中的那个 class 对应的名称。</p><p><strong>步骤④</strong>：下面就可以自己创建一个 Controller 测试一下是否能用了，和之前没有差别的。</p><p>​ 看到这里其实应该能够想明白了，通过向导或者网站创建的 SpringBoot 工程其实就是帮你写了一些代码，而现在是自己手写，写的内容都一样，仅此而已。</p><p><span class="#f0f border">温馨提示</span></p><p>​ 如果你的计算机上从来没有创建成功过 SpringBoot 工程，自然也就没有下载过 SpringBoot 对应的坐标相关的资源，那用手写创建的方式在不联网的情况下肯定该是不能用的。所谓手写，其实就是自己写别人帮你生成的东西，但是引用的坐标对应的资源必须保障 maven 仓库里面有才行，如果没有，还是要去下载的。</p><p><strong>总结</strong></p><ol><li>创建普通 Maven 工程</li><li>继承 spring-boot-starter-parent</li><li>添加依赖 spring-boot-starter-web</li><li>制作引导类 Application</li></ol><p>​ 到这里已经学习了 4 种创建 SpringBoot 工程的方式，其实本质是一样的，都是根据 SpringBoot 工程的文件格式要求，通过不同时方式生成或者手写得到对应的文件，效果完全一样。</p><h4 id="教你一招在idea中隐藏指定文件文件夹"><a class="anchor" href="#教你一招在idea中隐藏指定文件文件夹">#</a> 教你一招：在 Idea 中隐藏指定文件 / 文件夹</h4><p>​ 创建 SpringBoot 工程时，使用 SpringBoot 向导也好，阿里云也罢，其实都是为了一个目的，得到一个标准的 SpringBoot 工程文件结构。这个时候就有新的问题出现了，标准的工程结构中包含了一些未知的文件夹，在开发的时候看起来特别别扭，这一节就来说说这些文件怎么处理。</p><p>​ 处理方案无外乎两种，如果你对每一个文件 / 目录足够了解，有用的留着，没有用的完全可以删除掉。或者不删除，但是看着别扭，就设置文件为看不到就行了。删除不说了，选中后直接 Delete 掉就好了，这一节说说如何隐藏指定的文件或文件夹信息。</p><p>​ 既然是在 Idea 下做隐藏功能，肯定隶属于 Idea 的设置，设置方式如下。</p><p><strong>步骤①</strong>：打开设置，【Files】→【Settings】。</p><p><img data-src="/img/image-20211122173835517.png" alt=""></p><p><strong>步骤②</strong>：打开文件类型设置界面后，【Editor】→【File Types】→【Ignored Files and Folders】，忽略文件或文件夹显示。</p><p><img data-src="/img/image-20211122174020028.png" alt=""></p><p><strong>步骤③</strong>：添加你要隐藏的文件名称或文件夹名称，可以使用 * 号通配符，表示任意，设置完毕即可。</p><p>​	到这里就做完了，其实就是 Idea 的一个小功能</p><p><strong>总结</strong></p><ol><li>Idea 中隐藏指定文件或指定类型文件<ol><li>【Files】→【Settings】</li><li>【Editor】→【File Types】→【Ignored Files and Folders】</li><li>输入要隐藏的名称，支持 * 号通配符</li><li>回车确认添加</li></ol></li></ol><h3 id="jc-1-5springboot简介"><a class="anchor" href="#jc-1-5springboot简介">#</a> JC-1-5.SpringBoot 简介</h3><p>​ 入门案例做完了，这个时候回忆一下咱们之前说的 SpringBoot 的功能是什么还记得吗？加速 Spring 程序的开发，现在是否深有体会？再来看 SpringBoot 技术的设计初衷就很容易理解了。</p><p>​ SpringBoot 是由 Pivotal 团队提供的全新框架，其设计目的是用来<span class="#ff0000 border">简化 Spring 应用的初始搭建以及开发过程</span>。</p><p>​ 都简化了了哪些东西呢？其实就是针对原始的 Spring 程序制作的两个方面进行了简化：</p><ul><li>Spring 程序缺点<ul><li>依赖设置繁琐<ul><li>以前写 Spring 程序，使用的技术都要自己一个一个的写，现在不需要了，如果做过原始 SpringMVC 程序的小伙伴应该知道，写 SpringMVC 程序，最基础的 spring-web 和 spring-webmvc 这两个坐标是必须的，就这还不包含你用 json 啊等等这些坐标，现在呢？一个坐标搞定了。</li></ul></li><li>配置繁琐<ul><li>以前写配置类或者配置文件，然后用什么东西就要自己写加载 bean 这些东西，现在呢？什么都没写，照样能用。</li></ul></li></ul></li></ul><blockquote><p>回顾</p><p>​	通过上面两个方面的定位，我们可以产生两个模糊的概念：</p><ol><li>SpringBoot 开发团队认为原始的 Spring 程序初始搭建的时候可能有些繁琐，这个过程是可以简化的，那原始的 Spring 程序初始搭建过程都包含哪些东西了呢？为什么觉得繁琐呢？最基本的 Spring 程序至少有一个配置文件或配置类，用来描述 Spring 的配置信息，莫非这个文件都可以不写？此外现在企业级开发使用 Spring 大部分情况下是做 web 开发，如果做 web 开发的话，还要在加载 web 环境时加载时加载指定的 spring 配置，这都是最基本的需求了，不写的话怎么知道加载哪个配置文件 / 配置类呢？那换了 SpringBoot 技术以后呢，这些还要写吗？谜底稍后揭晓，先卖个关子</li><li>SpringBoot 开发团队认为原始的 Spring 程序开发的过程也有些繁琐，这个过程仍然可以简化。开发过程无外乎使用什么技术，导入对应的 jar 包（或坐标）然后将这个技术的核心对象交给 Spring 容器管理，也就是配置成 Spring 容器管控的 bean 就可以了。这都是基本操作啊，难道这些东西 SpringBoot 也能帮我们简化？</li></ol></blockquote><p>​ 再来看看前面提出的两个问题，已经有答案了，都简化了，都不用写了，这就是 SpringBoot 给我们带来的好处。这些简化操作在 SpringBoot 中有专业的用语，也是 SpringBoot 程序的核心功能及优点：</p><ul><li>起步依赖（简化依赖配置）<ul><li>依赖配置的书写简化就是靠这个起步依赖达成的。</li></ul></li><li>自动配置（简化常用工程相关配置）<ul><li>配置过于繁琐，使用自动配置就可以做相应的简化，但是内部还是很复杂的，后面具体展开说。</li></ul></li><li>辅助功能（内置服务器，……）<ul><li>除了上面的功能，其实 SpringBoot 程序还有其他的一些优势，比如我们没有配置 Tomcat 服务器，但是能正常运行，这是 SpringBoot 入门程序中一个可以感知到的功能，也是 SpringBoot 的辅助功能之一。一个辅助功能都能做的这么 6，太牛了。</li></ul></li></ul><p>​ 下面结合入门程序来说说这些简化操作都在哪些方面进行体现的，一共分为 4 个方面</p><ul><li>parent</li><li>starter</li><li>引导类</li><li>内嵌 tomcat</li></ul><h4 id="parent"><a class="anchor" href="#parent">#</a> parent</h4><p>​ SpringBoot 关注到开发者在进行开发时，往往对依赖版本的选择具有固定的搭配格式，并且这些依赖版本的选择还不能乱搭配。比如 A 技术的 2.0 版，在与 B 技术进行配合使用时，与 B 技术的 3.5 版可以合作在一起工作，但是和 B 技术的 3.7 版合作开发使用时就有冲突。其实很多开发者都一直想做一件事情，就是将各种各样的技术配合使用的常见依赖版本进行收集整理，制作出了最合理的依赖版本配置方案，这样使用起来就方便多了。</p><p>​ SpringBoot 一看这种情况 so easy 啊，于是将所有的技术版本的常见使用方案都给开发者整理了出来，以后开发者使用时直接用它提供的版本方案，就不用担心冲突问题了，相当于 SpringBoot 做了无数个技术版本搭配的列表，这个技术搭配列表的名字叫做<span class="#ff0000 border"> parent</span>。</p><p>​ <span class="#ff0000 border">parent</span> 自身具有很多个版本，每个<span class="#ff0000 border"> parent</span> 版本中包含有几百个其他技术的版本号，不同的 parent 间使用的各种技术的版本号有可能会发生变化。当开发者使用某些技术时，直接使用 SpringBoot 提供的<span class="#ff0000 border"> parent</span> 就行了，由<span class="#ff0000 border"> parent</span> 帮助开发者统一的进行各种技术的版本管理。</p><p>​ 比如你现在要使用 Spring 配合 MyBatis 开发，没有 parent 之前怎么做呢？选个 Spring 的版本，再选个 MyBatis 的版本，再把这些技术使用时关联的其他技术的版本逐一确定下来。当你 Spring 的版本发生变化需要切换时，你的 MyBatis 版本有可能也要跟着切换，关联技术呢？可能都要切换，而且切换后还可能出现其他问题。现在这一切工作都可以交给 parent 来做了。你无需关注这些技术间的版本冲突问题，你只需要关注你用什么技术就行了，冲突问题由<span class="#ff0000 border"> parent</span> 负责处理。</p><p>​ 有人可能会提出来，万一<span class="#ff0000 border"> parent</span> 给我导入了一些我不想使用的依赖怎么办？记清楚，这一点很关键，<span class="#ff0000 border">parent</span> 仅仅帮我们进行版本管理，它不负责帮你导入坐标，说白了用什么还是你自己定，只不过版本不需要你管理了。整体上来说，<span class="#ff0000 border">使用 parent 可以帮助开发者进行版本的统一管理。</span></p><p>​ <span class="#ff0000 border">关注</span>：parent 定义出来以后，并不是直接使用的，仅仅给了开发者一个说明书，但是并没有实际使用，这个一定要确认清楚。</p><p>​ 那 SpringBoot 又是如何做到这一点的呢？可以查阅 SpringBoot 的配置源码，看到这些定义。</p><ul><li>项目中的 pom.xml 中继承了一个坐标</li></ul><pre><code class="language-XML">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.5.4&lt;/version&gt;
&lt;/parent&gt;
</code></pre><ul><li>打开后可以查阅到其中又继承了一个坐标</li></ul><pre><code class="language-XML">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
    &lt;version&gt;2.5.4&lt;/version&gt;
&lt;/parent&gt;
</code></pre><ul><li>这个坐标中定义了两组信息</li></ul><p>第一组是各式各样的依赖版本号属性，下面列出依赖版本属性的局部，可以看的出来，定义了若干个技术的依赖版本号。</p><pre><code class="language-XML">&lt;properties&gt;
    &lt;activemq.version&gt;5.16.3&lt;/activemq.version&gt;
    &lt;aspectj.version&gt;1.9.7&lt;/aspectj.version&gt;
    &lt;assertj.version&gt;3.19.0&lt;/assertj.version&gt;
    &lt;commons-codec.version&gt;1.15&lt;/commons-codec.version&gt;
    &lt;commons-dbcp2.version&gt;2.8.0&lt;/commons-dbcp2.version&gt;
    &lt;commons-lang3.version&gt;3.12.0&lt;/commons-lang3.version&gt;
    &lt;commons-pool.version&gt;1.6&lt;/commons-pool.version&gt;
    &lt;commons-pool2.version&gt;2.9.0&lt;/commons-pool2.version&gt;
    &lt;h2.version&gt;1.4.200&lt;/h2.version&gt;
    &lt;hibernate.version&gt;5.4.32.Final&lt;/hibernate.version&gt;
    &lt;hibernate-validator.version&gt;6.2.0.Final&lt;/hibernate-validator.version&gt;
    &lt;httpclient.version&gt;4.5.13&lt;/httpclient.version&gt;
    &lt;jackson-bom.version&gt;2.12.4&lt;/jackson-bom.version&gt;
    &lt;javax-jms.version&gt;2.0.1&lt;/javax-jms.version&gt;
    &lt;javax-json.version&gt;1.1.4&lt;/javax-json.version&gt;
    &lt;javax-websocket.version&gt;1.1&lt;/javax-websocket.version&gt;
    &lt;jetty-el.version&gt;9.0.48&lt;/jetty-el.version&gt;
    &lt;junit.version&gt;4.13.2&lt;/junit.version&gt;
&lt;/properties&gt;
</code></pre><p>第二组是各式各样的依赖坐标信息，可以看出依赖坐标定义中没有具体的依赖版本号，而是引用了第一组信息中定义的依赖版本属性值.</p><pre><code class="language-XML">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;
            &lt;version&gt;$&#123;hibernate.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre><p>​ <span class="#ff0000 border">关注</span>：上面的依赖坐标定义是出现在 <code>&lt;dependencyManagement&gt;</code> 标签中的，是对引用坐标的依赖管理，并不是实际使用的坐标。因此当你的项目中继承了这组 parent 信息后，在不使用对应坐标的情况下，前面的这组定义是不会具体导入某个依赖的。</p><p>​ <span class="#ff0000 border">关注</span>：因为在 maven 中继承机会只有一次，上述继承的格式还可以切换成导入的形式进行，并且在阿里云的 starter 创建工程时就使用了此种形式。</p><pre><code class="language-XML">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre><p><strong>总结</strong></p><ol><li>开发 SpringBoot 程序要继承 spring-boot-starter-parent</li><li>spring-boot-starter-parent 中定义了若干个依赖管理</li><li>继承 parent 模块可以避免多个依赖使用相同技术时出现依赖版本冲突</li><li>继承 parent 的形式也可以采用引入依赖的形式实现效果</li></ol><p><strong>思考</strong></p><p>​ parent 中定义了若干个依赖版本管理，但是也没有使用，那这个设定也就不生效啊，究竟谁在使用这些定义呢？</p><h4 id="starter"><a class="anchor" href="#starter">#</a> starter</h4><p>​ SpringBoot 关注到实际开发时，开发者对于依赖坐标的使用往往都有一些固定的组合方式，比如使用 spring-webmvc 就一定要使用 spring-web。每次都要固定搭配着写，非常繁琐，而且格式固定，没有任何技术含量。</p><p>​ SpringBoot 一看这种情况，看来需要给开发者带来一些帮助了。安排，把所有的技术使用的固定搭配格式都给开发出来，以后你用某个技术，就不用每次写一堆依赖了，还容易写错，我给你做一个东西，代表一堆东西，开发者使用的时候，直接用我做好的这个东西就好了，对于这样的固定技术搭配，SpringBoot 给它起了个名字叫做<span class="#ff0000 border"> starter</span>。</p><p>​ starter 定义了使用某种技术时对于依赖的固定搭配格式，也是一种最佳解决方案，<span class="#ff0000 border">使用 starter 可以帮助开发者减少依赖配置</span>。</p><p>​ 这个东西其实在入门案例里面已经使用过了，入门案例中的 web 功能就是使用这种方式添加依赖的。可以查阅 SpringBoot 的配置源码，看到这些定义。</p><ul><li>项目中的 pom.xml 定义了使用 SpringMVC 技术，但是并没有写 SpringMVC 的坐标，而是添加了一个名字中包含 starter 的依赖</li></ul><pre><code class="language-XML">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><ul><li>在 spring-boot-starter-web 中又定义了若干个具体依赖的坐标</li></ul><pre><code class="language-XML">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;2.5.4&lt;/version&gt;
        &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt;
        &lt;version&gt;2.5.4&lt;/version&gt;
        &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
        &lt;version&gt;2.5.4&lt;/version&gt;
        &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
        &lt;version&gt;5.3.9&lt;/version&gt;
        &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
        &lt;version&gt;5.3.9&lt;/version&gt;
        &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>​ 之前提到过开发 SpringMVC 程序需要导入 spring-webmvc 的坐标和 spring 整合 web 开发的坐标，就是上面这组坐标中的最后两个了。</p><p>​ 但是我们发现除了这两个坐标，还有其他的坐标。比如第二个，叫做 spring-boot-starter-json。看名称就知道，这个是与 json 有关的坐标了，但是看名字发现和最后两个又不太一样，它的名字中也有 starter，打开看看里面有什么？</p><pre><code class="language-XML">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;2.5.4&lt;/version&gt;
        &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
        &lt;version&gt;5.3.9&lt;/version&gt;
        &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
        &lt;version&gt;2.12.4&lt;/version&gt;
        &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;
        &lt;artifactId&gt;jackson-datatype-jdk8&lt;/artifactId&gt;
        &lt;version&gt;2.12.4&lt;/version&gt;
        &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;
        &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;
        &lt;version&gt;2.12.4&lt;/version&gt;
        &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt;
        &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt;
        &lt;version&gt;2.12.4&lt;/version&gt;
        &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>​ 我们可以发现，这个 starter 中又包含了若干个坐标，其实就是使用 SpringMVC 开发通常都会使用到 Json，使用 json 又离不开这里面定义的这些坐标，看来还真是方便，SpringBoot 把我们开发中使用的东西能用到的都给提前做好了。你仔细看完会发现，里面有一些你没用过的。的确会出现这种过量导入的可能性，没关系，可以通过 maven 中的排除依赖剔除掉一部分。不过你不管它也没事，大不了就是过量导入呗。</p><p>​	到这里基本上得到了一个信息，使用 starter 可以帮开发者快速配置依赖关系。以前写依赖 3 个坐标的，现在写导入一个就搞定了，就是加速依赖配置的。</p><p><strong>starter 与 parent 的区别</strong></p><p>​ 朦朦胧胧中感觉 starter 与 parent 好像都是帮助我们简化配置的，但是功能又不一样，梳理一下。</p><p>​ [starter]</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-09-02 16:35:47" itemprop="dateModified" datetime="2023-09-02T16:35:47+08:00">2023-09-02</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="KangKang 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="KangKang 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>kangkang <i class="ic i-at"><em>@</em></i>KangKang</li><li class="link"><strong>本文链接：</strong> <a href="https://blog.0kangkang0.top/2023/09/02/SpringBoot%E8%AE%B2%E4%B9%89/" title="springboot2">https://blog.0kangkang0.top/2023/09/02/SpringBoot讲义/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/07/23/SSM%E6%A1%86%E6%9E%B6/" itemprop="url" rel="prev" data-background-image="&#x2F;img&#x2F;00032-3635204742.png" title="SSM框架"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>SSM框架</h3></a></div><div class="item right"></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#springboot"><span class="toc-number">1.</span> <span class="toc-text">SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97"><span class="toc-number">1.0.1.</span> <span class="toc-text">文档更新日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.0.2.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E5%86%85%E5%AE%B9%E8%AF%B4%E6%98%8E"><span class="toc-number">1.0.3.</span> <span class="toc-text">课程内容说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E8%AF%B4%E6%98%8E"><span class="toc-number">1.0.4.</span> <span class="toc-text">课程前置知识说明</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#springboot%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-number">2.</span> <span class="toc-text">SpringBoot 基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#jc-1%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8Bspringboot"><span class="toc-number">2.1.</span> <span class="toc-text">JC-1. 快速上手 SpringBoot</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jc-1-1springboot%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F%E5%88%B6%E4%BD%9C%E4%B8%80"><span class="toc-number">2.1.1.</span> <span class="toc-text">JC-1-1.SpringBoot 入门程序制作（一）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jc-1-2springboot%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F%E5%88%B6%E4%BD%9C%E4%BA%8C"><span class="toc-number">2.1.2.</span> <span class="toc-text">JC-1-2.SpringBoot 入门程序制作（二）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jc-1-3springboot%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F%E5%88%B6%E4%BD%9C%E4%B8%89"><span class="toc-number">2.1.3.</span> <span class="toc-text">JC-1-3.SpringBoot 入门程序制作（三）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jc-1-4springboot%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F%E5%88%B6%E4%BD%9C%E5%9B%9B"><span class="toc-number">2.1.4.</span> <span class="toc-text">JC-1-4.SpringBoot 入门程序制作（四）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%99%E4%BD%A0%E4%B8%80%E6%8B%9B%E5%9C%A8idea%E4%B8%AD%E9%9A%90%E8%97%8F%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">2.1.4.1.</span> <span class="toc-text">教你一招：在 Idea 中隐藏指定文件 &#x2F; 文件夹</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jc-1-5springboot%E7%AE%80%E4%BB%8B"><span class="toc-number">2.1.5.</span> <span class="toc-text">JC-1-5.SpringBoot 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#parent"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">parent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#starter"><span class="toc-number">2.1.5.2.</span> <span class="toc-text">starter</span></a></li></ol></li></ol></li></ol></li></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="KangKang" data-src="/images/avatar.jpg"><p class="name" itemprop="name">KangKang</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">7</span> <span class="name">文章</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tLzBrYW5na2FuZzA=" title="https:&#x2F;&#x2F;github.com&#x2F;0kangkang0"><i class="ic i-github"></i></span> <span class="exturl item csdn" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MTY2NjU1" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_15166655"><i class="ic i-csdn"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9rYW5na2FuZy02OC0xOC04OQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;kangkang-68-18-89"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTE2MjE4MTczMjA=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;1621817320"><i class="ic i-cloud-music"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/11/spring%E9%AB%98%E7%BA%A7/" title="spring高级">spring高级</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/09/02/SpringBoot%E8%AE%B2%E4%B9%89/" title="springboot2">springboot2</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/11/MybatisPlus/" title="MybatisPlus">MybatisPlus</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/23/JavaWeb/" title="JavaWeb">JavaWeb</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/11/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/23/SSM%E6%A1%86%E6%9E%B6/" title="SSM框架">SSM框架</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/12/Java/" title="Java">Java</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">KangKang @ kangkang</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div><div class="beian"><a href="https://beian.miit.gov.cn/" target="_blank">闽ICP备2023012662号</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/09/02/SpringBoot讲义/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->