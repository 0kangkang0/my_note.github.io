<!-- build time:Mon Jan 01 2024 14:37:46 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="KangKang" href="https://blog.0kangkang0.top/rss.xml"><link rel="alternate" type="application/atom+xml" title="KangKang" href="https://blog.0kangkang0.top/atom.xml"><link rel="alternate" type="application/json" title="KangKang" href="https://blog.0kangkang0.top/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://blog.0kangkang0.top/2023/07/12/Java/"><title>Java | kangkang = KangKang</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">Java</h1><div class="meta"><span class="item" title="创建时间：2023-07-12 17:26:27"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-07-12T17:26:27+08:00">2023-07-12</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>115k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>1:44</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">kangkang</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="/img/00014-1028390108.png"></li><li class="item" data-background-image="/img/00013-1028390107.png"></li><li class="item" data-background-image="/img/00003-2875532178.png"></li><li class="item" data-background-image="/img/00044-4079796900.png"></li><li class="item" data-background-image="/img/00041-166261796.png"></li><li class="item" data-background-image="/img/00018-1130862969.png"></li></ul></div><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div></header><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.0kangkang0.top/2023/07/12/Java/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="KangKang"><meta itemprop="description" content=", "></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="KangKang"></span><div class="body md" itemprop="articleBody"><h1 id="类和对象"><a class="anchor" href="#类和对象">#</a> 类和对象</h1><pre><code class="language-java">package text;

public class Student &#123;//此处的Student为类名
    private String name;//name和age为成员变量，加了private后，age和name不能直接通过.name和.age来获取
    private int age;    //通过private可以避免输入非法数据；

    public Student() &#123;//这个是构造方法，如果没写，系统会默认为空，但是建议自己写一个空的构造方法，构造方法可以
    &#125;                 //有多种，类似于方法的重构；

    public Student(String name, int age) &#123;
        this.name = name;//通过this可以访问该类的成员变量；
        this.age = age;
    &#125;

    public void setAge(int age) &#123;//有private修饰的成员变量不能直接通过.操作符来访问，但是Java给出了get和
        this.age = age;          //set方法来给成员变量赋值和获取成员变量；
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void show() &#123;//这个是成员方法，成员方法不用static；
        System.out.println(name + &quot;,&quot; + age);
    &#125;
&#125;

</code></pre><p>下面的代码是上面类的调用代码；</p><pre><code class="language-java">package text;

public class StudentDemo &#123;
    public static void main(String[] args) &#123;8
        Student s1 = new Student();//通过空变量创建方法
        s1.setAge(19);//通过set来进行赋值
        s1.setName(&quot;林宏伟sb&quot;);
        s1.show();//调用类的成员方法；
        Student s2 = new Student(&quot;林宏伟sb&quot;, 19);//通过String和age来创建方法；
        s2.show();
        System.out.println(s2.getName() + &quot;,&quot; + s2.getAge());//通过get来获得类的成员变量；
    &#125;
&#125;

</code></pre><h1 id="集合arraylist"><a class="anchor" href="#集合arraylist">#</a> 集合 ArrayList</h1><h2 id="一-构造和添加"><a class="anchor" href="#一-构造和添加">#</a> 一、构造和添加</h2><pre><code class="language-java">import java.util.ArrayList;

public class Main &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; student = new ArrayList&lt;&gt;();
//        jdk7以后可以这样创建一个新的空集合
//        在之前要在后面的&lt;&gt;中填写数据类型,例如：
//        ArrayList&lt;String&gt; student = new ArrayList&lt;String&gt;();
        System.out.println(student);
        student.add(&quot;大傻逼&quot;);
        System.out.println(student.add(&quot;大傻逼&quot;));
        System.out.println(student);
//        通过ArrayList.add在集合的末尾添加一个数据
//        该方法的返回值为布尔类型
        student.add(&quot;二傻逼&quot;);
        student.add(&quot;三傻逼&quot;);
        System.out.println(student);
        student.add(1,&quot;一傻逼&quot;);
//        通过索引来在集合的指定位置添加元素，切记索引不要越界
        System.out.println(student);
    &#125;
&#125;
</code></pre><p>输出：</p><pre><code>[]
true
[大傻逼]
[大傻逼, 二傻逼, 三傻逼]
[大傻逼, 一傻逼, 二傻逼, 三傻逼]
</code></pre><h2 id="二-常用方法"><a class="anchor" href="#二-常用方法">#</a> 二、常用方法</h2><pre><code class="language-java">import java.util.ArrayList;

public class Main &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; student = new ArrayList&lt;&gt;();
        student.add(&quot;大傻逼&quot;);
        student.add(&quot;二傻逼&quot;);
        student.add(&quot;三傻逼&quot;);
        student.add(1,&quot;一傻逼&quot;);
        System.out.println(student);
        System.out.println(student.remove(&quot;一傻逼&quot;));
        System.out.println(student.remove(&quot;五傻逼&quot;));
        student.remove(&quot;一傻逼&quot;);
//        删除指定的元素并反回布尔值表示是否删除成功；
        System.out.println(student);
        student.add(1,&quot;一傻逼&quot;);
        student.remove(1);
//        通过索引删除指定位置的元素，返回值为布尔类型，切记索引不要越界；
        System.out.println(student);
        student.add(1,&quot;一傻逼&quot;);
        System.out.println(student.set(1,&quot;五傻逼&quot;));
        System.out.println(student);
//        修改索引位置的元素并返回被修改的元素；
        student.set(1,&quot;一傻逼&quot;);
        System.out.println(student.get(1));
//        获取索引位置的元素并返回索引处元素的值；
        System.out.println(student.size());
//        ArrayList.size()方法返回ArrayList的长度；
    &#125;
&#125;
</code></pre><p>输出</p><pre><code>[大傻逼, 一傻逼, 二傻逼, 三傻逼]//初始的集合
true//remove的返回值
false
[大傻逼, 二傻逼, 三傻逼]//修改后的集合
[大傻逼, 二傻逼, 三傻逼]//修改后的集合
一傻逼//set的返回值
[大傻逼, 五傻逼, 二傻逼, 三傻逼]//使用set后的方法
一傻逼//get
4//size
</code></pre><h2 id="三-集合的遍历"><a class="anchor" href="#三-集合的遍历">#</a> 三、集合的遍历</h2><pre><code class="language-java">import java.util.ArrayList;

public class Main &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; student = new ArrayList&lt;&gt;();
        student.add(&quot;大傻逼&quot;);
        student.add(&quot;一傻逼&quot;);
        student.add(&quot;二傻逼&quot;);
        student.add(&quot;三傻逼&quot;);
        for (int i=0;i&lt;student.size();i++)&#123;
            System.out.println(student.get(i));
        &#125;//集合的标准遍历
        //以下为加强for
        System.out.println();
        for (String s : student) &#123;
            System.out.println(s);
        &#125;
    &#125;
&#125;
</code></pre><h1 id="继承"><a class="anchor" href="#继承">#</a> 继承</h1><h2 id="一-继承概述"><a class="anchor" href="#一-继承概述">#</a> 一、继承概述</h2><p>1、继承的概念<br>继承是面向对象三大特征之一，可以使得子类具有父类的属性和方法，还可以在子类中重新定义，以及<br>追加属性和方法</p><p>2、继承的格式</p><p>继承通过 extends 实现<br>格式：class 子类 extends 父类</p><p>如 public class Zi extends Fu</p><p>3、继承的好处</p><p>继承可以让类与类之间产生关系，子父类关系，产生子父类后，子类则可以使用父类中非私有的成员。</p><p>父类</p><p><a href="/youdaonote-attachments/WEBRESOURCE0f40a036bbf3b68359ec3dbec1c1dd96Fu.java">Fu.java</a></p><pre><code class="language-java">package inherit;

public class Fu &#123;
    String age,name;
&#125;
</code></pre><p>子类</p><p><a href="/youdaonote-attachments/WEBRESOURCE676720b3748ca40423537c0495b8a585Zi.java">Zi.java</a></p><pre><code class="language-java">package inherit;

public class Zi extends Fu&#123;
    public void pr()&#123;
        System.out.println(name+&quot; &quot;+age);
    &#125;
&#125;
</code></pre><p>测试</p><p><a href="/youdaonote-attachments/WEBRESOURCEc703d68b6d1e7b455546f8ce53dc84a0Demo.java">Demo.java</a></p><pre><code class="language-java">package inherit;

public class Demo &#123;
    public static void main(String[] args) &#123;
        Zi zi=new Zi();
        zi.age=&quot;1&quot;;
        zi.name=&quot;GHUIY&quot;;
        Fu fu = new Fu();
        fu.age=&quot;114514&quot;;
        fu.name=&quot;gauebikgh&quot;;
        System.out.println(&quot;FU:&quot;+fu.age+&quot;\t&quot;+fu.name);
        zi.pr();
    &#125;
&#125;
</code></pre><p><img data-src="/youdaonote-images/WEBRESOURCEd9a580d35dea03c1df5531e52d9a1da1.png" alt=""></p><h2 id="二-继承的好处和弊端"><a class="anchor" href="#二-继承的好处和弊端">#</a> 二、继承的好处和弊端</h2><p>继承好处<br>提高了代码的复用性 (多个类相同的成员可以放到同一个类中)<br>提高了代码的维护性 (如果方法的代码需要修改，修改一处即可)<br>继承弊端</p><p>继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削<br>弱了子类的独立性</p><p>继承的应用场景：<br>使用继承，需要考虑类与类之间是否存在 is..a 的关系，不能盲目使用继承<br>is..a 的关系：谁是谁的一种，例如：老师和学生是人的一种，那人就是父类，学生和老师就是子类</p><h2 id="三-继承中变量的访问特点"><a class="anchor" href="#三-继承中变量的访问特点">#</a> 三、 继承中变量的访问特点</h2><p>在子类方法中访问一个变量，采用的是就近原则。<br>1. 子类局部范围找<br>2. 子类成员范围找<br>3. 父类成员范围找<br>4. 如果都没有就报错 (不考虑父亲的父亲…)</p><p>父类</p><p><a href="/youdaonote-attachments/WEBRESOURCEed3ba727c00bd1dd0527c4022da5d24eFu.java">Fu.java</a></p><pre><code class="language-java">package inherit1;

class Fu &#123;
    int num = 10;
&#125;


</code></pre><p>子类</p><p><a href="/youdaonote-attachments/WEBRESOURCE76ddf5571d3ea3972530dc036634e5b8Zi.java">Zi.java</a></p><pre><code class="language-java">package inherit1;

class Zi &#123;
    int num = 20;
    public void show()&#123;
        int num = 30;
        System.out.println(num);
    &#125;
&#125;

</code></pre><p>测试</p><p><a href="/youdaonote-attachments/WEBRESOURCE6b8a69947ece62bb5a839cc7bf8d2a5aDemo.java">Demo.java</a></p><pre><code class="language-java">package inherit1;

public class Demo &#123;
    public static void main(String[] args) &#123;
        Zi z = new Zi();
        z.show(); // 输出show方法中的局部变量30
    &#125;
&#125;

</code></pre><h2 id="四-super"><a class="anchor" href="#四-super">#</a> 四、super</h2><p>this&amp;super 关键字：<br>this：代表本类对象的引用<br>super：代表父类存储空间的标识 (可以理解为父类对象引用)<br>this 和 super 的使用分别<br>成员变量：<br>this. 成员变量 - 访问本类成员变量<br>super. 成员变量 - 访问父类成员变量<br>成员方法：<br>this. 成员方法 - 访问本类成员方法</p><p>super. 成员方法 - 访问父类成员方法<br>构造方法：<br>this (…) - 访问本类构造方法<br>super (…) - 访问父类构造方法</p><p>父类</p><p><a href="/youdaonote-attachments/WEBRESOURCE3a4b397af0a9ffeb06322ec60bf5894eFu.java">Fu.java</a></p><pre><code class="language-java">package inherit2;

public class Fu &#123;
    int age=40;
&#125;

</code></pre><p>子类</p><p><a href="/youdaonote-attachments/WEBRESOURCE67b056089adec66281b908b91562e0e9Zi.java">Zi.java</a></p><pre><code class="language-java">package inherit2;

public class Zi extends Fu &#123;
    int age=30;
    public void show()&#123;
        int age =20;
        System.out.println(age);
        System.out.println(this.age);
        System.out.println(super.age);
    &#125;
&#125;

</code></pre><p>测试</p><p><a href="/youdaonote-attachments/WEBRESOURCEd77eb06866b8b4b84730610eb1e75d21Demo.java">Demo.java</a></p><pre><code class="language-java">package inherit2;

public class Demo &#123;
    public static void main(String[] args) &#123;
        Zi zi = new Zi();
        zi.show();
    &#125;
&#125;

</code></pre><p><img data-src="/youdaonote-images/WEBRESOURCE7f9b3f3038f7c5244c0122b083027b66.png" alt=""></p><h2 id="五-继承中构造方法的访问特点"><a class="anchor" href="#五-继承中构造方法的访问特点">#</a> 五、 继承中构造方法的访问特点</h2><p>注意：子类中所有的构造方法默认都会访问父类中无参的构造方法<br>子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数</p><pre><code>		据的初始化，原因在于，每一个子类构造方法的第一条语句默认都是：super()
问题：如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢？
</code></pre><ol><li>通过使用 super 关键字去显示的调用父类的带参构造方法<br>2. 在父类中自己提供一个无参构造方法<br>推荐方案：<br>自己给出无参构造方法</li></ol><p>父类</p><p><a href="/youdaonote-attachments/WEBRESOURCE85ce35b466f2adf1dc9a72de02151f8bFu.java">Fu.java</a></p><pre><code class="language-java">package inherit2;

public class Fu &#123;
    public Fu()&#123;
        System.out.println(&quot;fu中无参构造方法被调用&quot;);
    &#125;
    public Fu(int age)&#123;
        System.out.println(&quot;fu中带参构造方法被调用&quot;);
    &#125;
&#125;

</code></pre><p>子类</p><p><a href="/youdaonote-attachments/WEBRESOURCE5ee5fed84423c11a13ed4e88e8c9d190Zi.java">Zi.java</a></p><pre><code class="language-java">package inherit2;

public class Zi extends Fu &#123;
    public Zi()&#123;
        System.out.println(&quot;zi的无参构造方法被调用&quot;);
    &#125;
    public Zi(int age)&#123;
        System.out.println(&quot;zi中的带参构造方法被调用&quot;);
    &#125;
&#125;

</code></pre><p>测试</p><p><a href="/youdaonote-attachments/WEBRESOURCE12c728fd2ecd11545ec4d7e91548f072Demo.java">Demo.java</a></p><pre><code class="language-java">package inherit2;

public class Demo &#123;
    public static void main(String[] args) &#123;
        Zi zi = new Zi();
        Zi zi1 = new Zi(78);
    &#125;
&#125;

</code></pre><p><img data-src="/youdaonote-images/WEBRESOURCE12f9506430f0a6c1855c8aac571ac62f.jpeg" alt=""></p><h2 id="六-继承中成员方法的访问特点"><a class="anchor" href="#六-继承中成员方法的访问特点">#</a> 六、继承中成员方法的访问特点</h2><p>同成员变量的访问方法</p><p>通过子类对象访问一个方法<br>1. 子类成员范围找<br>2. 父类成员范围找<br>3. 如果都没有就报错 (不考虑父亲的父亲…)</p><h2 id="七-super内存图"><a class="anchor" href="#七-super内存图">#</a> 七、super 内存图</h2><p>对象在堆内存中，会单独存在一块 super 区域，用来存放父类的数据</p><p><img data-src="/youdaonote-images/WEBRESOURCE96b3aaecf38c2b7e9eb6d1d5912884e5.jpeg" alt=""></p><h2 id="八-方法重写的注意事项"><a class="anchor" href="#八-方法重写的注意事项">#</a> 八、方法重写的注意事项</h2><p>方法重写的注意事项<br>1. 私有方法不能被重写 (父类私有成员子类是不能继承的)<br>2. 子类方法访问权限不能更低 (public&gt; 默认 &gt; 私有)</p><p>父类</p><p><a href="/youdaonote-attachments/WEBRESOURCE4cd7239c9c8c186af5df2ebc700e76c1Fu.java">Fu.java</a></p><pre><code class="language-java">package inherit2;

public class Fu &#123;
    private void show() &#123;
        System.out.println(&quot;Fu中show()方法被调用&quot;);
    &#125;
    void method() &#123;
        System.out.println(&quot;Fu中method()方法被调用&quot;);
    &#125;
&#125;
</code></pre><p>子类</p><p><a href="/youdaonote-attachments/WEBRESOURCEd305b16ab9bc7eaa2e7b2dd6ab0cde18Zi.java">Zi.java</a></p><pre><code class="language-java">package inherit2;

public class Zi extends Fu &#123;
    /* 编译【出错】，子类不能重写父类私有的方法*/
      @Override
      private void show() &#123;
        System.out.println(&quot;Zi中show()方法被调用&quot;);
    &#125;
    /* 编译【出错】，子类重写父类方法的时候，访问权限需要大于等于父类 */
    @Override
    private void method() &#123;
        System.out.println(&quot;Zi中method()方法被调用&quot;);
    &#125;
    /* 编译【通过】，子类重写父类方法的时候，访问权限需要大于等于父类 */

    @Override
    public void method() &#123;
        System.out.println(&quot;Zi中method()方法被调用&quot;);
    &#125;
&#125;


</code></pre><p>测试</p><p><a href="/youdaonote-attachments/WEBRESOURCE99938695f447885b136cae3a83c09b77Demo.java">Demo.java</a></p><pre><code class="language-java">package inherit2;

public class Demo &#123;
    public static void main(String[] args) &#123;
        Zi zi = new Zi();
        zi.method();
    &#125;
&#125;

</code></pre><h2 id="九-java中继承的注意事项"><a class="anchor" href="#九-java中继承的注意事项">#</a> 九、 Java 中继承的注意事项</h2><p>Java 中继承的注意事项<br>1. Java 中类只支持单继承，不支持多继承<br>错误范例：class A extends B, C</p><p>多层继承示例代码：</p><pre><code class="language-java">public class Granddad &#123;
    public void drink() &#123;
        System.out.println(&quot;爷爷爱喝酒&quot;);
    &#125;
&#125;
public class Father extends Granddad &#123;
    public void smoke() &#123;
        System.out.println(&quot;爸爸爱抽烟&quot;);
    &#125;
&#125;
public class Mother &#123;
    public void dance() &#123;
        System.out.println(&quot;妈妈爱跳舞&quot;);
    &#125;
&#125;
public class Son extends Father &#123;
// 此时，Son类中就同时拥有drink方法以及smoke方法
&#125;
</code></pre><h1 id="修饰符"><a class="anchor" href="#修饰符">#</a> 修饰符</h1><h2 id="一-package"><a class="anchor" href="#一-package">#</a> 一、package</h2><p>1、包的概念<br>包就是文件夹，用来管理类文件的<br>2、包的定义格式<br>package 包名；(多级包用。分开)<br>例如：package com.heima.demo;<br>3、带包编译 &amp; 带包运行<br>带包编译：javac –d . 类名.java<br>例如：javac -d . com.heima.demo.HelloWorld.java（自动生成包）<br>带包运行：java 包名 + 类名<br>例如：java com.heima.demo.HelloWorld</p><h2 id="二-import"><a class="anchor" href="#二-import">#</a> 二、import</h2><p>导包的意义<br>使用不同包下的类时，使用的时候要写类的全路径，写起来太麻烦了<br>为了简化带包的操作，Java 就提供了导包的功能<br>导包的格式<br>格式：import 包名；<br>范例：import java.util.Scanner;<br>示例代码（没有使用导包，创建的 Scanner 对象）</p><pre><code class="language-java">package com.heima;
public class Demo &#123;
public static void main(String[] args) &#123;
// 1. 没有导包，创建Scnaner对象
        java.util.Scanner sc = new java.util.Scanner(System.in);
    &#125;
&#125;
</code></pre><p>示例代码（使用导包后，创建的 Scanner 对象）</p><pre><code class="language-java">package com.heima;
import java.util.Scanner;
public class Demo &#123;
public static void main(String[] args) &#123;
// 1. 没有导包，创建Scnaner对象
        Scanner sc = new Scanner(System.in);
    &#125;
&#125;
</code></pre><h2 id="三-权限修饰符"><a class="anchor" href="#三-权限修饰符">#</a> 三、权限修饰符</h2><p><img data-src="/youdaonote-images/WEBRESOURCE3f66d0a51c9cf379a79f3199e387f1fb.jpeg" alt=""></p><h2 id="四-final"><a class="anchor" href="#四-final">#</a> 四、 final</h2><p>fianl 关键字的作用<br>final 代表最终的意思，可以修饰成员方法，成员变量，类<br>final 修饰类、方法、变量的效果<br>fianl 修饰类：该类不能被继承（不能有子类，但是可以有父类）<br>final 修饰方法：该方法不能被重写<br>final 修饰变量：表明该变量是一个常量，不能再次赋值</p><h2 id="五-final修饰局部变量"><a class="anchor" href="#五-final修饰局部变量">#</a> 五、 final 修饰局部变量</h2><p>fianl 修饰基本数据类型变量<br>final 修饰指的是基本类型的数据值不能发生改变<br>final 修饰引用数据类型变量<br>final 修饰指的是引用类型的地址值不能发生改变，但是地址里面的内容是可以发生改变的<br>举例：</p><pre><code class="language-java">public static void main(String[] args)&#123;
    final Student s = new Student(23);
    s = new Student(24); // 错误
    s.setAge(24); // 正确
&#125;
</code></pre><h2 id="六-static"><a class="anchor" href="#六-static">#</a> 六、 static</h2><p>static 的概念<br>static 关键字是静态的意思，可以修饰【成员方法】，【成员变量】<br>static 修饰的特点<br>1. 被类的所有对象共享，这也是我们判断是否使用静态关键字的条件<br>2. 可以通过类名调用当然，也可以通过对象名调用【推荐使用类名调用】<br>示例代码：</p><pre><code class="language-java">class Student &#123;
        public String name; //姓名
        public int age; //年龄
        public static String university; //学校 共享数据！所以设计为静态！
        public void show() &#123;
        System.out.println(name + &quot;,&quot; + age + &quot;,&quot; + university);
    &#125;
&#125;
public class StaticDemo &#123;
    public static void main(String[] args) &#123;
// 为对象的共享数据赋值
        Student.university = &quot;传智大学&quot;;
        Student s1 = new Student();
        s1.name = &quot;林青霞&quot;;
        s1.age = 30;
        s1.show();
        Student s2 = new Student();
        s2.name = &quot;风清扬&quot;;
        s2.age = 33;
        s2.show();
    &#125;
&#125;
</code></pre><h2 id="七-static访问特点"><a class="anchor" href="#七-static访问特点">#</a> 七、 static 访问特点</h2><p>static 的访问特点<br>非静态的成员方法<br>能访问静态的成员变量<br>能访问非静态的成员变量<br>能访问静态的成员方法<br>能访问非静态的成员方法<br>静态的成员方法<br>能访问静态的成员变量<br>能访问静态的成员方法<br>总结成一句话就是：<br>静态成员方法只能访问静态成员</p><h1 id="多态"><a class="anchor" href="#多态">#</a> 多态</h1><h2 id="一-多态的概述"><a class="anchor" href="#一-多态的概述">#</a> 一、多态的概述</h2><p>什么是多态<br>同一个对象，在不同时刻表现出来的不同形态<br>多态的前提<br>要有继承或实现关系<br>要有方法的重写<br>要有父类引用指向子类对象</p><h2 id="二-多态中的成员访问特点"><a class="anchor" href="#二-多态中的成员访问特点">#</a> 二、多态中的成员访问特点</h2><p>成员访问特点<br>成员变量<br>编译看父类，运行看父类<br>成员方法<br>编译看父类，运行看子类<br>代码演示</p><p>父类</p><p><a href="/youdaonote-attachments/WEBRESOURCE53b79f4506eef9323d43b6ffda99e3d3Fu.java">Fu.java</a></p><pre><code class="language-java">package inherit2;

public class Fu &#123;
    int age=10;
    public void show()&#123;
        System.out.println(&quot;FU&quot;);
    &#125;
&#125;
</code></pre><p>子类</p><p><a href="/youdaonote-attachments/WEBRESOURCE35c2e1fa852fd6a8ba741d1ebe81258eZi.java">Zi.java</a></p><pre><code class="language-java">package inherit2;

public class Zi extends Fu &#123;
    int age=20;
    @Override
    public void show() &#123;
        System.out.println(&quot;ZI&quot;);
    &#125;
&#125;
</code></pre><p>测试</p><p><a href="/youdaonote-attachments/WEBRESOURCE38be94e647f01837e50f89e80a10acc0Demo.java">Demo.java</a></p><pre><code class="language-java">package inherit2;

public class Demo &#123;
    public static void main(String[] args) &#123;
        Fu fu=new Zi();
        System.out.println(fu.age);
        fu.show();
    &#125;
&#125;
</code></pre><p><img data-src="/youdaonote-images/WEBRESOURCE7ad68fe25e58f804e2d072bb5124bbc0.jpeg" alt=""></p><h2 id="三-多态的好处和弊端"><a class="anchor" href="#三-多态的好处和弊端">#</a> 三、多态的好处和弊端</h2><p>好处<br>提高程序的扩展性。定义方法时候，使用父类型作为参数，在使用的时候，使用具体的子类型参与操作<br>弊端<br>不能使用子类的特有成员</p><h2 id="四-多态中的转型"><a class="anchor" href="#四-多态中的转型">#</a> 四、多态中的转型</h2><p>向上转型<br>父类引用指向子类对象就是向上转型<br>向下转型<br>格式：子类型 对象名 = (子类型) 父类引用；</p><p>代码演示</p><p>父类</p><p><a href="/youdaonote-attachments/WEBRESOURCEfbbcb9abc5170fac87ff6377d8dcfd6fFu.java">Fu.java</a></p><pre><code class="language-java">package inherit2;

public class Fu &#123;
    public void show()&#123;
        System.out.println(&quot;FU.SHOW&quot;);
    &#125;
&#125;
</code></pre><p>子类</p><p><a href="/youdaonote-attachments/WEBRESOURCEf7d554847acb2f12f10e83e8750f50b7Zi.java">Zi.java</a></p><pre><code class="language-java">package inherit2;

public class Zi extends Fu &#123;
    @Override
    public void show() &#123;
        System.out.println(&quot;ZI.SHOW&quot;);
    &#125;
    public void play()&#123;
        System.out.println(&quot;ZI.PLAY&quot;);
    &#125;
&#125;
</code></pre><p>测试</p><p><a href="/youdaonote-attachments/WEBRESOURCE375474fc06b0d98757e2739e5a68a15aDemo.java">Demo.java</a></p><pre><code class="language-java">package inherit2;

public class Demo &#123;
    public static void main(String[] args) &#123;
        //向上转型
        Fu fu=new Zi();
        fu.show();

        //向下转型
        Zi zi=(Zi)fu;
        zi.show();
        zi.play();
    &#125;
&#125;

</code></pre><p><img data-src="/youdaonote-images/WEBRESOURCE6d28b72062ae5170dbda6d20c49912c8.jpeg" alt=""></p><h1 id="抽象类"><a class="anchor" href="#抽象类">#</a> 抽象类</h1><h2 id="一-抽象类的概述"><a class="anchor" href="#一-抽象类的概述">#</a> 一、抽象类的概述</h2><p>当我们在做子类共性功能抽取时，有些方法在父类中并没有具体的体现，这个时候就需要抽象类了！<br>在 Java 中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类！</p><h2 id="二-抽象类的特点"><a class="anchor" href="#二-抽象类的特点">#</a> 二、抽象类的特点</h2><p>抽象类和抽象方法必须使用 abstract 关键字修饰</p><pre><code class="language-java">//抽象类的定义
public abstract class 类名 &#123;&#125;
//抽象方法的定义
public abstract void eat();
</code></pre><p>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</p><p>抽象类不能实例化</p><p>（不可以 new 类名 ( )）<br>抽象类如何实例化呢？参照多态的方式，通过子类对象实例化，这叫抽象类多态<br>抽象类的子类<br>要么重写抽象类中的所有抽象方法<br>要么是抽象类</p><h2 id="三-抽象类的成员特点"><a class="anchor" href="#三-抽象类的成员特点">#</a> 三、抽象类的成员特点</h2><p>成员的特点<br>成员变量<br>既可以是变量<br>也可以是常量（用 final 修饰）<br>构造方法<br>空参构造<br>有参构造<br>成员方法<br>抽象方法<br>普通方法</p><p>代码演示</p><p>父类</p><p><a href="/youdaonote-attachments/WEBRESOURCEbae0065855cad136816cd3e752b8ac0fFu.java">Fu.java</a></p><pre><code class="language-java">package inherit2;

public abstract class Fu &#123;
    int age=10;
    final String a=&quot;FU&quot;;

    public Fu() &#123;
    &#125;
    public Fu(int age) &#123;
        this.age = age;
    &#125;
    public void show()&#123;
        System.out.println(age);
        System.out.println(a);
    &#125;
    public abstract void eat();
&#125;
</code></pre><p>子类</p><p><a href="/youdaonote-attachments/WEBRESOURCE6cc31d47f43dd4b2741c40bb72e4c082Zi.java">Zi.java</a></p><pre><code class="language-java">package inherit2;

public class Zi extends Fu &#123;
    @Override
    public void eat() &#123;
        System.out.println(&quot;吃食物&quot;);
    &#125;
&#125;
</code></pre><p>测试类</p><p><a href="/youdaonote-attachments/WEBRESOURCE84e4b5e79212132f584f9cd3fadd1269Demo.java">Demo.java</a></p><pre><code class="language-java">package inherit2;

public class Demo &#123;
    public static void main(String[] args) &#123;
        Fu f=new Zi();
        f.show();
        f.eat();
    &#125;
&#125;

</code></pre><p><img data-src="/youdaonote-images/WEBRESOURCE7c01083576fbc1051efd3555ae4fbdf5.jpeg" alt=""></p><h1 id="接口"><a class="anchor" href="#接口">#</a> 接口</h1><h2 id="一-接口的概述"><a class="anchor" href="#一-接口的概述">#</a> 一、接口的概述</h2><p>接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用。<br>Java 中的接口更多的体现在对行为的抽象！</p><h2 id="二-接口的特点"><a class="anchor" href="#二-接口的特点">#</a> 二、接口的特点</h2><p>接口用关键字 interface 修饰</p><p>public interface 接口名 {}</p><pre><code>  类实现接口用implements表示
</code></pre><p>public class 类名 implements 接口名 {}</p><p>接口不能实例化<br>接口如何实例化呢？参照多态的方式，通过实现类对象实例化，这叫接口多态。<br>多态的形式：具体类多态 (基本不用)，抽象类多态，接口多态。<br>接口的子类<br>要么重写接口中的所有抽象方法<br>要么子类也是抽象类</p><h2 id="三-接口的成员特点"><a class="anchor" href="#三-接口的成员特点">#</a> 三、接口的成员特点</h2><p>成员特点<br>成员变量<br>只能是常量 默认修饰符：public static final<br>构造方法<br>没有，因为接口主要是扩展功能的，而没有具体存在</p><p>一个类如果没有父类，默认继承 Object 类<br>成员方法<br>只能是抽象方法<br>默认修饰符：public abstract<br>关于接口中的方法，JDK8 和 JDK9 中有一些新特性，后面再讲解</p><p>代码演示</p><p>接口</p><p><a href="/youdaonote-attachments/WEBRESOURCE85fba05cf294d23f9cdcf04220242d71inter.java">inter.java</a></p><pre><code class="language-java">package inherit2;

public interface inter &#123;
    public int num = 10;
    public final int num2 = 20;
    // public static final int num3 = 30;== int num3 = 30;
    int num3 = 30;
    // public Inter() &#123;&#125;   不存在
    // public void show() &#123;&#125;   不存在
    public abstract void method();//与下一行作用相同
    void show();
&#125;
</code></pre><pre><code>实现类
</code></pre><p><a href="/youdaonote-attachments/WEBRESOURCEc0f644f6e555d70cfd8951e03beed152InterImpl.java">InterImpl.java</a></p><pre><code class="language-java">package inherit2;

public class InterImpl implements inter&#123;
    public InterImpl() &#123;
        super();//继承Object类
    &#125;

    @Override
    public void show() &#123;
        System.out.println(&quot;show&quot;);
    &#125;

    @Override
    public void method() &#123;
        System.out.println(&quot;method&quot;);
    &#125;
&#125;
</code></pre><pre><code> 测试
</code></pre><p><a href="/youdaonote-attachments/WEBRESOURCE2bbcfccbc11c0e0155176df1d820427fDemo.java">Demo.java</a></p><pre><code class="language-java">package inherit2;

public class Demo &#123;
    public static void main(String[] args) &#123;
        inter i=new InterImpl();
        System.out.println(i.num);
        System.out.println(i.num2);
        i.show();
        i.method();
        System.out.println(inter.num);
    &#125;
&#125;
</code></pre><p><img data-src="/youdaonote-images/WEBRESOURCE1f8f1274cdbd55cbd423b18c3512ff74.jpeg" alt=""></p><h2 id="四-类和接口的关系"><a class="anchor" href="#四-类和接口的关系">#</a> 四、类和接口的关系</h2><p>类与类的关系<br>继承关系，只能单继承，但是可以多层继承<br>类与接口的关系<br>实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口<br>接口与接口的关系<br>继承关系，可以单继承，也可以多继承</p><h2 id="五-抽象类和接口的区别"><a class="anchor" href="#五-抽象类和接口的区别">#</a> 五、抽象类和接口的区别</h2><p>成员区别<br>抽象类：<br>变量，常量；有构造方法；有抽象方法，也有非抽象方法<br>接口：<br>常量；抽象方法<br>关系区别<br>类与类：<br>继承，单继承<br>类与接口：<br>实现，可以单实现，也可以多实现，接口不能继承类<br>接口与接口：<br>继承，单继承，多继承<br>设计理念区别<br>抽象类：<br>对类抽象，包括属性、行为<br>接口：<br>对行为抽象，主要是行为</p><h1 id="参数传递"><a class="anchor" href="#参数传递">#</a> 参数传递</h1><h2 id="一-类名作为形参和返回值"><a class="anchor" href="#一-类名作为形参和返回值">#</a> 一、类名作为形参和返回值</h2><p>类名作为方法的形参<br>方法的形参是类名，其实需要的是该类的对象<br>实际传递的是该对象的【地址值】<br>类名作为方法的返回值<br>方法的返回值是类名，其实返回的是该类的对象<br>实际传递的，也是该对象的【地址值】</p><p>示例代码</p><p><a href="/youdaonote-attachments/WEBRESOURCE5420b471da4834849bc1f71f7f7fb1e7Main.java">Main.java</a></p><pre><code class="language-java">class Cat &#123;
    public void eat() &#123;
        System.out.println(&quot;猫吃鱼&quot;);
    &#125;
&#125;
class CatOperator &#123;
    public void useCat(Cat c) &#123; //Cat c = new Cat();//作为方法的形参
        c.eat();
    &#125;
    public Cat getCat() &#123;
        Cat c = new Cat();
        return c;//作为方法的返回值
    &#125;
&#125;
public class Main &#123;
    public static void main(String[] args) &#123;
//创建操作类对象，并调用方法
        CatOperator co = new CatOperator();
        Cat c = new Cat();
        co.useCat(c);
        Cat c2 = co.getCat(); //new Cat()
        c2.eat();
    &#125;
&#125;
</code></pre><h2 id="二-抽象类作为形参和返回值"><a class="anchor" href="#二-抽象类作为形参和返回值">#</a> 二、抽象类作为形参和返回值</h2><p>抽象类作为形参和返回值<br>方法的形参是抽象类名，其实需要的是该抽象类的子类对象（抽象类不能直接实例化）<br>方法的返回值是抽象类名，其实返回的是该抽象类的子类对象</p><p>示例代码：</p><p><a href="/youdaonote-attachments/WEBRESOURCE48938b83aca9bca980646583c58850baMain.java">Main.java</a></p><pre><code class="language-java">abstract class Animal &#123;
    public abstract void eat();
&#125;
class Cat extends Animal &#123;
    @Override
    public void eat() &#123;
        System.out.println(&quot;猫吃鱼&quot;);
    &#125;
&#125;
class AnimalOperator &#123;
    public void useAnimal(Animal a) &#123; //Animal a = new Cat();
        a.eat();
    &#125;
    public Animal getAnimal() &#123;
        Animal a = new Cat();
        return a;
    &#125;
&#125;
public class Main &#123;
    public static void main(String[] args) &#123;
//创建操作类对象，并调用方法
        AnimalOperator ao = new AnimalOperator();
        Animal a = new Cat();
        ao.useAnimal(a);
        Animal a2 = ao.getAnimal(); //new Cat()
        a2.eat();
    &#125;
&#125;
</code></pre><h2 id="三-接口名作为形参和返回值"><a class="anchor" href="#三-接口名作为形参和返回值">#</a> 三、接口名作为形参和返回值</h2><p>接口作为形参和返回值<br>方法的形参是接口名，其实需要的是该接口的实现类对象（与抽象类一样，接口不能实例化）<br>方法的返回值是接口名，其实返回的是该接口的实现类对象</p><p>・示例代码：</p><p><a href="/youdaonote-attachments/WEBRESOURCE548a61c937029aa5c898b99ebcfd79edMain.java">Main.java</a></p><pre><code class="language-java">interface Jumping &#123;
    void jump();
&#125;
class JumpingOperator &#123;
    public void useJumpping(Jumping j) &#123; //Jumpping j = new Cat();
        j.jump();
    &#125;
    public Jumping getJumpping() &#123;
        Jumping j = new Cat();
        return j;
    &#125;
&#125;
class Cat implements Jumping &#123;
    @Override
    public void jump() &#123;
        System.out.println(&quot;猫可以跳高了&quot;);
    &#125;
&#125;
public class Main &#123;
    public static void main(String[] args) &#123;
//创建操作类对象，并调用方法
        JumpingOperator jo = new JumpingOperator();
        Jumping j = new Cat();
        jo.useJumpping(j);
        Jumping j2 = jo.getJumpping(); //new Cat()
        j2.jump();
    &#125;
&#125;
</code></pre><h1 id="内部类"><a class="anchor" href="#内部类">#</a> 内部类</h1><h2 id="一-内部类的基本使用"><a class="anchor" href="#一-内部类的基本使用">#</a> 一、内部类的基本使用</h2><p>内部类概念<br>在一个类中定义一个类。举例：在一个类 A 的内部定义一个类 B，类 B 就被称为内部类<br>内部类定义格式<br>格式 &amp; 举例：</p><pre><code class="language-java">class Outer &#123;
    public class Inner &#123;
    &#125;
&#125;
</code></pre><p>Inner 为内部类</p><p>内部类的访问特点<br>内部类可以直接访问外部类的成员，包括私有<br>外部类要访问内部类的成员，必须创建对象</p><p>示例代码：</p><pre><code class="language-java">public class Outer &#123;
    private int num = 10;
    public class Inner &#123;
        public void show() &#123;
            System.out.println(num);
        &#125;
    &#125;
    public void method() &#123;
        Inner i = new Inner();
        i.show();
    &#125;
&#125;
</code></pre><h2 id="二-成员内部类"><a class="anchor" href="#二-成员内部类">#</a> 二、 成员内部类</h2><p>成员内部类的定义位置<br>在类中方法，跟成员变量是一个位置<br>外界创建成员内部类格式<br>格式：外部类名。内部类名 对象名 = 外部类对象。内部类对象；<br>举例：Outer.Inner oi = new Outer ().new Inner ();<br>成员内部类的推荐使用方案<br>将一个类，设计为内部类的目的，大多数都是不想让外界去访问，所以内部类的定义应该私有化，私有<br>化之后，再提供一个可以让外界调用的方法，方法内部创建内部类对象并调用。</p><p>示例代码：</p><pre><code class="language-java">class Outer &#123;
    private int num = 10;
    private class Inner &#123;
        public void show() &#123;
            System.out.println(num);
        &#125;
    &#125;
    public void method() &#123;
        Inner i = new Inner();
        i.show();
    &#125;
&#125;
public class Main&#123;
    public static void main(String[] args) &#123;
//Outer.Inner oi = new Outer().new Inner();//类未被私有化可以这样实例化
//oi.show();
        //建议做法
        Outer o = new Outer();
        o.method();
    &#125;
&#125;
</code></pre><h2 id="三-局部内部类"><a class="anchor" href="#三-局部内部类">#</a> 三、局部内部类</h2><p>局部内部类定义位置<br>局部内部类是在方法中定义的类<br>局部内部类方式方式<br>局部内部类，外界是无法直接使用，需要在方法内部创建对象并使用<br>该类可以直接访问外部类的成员，也可以访问方法内的局部变量</p><p>示例代码</p><pre><code class="language-java">class Outer &#123;
    private int num = 10;
    public void method() &#123;
        int num2 = 20;
        class Inner &#123;//Inner为成员内部类
            public void show() &#123;
                System.out.println(num);
                System.out.println(num2);
            &#125;
        &#125;
        Inner i = new Inner();
        i.show();
    &#125;
&#125;
public class Main &#123;
    public static void main(String[] args) &#123;
        Outer o = new Outer();
        o.method();
    &#125;
&#125;

</code></pre><h2 id="四-匿名内部类"><a class="anchor" href="#四-匿名内部类">#</a> 四、 匿名内部类</h2><p>匿名内部类的前提<br>存在一个类或者接口，这里的类可以是具体类也可以是抽象类<br>匿名内部类的格式<br>格式：new 类名 () { 重写方法} new 接口名 ( ) { 重写方法 }<br>举例：</p><pre><code>new Inter()&#123;
     @Override

     public void method()&#123;&#125;
&#125;

</code></pre><p>匿名内部类的本质<br>本质：是一个继承了该类或者实现了该接口的子类匿名对象<br>匿名内部类的细节<br>匿名内部类可以通过多态的形式接受</p><pre><code class="language-java">Inter i = new Inter()&#123;

    @Override

    public void method()&#123;

    &#125;
&#125;
</code></pre><p>匿名内部类直接调用方法</p><pre><code class="language-java">interface Inter&#123;
    void method();
&#125;
class Test&#123;
    public static void main(String[] args)&#123;
        new Inter()&#123;
            @Override
            public void method()&#123;
                System.out.println(&quot;我是匿名内部类&quot;);
            &#125;
        &#125;.method(); // 直接调用方法
        //方法2，更常用
        Inter i=new Inter() &#123;
            @Override
            public void method() &#123;
                System.out.println(&quot;我是匿名内部类&quot;);
            &#125;
        &#125;;
        i.method();
    &#125;
&#125;
</code></pre><p><img data-src="/youdaonote-images/WEBRESOURCEa400edcef61d8993f9ba9d1273fcaa05.jpeg" alt=""></p><h2 id="五-匿名内部类在开发中的使用"><a class="anchor" href="#五-匿名内部类在开发中的使用">#</a> 五、 匿名内部类在开发中的使用</h2><p>匿名内部类在开发中的使用<br>当发现某个方法需要，接口或抽象类的子类对象，我们就可以传递一个匿名内部类过去，来简化传统的<br>代码</p><p>示例代码</p><pre><code class="language-java">interface jumping &#123;
    void jump();
&#125;
class Cat implements jumping &#123;
    @Override
    public void jump() &#123;
        System.out.println(&quot;猫可以跳高了&quot;);
    &#125;
&#125;
class Dog implements jumping &#123;
    @Override
    public void jump() &#123;
        System.out.println(&quot;狗可以跳高了&quot;);
    &#125;
&#125;
class jumpingOperator &#123;
    public void method(jumping j) &#123; //new Cat();new Dog();
        j.jump();
    &#125;
&#125;
class jumpingDemo &#123;
    public static void main(String[] args) &#123;
//需求：创建接口操作类的对象，调用method方法
        /*
        如果需要使用多次方法，并且每次的输出不同时，通过
        创建对象的方法来进行输出就太麻烦了；
        // */
        jumpingOperator jo = new jumpingOperator();
        jumping j = new Cat();
        jo.method(j);
        jumping j2 = new Dog();
        jo.method(j2);
        System.out.println(&quot;猫可以跳高了&quot;);
// 匿名内部类的简化
        jo.method(new jumping() &#123;
            @Override
            public void jump() &#123;
                System.out.println(&quot;猫可以跳高了&quot;);
            &#125;
        &#125;);
// 匿名内部类的简化
        jo.method(new jumping() &#123;
            @Override
            public void jump() &#123;
                System.out.println(&quot;狗可以跳高了&quot;);
            &#125;
        &#125;);
    &#125;
&#125;
</code></pre><h1 id="常用api"><a class="anchor" href="#常用api">#</a> 常用 API</h1><h2 id="一-math"><a class="anchor" href="#一-math">#</a> 一、Math</h2><p>Math 类概述<br>Math 包含执行基本数字运算的方法<br>Math 中方法的调用方式<br>Math 类中无构造方法，但内部的方法都是静态的，则可以通过 类名。进行调用<br>Math 类的常用方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static int abs(int a)</td><td>返回参数的绝对值</td></tr><tr><td>public static double ceil(double a)</td><td>返回大于或等于参数的最小 double 值，等于一个整 &lt;br&gt; 数</td></tr><tr><td>public static double floor(double a)</td><td>返回小于或等于参数的最大 double 值，等于一个整 &lt;br&gt; 数</td></tr><tr><td>public static int round(float a)</td><td>按照四舍五入返回最接近参数的 int</td></tr><tr><td>public static int max(int a,int b)</td><td>返回两个 int 值中的较大值</td></tr><tr><td>public static int min(int a,int b)</td><td>返回两个 int 值中的较小值</td></tr><tr><td>public static double pow (double a,double&lt;br&gt;b)&lt;br&gt;</td><td>返回 a 的 b 次幂的值</td></tr><tr><td>public static double random()</td><td>返回值为 double 的正值，[0.0,1.0)</td></tr></tbody></table><h2 id="二-system"><a class="anchor" href="#二-system">#</a> 二、 System</h2><p>System 类的常用方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static void exit(int status)</td><td>终止当前运行的 Java 虚拟机，非零表示异常终止</td></tr><tr><td>public static long currentTimeMillis()</td><td>返回当前时间 (以毫秒为单位)</td></tr></tbody></table><p>示例代码</p><p>需求：在控制台输出 1-10000，计算这段代码执行了多少毫秒</p><pre><code class="language-java">public class Main &#123;
    public static void main(String[] args) &#123;
// 获取开始的时间节点
        long start = System.currentTimeMillis();
        for (int i = 1; i &lt;= 10000; i++) &#123;
            System.out.println(i);
        &#125;
// 获取代码运行结束后的时间节点
        long end = System.currentTimeMillis();
        System.out.println(&quot;共耗时：&quot; + (end - start) + &quot;毫秒&quot;);
    &#125;
&#125;
</code></pre><h2 id="三-object类的tostring方法"><a class="anchor" href="#三-object类的tostring方法">#</a> 三、Object 类的 toString 方法</h2><p>Object 类概述<br>Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类，<br>换句话说，该类所具备的方法，所有类都会有一份<br>查看方法源码的方式<br>选中方法，按下 Ctrl + B<br>重写 toString 方法的方式<br>1. Alt + Insert 选择 toString<br>2. 在类的空白区域，右键 -&gt; Generate -&gt; 选择 toString<br>toString 方法的作用：<br>以良好的格式，更方便的展示对象中的属性值<br>示例代码：</p><pre><code class="language-java">class Student extends Object&#123;
    private String name;
    private int age;

    public Student() &#123;
    &#125;

    public Student(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '&#125;';
    &#125;
&#125;
public class Main &#123;
    public static void main(String[] args) &#123;
        Student student = new Student();
        student.setName(&quot;大傻逼&quot;);
        student.setAge(20);
        System.out.println(student);//直接输出时会自动执行toString
        System.out.println(student.toString());
    &#125;
&#125;
</code></pre><p>运行结果</p><pre><code>Student&#123;name='大傻逼', age=20&#125;
Student&#123;name='大傻逼', age=20&#125;

</code></pre><h2 id="四-object类的equals方法"><a class="anchor" href="#四-object类的equals方法">#</a> 四、Object 类的 equals 方法</h2><p>equals 方法的作用<br>用于对象之间的比较，返回 true 和 false 的结果<br>举例：s1.equals (s2); s1 和 s2 是两个对象<br>重写 equals 方法的场景<br>不希望比较对象的地址值，想要结合对象属性进行比较的时候。<br>重写 equals 方法的方式<br>1. alt + insert 选择 equals () and hashCode ()，IntelliJ Default，一路 next，finish 即可<br>2. 在类的空白区域，右键 -&gt; Generate -&gt; 选择 equals () and hashCode ()，后面的同上。<br>示例代码</p><pre><code class="language-java">class Student &#123;
    private String name;
    private int age;
    public Student() &#123;
    &#125;
    public Student(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public int getAge() &#123;
        return age;
    &#125;
    public void setAge(int age) &#123;
        this.age = age;
    &#125;
    @Override
    public boolean equals(Object o) &#123;
//this -- s1
//o -- s2
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Student student = (Student) o; //student -- s2
        if (age != student.age) return false;
        return name != null ? name.equals(student.name) : student.name == null;
    &#125;
&#125;
public class Main &#123;
    public static void main(String[] args) &#123;
        Student s1 = new Student();
        s1.setName(&quot;林青霞&quot;);
        s1.setAge(30);
        Student s2 = new Student();
        s2.setName(&quot;林青霞&quot;);
        s2.setAge(30);
//需求：比较两个对象的内容是否相同
        System.out.println(s1.equals(s2));
    &#125;
&#125;
</code></pre><h2 id="五-冒泡排序原理"><a class="anchor" href="#五-冒泡排序原理">#</a> 五、 冒泡排序原理</h2><p>冒泡排序概述<br>一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，将较大的数据放在后面，依次对所<br>有的数据进行操作，直至所有数据按要求完成排序<br>如果有 n 个数据进行排序，总共需要比较 n-1 次<br>每一次比较完毕，下一次的比较就会少一个数据参与</p><h2 id="六-冒泡排序代码实现"><a class="anchor" href="#六-冒泡排序代码实现">#</a> 六、冒泡排序代码实现</h2><p>代码实现</p><pre><code class="language-java">/*
冒泡排序：
一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，将较大的数据放在后面，
依次对所有的数据进行操作，直至所有数据按要求完成排序
*/
public class Main &#123;
    public static void main(String[] args) &#123;
//定义一个数组
        int[] arr = &#123;24, 69, 80, 57, 13&#125;;
        System.out.println(&quot;排序前：&quot; + arrayToString(arr));
// 这里减1，是控制每轮比较的次数
        for (int x = 0; x &lt; arr.length - 1; x++) &#123;
// ­1是为了避免索引越界，-x是为了调高比较效率
            for (int i = 0; i &lt; arr.length - 1 - x; i++) &#123;
                if (arr[i] &gt; arr[i + 1]) &#123;
                    int temp = arr[i];
                    arr[i] = arr[i + 1];
                    arr[i + 1] = temp;
                &#125;
            &#125;
        &#125;
        System.out.println(&quot;排序后：&quot; + arrayToString(arr));
    &#125;
    //把数组中的元素按照指定的规则组成一个字符串：[元素1, 元素2, ...]
    public static String arrayToString(int[] arr) &#123;
        StringBuilder sb = new StringBuilder();
        sb.append(&quot;[&quot;);
        for (int i = 0; i &lt; arr.length; i++) &#123;
            if (i == arr.length - 1) &#123;
                sb.append(arr[i]);
            &#125; else &#123;
                sb.append(arr[i]).append(&quot;, &quot;);
            &#125;
        &#125;
        sb.append(&quot;]&quot;);
        String s = sb.toString();
        return s;
    &#125;
&#125;
</code></pre><h2 id="七-arrays"><a class="anchor" href="#七-arrays">#</a> 七、Arrays</h2><p>Arrays 的常用方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static String toString(int[] a)</td><td>返回指定数组的内容的字符串表示形式</td></tr><tr><td>public static void sort(int[] a)</td><td>按照数字顺序排列指定的数组</td></tr></tbody></table><p>工具类设计思想<br>1、构造方法用 private 修饰<br>2、成员用 public static 修饰</p><h1 id="包装类"><a class="anchor" href="#包装类">#</a> 包装类</h1><h2 id="一-基本类型包装类"><a class="anchor" href="#一-基本类型包装类">#</a> 一、基本类型包装类</h2><p>基本类型包装类的作用<br>将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据<br>常用的操作之一：用于基本数据类型与字符串之间的转换</p><p>基本类型对应的包装类</p><table><thead><tr><th>基本数据类型</th><th>包装类 &lt;br&gt;</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h2 id="二-integer类"><a class="anchor" href="#二-integer类">#</a> 二、Integer 类</h2><p>Integer 类概述<br>包装一个对象中的原始类型 int 的值</p><p>Integer 类构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public Integer(int value)</td><td>根据 int 值创建 Integer 对象 (过时)&lt;br&gt;</td></tr><tr><td>public Integer(String s)</td><td>根据 String 值创建 Integer 对象 (过时</td></tr><tr><td>public static Integer valueOf(int i)</td><td>返回表示指定的 int 值的 Integer 实例 &lt;br&gt;</td></tr><tr><td>public static Integer valueOf(String s)</td><td>返回一个保存指定值的 Integer 对象 String</td></tr></tbody></table><p>示例代🐎</p><pre><code class="language-java">public class Main &#123;
    public static void main(String[] args) &#123;
//public Integer(int value)：根据 int 值创建 Integer 对象(过时)
        Integer i1 = new Integer(100);
        System.out.println(i1);
//public Integer(String s)：根据 String 值创建 Integer 对象(过时)
        Integer i2 = new Integer(&quot;100&quot;);
// Integer i2 = new Integer(&quot;abc&quot;); //NumberFormatException
        System.out.println(i2);
        System.out.println(&quot;--------&quot;);
//public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例
        Integer i3 = Integer.valueOf(100);
        System.out.println(i3);
//public static Integer valueOf(String s)：返回一个保存指定值的Integer对象String
        Integer i4 = Integer.valueOf(&quot;100&quot;);
        System.out.println(i4);
    &#125;
&#125;

</code></pre><p>无论是 public Integer (String s) 还是 public static Integer valueOf (String s) 其中 s 的值都必须只存在数字</p><h2 id="三-int和string类型的相互转换"><a class="anchor" href="#三-int和string类型的相互转换">#</a> 三、int 和 String 类型的相互转换</h2><p>int 转换为 String<br>转换方式<br>方式一：直接在数字后加一个空字符串<br>方式二：通过 String 类静态方法 valueOf ()<br>示例代🐎</p><pre><code class="language-java">public class Main &#123;
    public static void main(String[] args) &#123;
//int --- String
        int number = 100;
//方式1
        String s1 = number + &quot;&quot;;
        System.out.println(s1);
//方式2
//public static String valueOf(int i)
        String s2 = String.valueOf(number);
        System.out.println(s2);
        System.out.println(&quot;--------&quot;);
    &#125;
&#125;
</code></pre><p>String 转换为 int<br>转换方式<br>方式一：先将字符串数字转成 Integer，再调用 valueOf () 方法<br>方式二：通过 Integer 静态方法 parseInt () 进行转换<br>示例代码</p><pre><code class="language-java">public class Main &#123;
    public static void main(String[] args) &#123;
//String --- int
        String s = &quot;100&quot;;
//方式1：String --- Integer --- int
        Integer i = Integer.valueOf(s);
//public int intValue()
        int x = i.intValue();
        System.out.println(x);
//方式2
//public static int parseInt(String s)
        int y = Integer.parseInt(s);
        System.out.println(y);
    &#125;
&#125;
</code></pre><h2 id="四-自动拆箱和自动装箱"><a class="anchor" href="#四-自动拆箱和自动装箱">#</a> 四、自动拆箱和自动装箱</h2><p>自动装箱<br>把基本数据类型转换为对应的包装类类型<br>自动拆箱<br>把包装类类型转换为对应的基本数据类型<br>示例代码</p><pre><code class="language-java">Integer i = 100; // 自动装箱
i += 200; // i = i + 200; i + 200 自动拆箱；i = i + 200; 是自动装箱
</code></pre><p>自动装箱可以让 Integer 直接等于 int 的值，自动拆箱可以直接让 int 等于 Integer</p><p>在自动装箱和自动拆箱的过程中 Java 自动执行了拆装箱的方法</p><h1 id="时间日期类"><a class="anchor" href="#时间日期类">#</a> 时间日期类</h1><h2 id="一-date类"><a class="anchor" href="#一-date类">#</a> 一、Date 类</h2><p>Date 类概述<br>Date 代表了一个特定的时间，精确到毫秒</p><p>Date 类构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public Date()</td><td>分配一个 Date 对象，并初始化，以便它代表它被分配的时间，精确到毫秒 &lt;br&gt;</td></tr><tr><td>public Date(long date)</td><td>分配一个 Date 对象，并将其初始化为表示从标准基准时间起指定的毫秒数 &lt;br&gt;</td></tr></tbody></table><pre><code class="language-java">import java.util.Date;
public class Main &#123;
    public static void main(String[] args) &#123;
//public Date()：分配一个 Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒
        Date d1 = new Date();
        System.out.println(d1);
//public Date(long date)：分配一个 Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数
        long date = 1000*60*60;
        Date d2 = new Date(date);
        System.out.println(d2);
    &#125;
&#125;
</code></pre><h2 id="二-date类常用方法"><a class="anchor" href="#二-date类常用方法">#</a> 二、Date 类常用方法</h2><p>常用方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public long getTime()</td><td>获取的是日期对象从 1970 年 1 月 1 日 00:00:00 到现在的毫秒值</td></tr><tr><td>public void setTime(long time)</td><td>设置时间，给的是毫秒值</td></tr></tbody></table><pre><code class="language-java">import java.util.Date;

public class Main &#123;
    public static void main(String[] args) &#123;
//创建日期对象
        Date d = new Date();
        //public long getTime():获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值
        System.out.println(d.getTime());
        System.out.println(d.getTime() * 1.0 / 1000 / 60 / 60 / 24 / 365 + &quot;年&quot;);
        //public void setTime(long time):设置时间，给的是毫秒值
        // long time = 1000*60*60;
        long time = System.currentTimeMillis();
        d.setTime(time);
        System.out.println(d);
    &#125;
&#125;
</code></pre><h2 id="三-simpledateformat类"><a class="anchor" href="#三-simpledateformat类">#</a> 三、SimpleDateFormat 类</h2><p>SimpleDateFormat 类概述<br>SimpleDateFormat 是一个具体的类，用于以区域设置敏感的方式格式化和解析日期。<br>我们重点学习日期格式化和解析</p><p>SimpleDateFormat 类构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public SimpleDateFormat()</td><td>构造一个 SimpleDateFormat，使用默认模式和日期格式</td></tr><tr><td>public SimpleDateFormat(String&lt;br&gt;pattern)</td><td>构造一个 SimpleDateFormat 使用给定的模式和默认的日期 &lt;br&gt; 格式 &lt; br&gt;</td></tr></tbody></table><p>SimpleDateFormat 类的常用方法<br>格式化 (从 Date 到 String)<br>public final String format (Date date)：将日期格式化成日期 / 时间字符串<br>解析 (从 String 到 Date)</p><p>public Date parse (String source)：从给定字符串的开始解析文本以生成日期</p><p>示例代码</p><pre><code class="language-java">import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
public class Main &#123;
    public static void main(String[] args) throws ParseException &#123;
//格式化：从 Date 到 String
        Date d = new Date();
// SimpleDateFormat sdf = new SimpleDateFormat();
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);
        String s = sdf.format(d);
        System.out.println(s);
        System.out.println(&quot;--------&quot;);
//从 String 到 Date
        String ss = &quot;2048-08-09 11:11:11&quot;;
//ParseException
//输入的字符串要和模式串匹配
        SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        Date dd = sdf2.parse(ss);
        System.out.println(dd);
    &#125;
&#125;
</code></pre><h2 id="四-calendar类"><a class="anchor" href="#四-calendar类">#</a> 四、Calendar 类</h2><p>Calendar 类概述<br>Calendar 为特定瞬间与一组日历字段之间的转换提供了一些方法，并为操作日历字段提供了一些方法<br>Calendar 提供了一个类方法 getInstance 用于获取这种类型的一般有用的对象。<br>该方法返回一个 Calendar 对象。<br>其日历字段已使用当前日期和时间初始化：Calendar rightNow = Calendar.getInstance ();<br>Calendar 类常用方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public int get(int field)</td><td>返回给定日历字段的值</td></tr><tr><td>public abstract void add(int field, int&lt;br&gt;amount)</td><td>根据日历的规则，将指定的时间量添加或减去给定的日 &lt;br&gt; 历字段</td></tr><tr><td>public final void set(int year,int month,int&lt;br&gt;date)</td><td>设置当前日历的年月日</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">import java.util.Calendar;

public class Main &#123;
    public static void main(String[] args) &#123;
        Calendar c=Calendar.getInstance();
        print(c);
        //public abstract void add(int field, int amount):根据日历的规则，将指定的时间量添加或减去给定的日历字段
        c.add(Calendar.DATE,10);
        print(c);
        c.add(Calendar.DATE,-3);
        print(c);
        //public final void set(int year,int month,int date):设置当前日历的年月日
        c.set(2090,5,20);
        print(c);
    &#125;
    public static void print(Calendar c)&#123;
        int year=c.get(Calendar.YEAR);
        int month=c.get(Calendar.MONTH)+1;//month的范围是0-11，因此需要加一；
        int day=c.get(Calendar.DATE);
        System.out.println(year+&quot;年&quot;+month+&quot;月&quot;+day+&quot;日&quot;);
    &#125;
&#125;
</code></pre><h1 id="异常"><a class="anchor" href="#异常">#</a> 异常</h1><h2 id="一-异常"><a class="anchor" href="#一-异常">#</a> 一、异常</h2><p>异常的概述<br>异常就是程序出现了不正常的情况<br>异常的体系结构</p><p><img data-src="/youdaonote-images/WEBRESOURCEf54367a3e80ba9f9fbc4b7c742eac0e5.jpeg" alt=""></p><p>Error 一般是硬件上出问题，如内存不足；</p><h2 id="二-jvm默认处理异常的方式"><a class="anchor" href="#二-jvm默认处理异常的方式">#</a> 二、JVM 默认处理异常的方式</h2><p>如果程序出现了问题，我们没有做任何处理，最终 JVM 会做默认的处理，处理方式有如下两个步骤：<br>把异常的名称，错误原因及异常出现的位置等信息输出在了控制台<br>程序停止执行</p><h2 id="三-try-catch方式处理异常"><a class="anchor" href="#三-try-catch方式处理异常">#</a> 三、try-catch 方式处理异常</h2><p>定义格式</p><pre><code class="language-java">try &#123;
可能出现异常的代码;
&#125; catch(异常类名 变量名) &#123;
异常的处理代码;
&#125;

</code></pre><p>执行流程</p><p>程序从 try 里面的代码开始执行<br>出现异常，就会跳转到对应的 catch 里面去执行<br>执行完毕之后，程序还可以继续往下执行</p><p>演示代码</p><pre><code class="language-java">public class Main &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;开始&quot;);
        method();
        System.out.println(&quot;结束&quot;);
    &#125;
    public static void method() &#123;
        try &#123;
            int[] arr = &#123;1, 2, 3&#125;;
            System.out.println(arr[3]);
            System.out.println(&quot;这里能够访问到吗&quot;);//发生错误后直接跳转到catch这里不会被执行
        &#125; catch (ArrayIndexOutOfBoundsException e) &#123;
        // System.out.println(&quot;你访问的数组索引不存在，请回去修改为正确的索引&quot;);
            e.printStackTrace();
        &#125;
    &#125;
&#125;

</code></pre><h2 id="四-throwable成员方法"><a class="anchor" href="#四-throwable成员方法">#</a> 四、Throwable 成员方法</h2><p>常用方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public String getMessage()</td><td>返回此 throwable 的详细消息字符串 &lt;br&gt;</td></tr><tr><td>public String toString()</td><td>返回此可抛出的简短描述</td></tr><tr><td>public void printStackTrace()</td><td>把异常的错误信息输出在控制台 &lt;br&gt;</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">public class Main &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;开始&quot;);
        method();
        System.out.println(&quot;结束&quot;);
    &#125;
    public static void method() &#123;
        try &#123;
            int[] arr = &#123;1, 2, 3&#125;;
            System.out.println(arr[3]); //new ArrayIndexOutOfBoundsException();
        &#125; catch (ArrayIndexOutOfBoundsException e) &#123; //newArrayIndexOutOfBoundsException();
            System.out.println(e.getMessage());
            /**输出结果：
             * Index 3 out of bounds for length 3
             */
            System.out.println(e.toString());
            /**输出结果
             * java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3
             */
            e.printStackTrace();//一般使用这个方法
            /**运行结果
             * java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3
             *     at Main.method(Main.java:10)
             *     at Main.main(Main.java:4)
             */
        &#125;
    &#125;
&#125;

</code></pre><h2 id="五-编译时异常和运行时异常的区别"><a class="anchor" href="#五-编译时异常和运行时异常的区别">#</a> 五、编译时异常和运行时异常的区别</h2><p>编译时异常<br>都是 Exception 类及其子类<br>必须显示处理，否则程序就会发生错误，无法通过编译（在 IDEA 中会报错）</p><p>编译异常可能有错误也可能没有，但是必须要处理<br>运行时异常<br>都是 RuntimeException 类及其子类<br>无需显示处理，也可以和编译时异常一样处理</p><h2 id="六-throws方式处理异常"><a class="anchor" href="#六-throws方式处理异常">#</a> 六、throws 方式处理异常</h2><p>定义格式</p><pre><code class="language-java">public void 方法() throws 异常类名 &#123;
&#125;

</code></pre><p>示例代码</p><pre><code class="language-java">import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class Main &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;开始&quot;);
// method();
        try &#123;
            method2();
        &#125;catch (ParseException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;结束&quot;);
    &#125;
    //编译时异常
    public static void method2() throws ParseException &#123;
        String s = &quot;2048-08-09&quot;;
        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        Date d = sdf.parse(s);
        System.out.println(d);
    &#125;
    //运行时异常
    public static void method() throws ArrayIndexOutOfBoundsException &#123;
        int[] arr = &#123;1, 2, 3&#125;;
        System.out.println(arr[3]);
    &#125;
&#125;
</code></pre><p>注意事项<br>这个 throws 格式是跟在方法的括号后面的<br>编译时异常必须要进行处理，两种处理方案：try...catch … 或者 throws，如果采用 throws 这种方案，<br>将来谁调用谁处理 (throw 不会处理异常，只会把异常抛出给调用者，如果不进行处理，同样会在控制台出错误)<br>运行时异常可以不处理，出现问题后，需要我们回来修改代码</p><h2 id="七-throws和throw的区别"><a class="anchor" href="#七-throws和throw的区别">#</a> 七、throws 和 throw 的区别</h2><p><img data-src="/youdaonote-images/WEBRESOURCE0daa341d2af7f1ddfe4e7e9377df439f.jpeg" alt=""></p><h2 id="八-自定义异常"><a class="anchor" href="#八-自定义异常">#</a> 八、自定义异常</h2><p>自定义异常类</p><pre><code class="language-java">package text;

public class ScoreException extends Exception&#123;
    public ScoreException() &#123;
    &#125;
    public ScoreException(String message) &#123;
        super(message);
    &#125;
&#125;

</code></pre><p>老师类</p><pre><code class="language-java">package text;

public class Teacher &#123;
    public void checkScore(int score) throws ScoreException &#123;
        if(score&lt;0 || score&gt;100) &#123;
// throw new ScoreException();
            throw new ScoreException(&quot;你给的分数有误，分数应该在0-100之间&quot;);
        &#125; else &#123;
            System.out.println(&quot;成绩正常&quot;);
        &#125;
    &#125;
&#125;
</code></pre><p>测试类</p><pre><code class="language-java">package text;

import java.util.Scanner;

public class Demo &#123;
    public static void main(String[] args) &#123;
        Scanner sc = new Scanner(System.in);
        System.out.println(&quot;请输入分数：&quot;);
        int score = sc.nextInt();
        Teacher t = new Teacher();
        try &#123;
            t.checkScore(score);
        &#125; catch (ScoreException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre><p>出错运行结果</p><p><img data-src="/youdaonote-images/WEBRESOURCE25cf5bfc2813fe259e443ec48c4153af.png" alt=""></p><h1 id="colection集合"><a class="anchor" href="#colection集合">#</a> colection 集合</h1><h2 id="一-集合体系结构"><a class="anchor" href="#一-集合体系结构">#</a> 一、集合体系结构</h2><p>集合类的特点<br>提供一种存储空间可变的存储模型，存储的数据容量可以随时发生改变</p><p>集合类的体系图</p><p><img data-src="/youdaonote-images/WEBRESOURCE34236cf0afcffe287051af61501188c2.jpeg" alt=""></p><h2 id="二-collection集合概述和基本使用"><a class="anchor" href="#二-collection集合概述和基本使用">#</a> 二、Collection 集合概述和基本使用</h2><p>Collection 集合概述<br>是单例集合的顶层接口，它表示一组对象，这些对象也称为 Collection 的元素<br>JDK 不提供此接口的任何直接实现，它提供更具体的子接口（如 Set 和 List）实现</p><p>Collection 集合基本使用</p><pre><code class="language-java">import java.util.ArrayList;
import java.util.Collection;

public class Main &#123;
    public static void main(String[] args) &#123;
        Collection&lt;String&gt; co=new ArrayList&lt;&gt;();
        co.add(&quot;一傻逼&quot;);
        co.add(&quot;二傻逼&quot;);
        co.add(&quot;三傻逼&quot;);
        System.out.println(co);
    &#125;
&#125;
</code></pre><p>结果</p><pre><code>[一傻逼, 二傻逼, 三傻逼]
</code></pre><p>collection 中重写了 toString 方法</p><h2 id="三-collection集合的常用方法"><a class="anchor" href="#三-collection集合的常用方法">#</a> 三、Collection 集合的常用方法</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>boolean add(E e)</td><td>添加元素</td></tr><tr><td>boolean remove(Object o)</td><td>从集合中移除指定的元素</td></tr><tr><td>void clear()</td><td>清空集合中的元素 &lt;br&gt;</td></tr><tr><td>boolean contains(Object o)</td><td>判断集合中是否存在指定的元素</td></tr><tr><td>boolean isEmpty()</td><td>判断集合是否为空</td></tr><tr><td>int size()</td><td>集合的长度，也就是集合中元素的个数</td></tr></tbody></table><h2 id="四-collection集合的遍历"><a class="anchor" href="#四-collection集合的遍历">#</a> 四、Collection 集合的遍历</h2><p>迭代器的介绍<br>迭代器，集合的专用遍历方式<br>Iterator iterator ()：返回此集合中元素的迭代器，通过集合的 iterator () 方法得到<br>迭代器是通过集合的 iterator () 方法得到的，所以我们说它是依赖于集合而存在的</p><p>Collection 集合的遍历</p><pre><code class="language-java">import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class Main &#123;
    public static void main(String[] args) &#123;
        Collection&lt;String&gt; co=new ArrayList&lt;&gt;();
        co.add(&quot;一傻逼&quot;);
        co.add(&quot;二傻逼&quot;);
        co.add(&quot;三傻逼&quot;);
        Iterator&lt;String&gt; it = co.iterator();
        while (it.hasNext())&#123;
            String s=it.next();//不直接输出是为了可能拿到s后需要做其他操作
            System.out.println(s);
        &#125;
    &#125;
&#125;
</code></pre><h1 id="list集合"><a class="anchor" href="#list集合">#</a> List 集合</h1><h2 id="一-list集合概述和特点"><a class="anchor" href="#一-list集合概述和特点">#</a> 一、List 集合概述和特点</h2><p>List 集合概述<br>有序集合 (也称为序列)，用户可以精确控制列表中每个元素的插入位置。用户可以通过整数索引访问元<br>素，并搜索列表中的元素<br>与 Set 集合不同，列表通常允许重复的元素<br>List 集合特点<br>有索引<br>可以存储重复元素<br>元素存取有序</p><h2 id="二-list集合的特有方法"><a class="anchor" href="#二-list集合的特有方法">#</a> 二、List 集合的特有方法</h2><table><thead><tr><th>方法名</th><th>描述 &lt;br&gt;</th></tr></thead><tbody><tr><td>void add(int index,E element)</td><td>在此集合中的指定位置插入指定的元素</td></tr><tr><td>E remove(int index)</td><td>删除指定索引处的元素，返回被删除的元素</td></tr><tr><td>E set(int index,E element)</td><td>修改指定索引处的元素，返回被修改的元素</td></tr><tr><td>E get(int index)</td><td>返回指定索引处的元素 &lt;br&gt;</td></tr></tbody></table><h2 id="三-并发修改异常"><a class="anchor" href="#三-并发修改异常">#</a> 三、并发修改异常</h2><p>出现的原因<br>迭代器遍历的过程中，通过集合对象修改了集合中的元素，造成了迭代器获取元素中判断预期修改值和实际<br>修改值不一致，则会出现：ConcurrentModificationException<br>解决的方案<br>用 for 循环遍历，然后用集合对象做对应的操作即可</p><p>在使用 add 是会将实际操作次数加一，使其与预期操作次数不同导致异常</p><h2 id="四-列表迭代器"><a class="anchor" href="#四-列表迭代器">#</a> 四、列表迭代器</h2><p>ListIterator 介绍<br>通过 List 集合的 listIterator () 方法得到，所以说它是 List 集合特有的迭代器<br>用于允许程序员沿任一方向遍历的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置</p><p>示例代码</p><pre><code class="language-java">import java.util.*;

public class Main &#123;
    public static void main(String[] args) &#123;
        List&lt;String&gt; co=new ArrayList&lt;&gt;();
        co.add(&quot;一傻逼&quot;);
        co.add(&quot;二傻逼&quot;);
        co.add(&quot;三傻逼&quot;);
        ListIterator&lt;String&gt; it=co.listIterator();
        while (it.hasNext())&#123;
            String s=it.next();
            System.out.println(s);
        &#125;
        System.out.println(&quot;-------&quot;);
        while (it.hasPrevious())&#123;
            String s=it.previous();//向前移动
            System.out.println(s);
        &#125;
        while (it.hasNext()) &#123;
            String s = it.next();
            if(s.equals(&quot;三傻逼&quot;)) &#123;
                it.add(&quot;四傻逼&quot;);
            &#125;
        &#125;
        System.out.println(co);
    &#125;
&#125;
</code></pre><p>输出结果</p><pre><code>一傻逼
二傻逼
三傻逼
-------
三傻逼
二傻逼
一傻逼
[一傻逼, 二傻逼, 三傻逼, 四傻逼]
</code></pre><p>ListIterator 很少使用</p><h2 id="五-增强for循环"><a class="anchor" href="#五-增强for循环">#</a> 五、增强 for 循环</h2><p>定义格式</p><pre><code class="language-java">for(元素数据类型 变量名 : 数组/集合对象名) &#123;
     循环体;

&#125;

</code></pre><h1 id="数据结构"><a class="anchor" href="#数据结构">#</a> 数据结构</h1><h2 id="一-数据结构之栈和队列"><a class="anchor" href="#一-数据结构之栈和队列">#</a> 一、数据结构之栈和队列</h2><p>栈结构<br>先进后出<br>队列结构<br>先进先出</p><h2 id="二-数据结构之数组和链表"><a class="anchor" href="#二-数据结构之数组和链表">#</a> 二、数据结构之数组和链表</h2><p>数组结构<br>查询快、增删慢<br>链表结构<br>查询慢、增删快</p><h1 id="list集合的实现类"><a class="anchor" href="#list集合的实现类">#</a> List 集合的实现类</h1><h2 id="一-list集合子类的特点"><a class="anchor" href="#一-list集合子类的特点">#</a> 一、List 集合子类的特点</h2><p>ArrayList 集合<br>底层是数组结构实现，查询快、增删慢（在不知道用那个 list 时一般用 ArrayList）<br>LinkedList 集合<br>底层是链表结构实现，查询慢、增删快</p><h2 id="二-linkedlist集合的特有功能"><a class="anchor" href="#二-linkedlist集合的特有功能">#</a> 二、LinkedList 集合的特有功能</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public void addFirst(E e)</td><td>在该列表开头插入指定的元素 &lt;br&gt;</td></tr><tr><td>public void addLast(E e)</td><td>将指定的元素追加到此列表的末尾</td></tr><tr><td>public E getFirst()</td><td>返回此列表中的第一个元素</td></tr><tr><td>public E getLast()</td><td>返回此列表中的最后一个元素</td></tr><tr><td>public E removeFirst()</td><td>从此列表中删除并返回第一个元素</td></tr><tr><td>public E removeLast(</td><td>从此列表中删除并返回最后一个元素</td></tr></tbody></table><h1 id="set集合"><a class="anchor" href="#set集合">#</a> set 集合</h1><h2 id="一-set集合概述和特点"><a class="anchor" href="#一-set集合概述和特点">#</a> 一、Set 集合概述和特点</h2><p>Set 集合的特点<br>元素存取无序<br>没有索引、只能通过迭代器或增强 for 循环遍历<br>不能存储重复元素<br>Set 集合的基本使用</p><pre><code class="language-java">import java.util.*;

public class Main &#123;
    public static void main(String[] args) &#123;
        Set&lt;String&gt;a=new HashSet&lt;&gt;();
        a.add(&quot;一&quot;);
        a.add(&quot;二&quot;);
        a.add(&quot;三&quot;);
        for (String i:a)&#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;
</code></pre><p>输出结果</p><pre><code>一
三
二
</code></pre><h2 id="二-哈希值"><a class="anchor" href="#二-哈希值">#</a> 二、哈希值</h2><p>哈希值简介<br>是 JDK 根据对象的地址或者字符串或者数字算出来的 int 类型的数值<br>如何获取哈希值<br>Object 类中的 public int hashCode ()：返回对象的哈希码值<br>哈希值的特点<br>同一个对象多次调用 hashCode () 方法返回的哈希值是相同的<br>默认情况下，不同对象的哈希值是不同的。而重写 hashCode () 方法，可以实现让不同对象的哈希值相同</p><p>演示代码</p><pre><code class="language-java">import java.util.*;
class Student&#123;
    private String name;
    private int age;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public Student() &#123;
    &#125;

    public Student(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
&#125;
public class Main &#123;
    public static void main(String[] args) &#123;
        Student a=new Student(&quot;张三&quot;,15);
        //多次调用同一个对象，哈希值是相同的；
        System.out.println(a.hashCode());
        System.out.println(a.hashCode());
        Student b=new Student(&quot;张三&quot;,15);
        //不同对象即使是变量相同，哈希值是不同的
        System.out.println(b.hashCode());
        //相同字符串输出的哈希值相同
        System.out.println(&quot;hello&quot;.hashCode());
        System.out.println(&quot;hello&quot;.hashCode());
        System.out.println(&quot;world&quot;.hashCode());
        //重写了hashCode因此哈希值是相同的
        System.out.println(&quot;重地&quot;.hashCode());
        System.out.println(&quot;通话&quot;.hashCode());
    &#125;
&#125;
</code></pre><p>代码演示</p><pre><code>41903949//a
41903949//a
488970385//b
99162322//&quot;hello&quot;
99162322//&quot;hello&quot;
113318802//&quot;world&quot;
1179395//&quot;重地&quot;
1179395//&quot;通话&quot;
</code></pre><h2 id="三-hashset集合概述和特点"><a class="anchor" href="#三-hashset集合概述和特点">#</a> 三、HashSet 集合概述和特点</h2><p>HashSet 集合的特点<br>底层数据结构是哈希表<br>对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致<br>没有带索引的方法，所以不能使用普通 for 循环遍历 (只能用增强 for 或迭代器)<br>由于是 Set 集合，所以是不包含重复元素的集合 1<br>HashSet 集合的基本使用</p><pre><code class="language-java">import java.util.HashSet;

public class Main &#123;
    public static void main(String[] args) &#123;
        HashSet&lt;String&gt; ha = new HashSet&lt;&gt;();
        ha.add(&quot;张三&quot;);
        ha.add(&quot;李四&quot;);
        ha.add(&quot;王五&quot;);
        for (String i:ha)&#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;
</code></pre><p>输出结果</p><pre><code>李四
张三
王五
</code></pre><h2 id="四-hashset集合保证元素唯一性源码分析"><a class="anchor" href="#四-hashset集合保证元素唯一性源码分析">#</a> 四、HashSet 集合保证元素唯一性源码分析</h2><p>HashSet 集合保证元素唯一性的原理<br>1. 根据对象的哈希值计算存储位置<br>如果当前位置没有元素则直接存入<br>如果当前位置有元素存在，则进入第二步<br>2. 当前元素的元素和已经存在的元素比较哈希值<br>如果哈希值不同，则将当前元素进行存储<br>如果哈希值相同，则进入第三步<br>3. 通过 equals () 方法比较两个元素的内容<br>如果内容不相同，则将当前元素进行存储</p><p>如果内容相同，则不存储当前元素</p><p>HashSet 集合保证元素唯一性的图解</p><p><img data-src="/youdaonote-images/WEBRESOURCEac7036bef12f7df8c6401c7f472792df.png" alt=""></p><h2 id="五-常见数据结构之哈希表"><a class="anchor" href="#五-常见数据结构之哈希表">#</a> 五、常见数据结构之哈希表</h2><p>哈希表是数组和链表的结合</p><p>数组的大小一般为 16</p><p><img data-src="/youdaonote-images/WEBRESOURCEb0457a0a6fe067ab778dc7ddb3309984.png" alt=""></p><h2 id="六-linkedhashset集合概述和特点"><a class="anchor" href="#六-linkedhashset集合概述和特点">#</a> 六、LinkedHashSet 集合概述和特点</h2><p>LinkedHashSet 集合特点<br>哈希表和链表实现的 Set 接口，具有可预测的迭代次序<br>由链表保证元素有序，也就是说元素的存储和取出顺序是一致的<br>由哈希表保证元素唯一，也就是说没有重复的元素<br>LinkedHashSet 集合基本使用</p><pre><code class="language-java">import java.util.LinkedHashSet;

public class Main &#123;
    public static void main(String[] args) &#123;
        LinkedHashSet&lt;String&gt; list = new LinkedHashSet&lt;&gt;();

        list.add(&quot;一一一&quot;);
        list.add(&quot;二二二&quot;);
        list.add(&quot;三三三&quot;);
        for (String i:list)&#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;

</code></pre><p>输出结果</p><p><img data-src="/youdaonote-images/WEBRESOURCEd7903a8627fe4e5bc0edd92d745da439.png" alt=""></p><h1 id="set集合排序"><a class="anchor" href="#set集合排序">#</a> Set 集合排序</h1><h2 id="一-treeset集合概述和特点"><a class="anchor" href="#一-treeset集合概述和特点">#</a> 一、TreeSet 集合概述和特点</h2><p>TreeSet 集合概述</p><p>元素有序，可以按照一定的规则进行排序，具体排序方式取决于构造方法<br>TreeSet ()：根据其元素的自然排序进行排序<br>TreeSet (Comparator comparator) ：根据指定的比较器进行排序<br>没有带索引的方法，所以不能使用普通 for 循环遍历<br>由于是 Set 集合，所以不包含重复元素的集合</p><p>TreeSet 集合基本使用</p><pre><code class="language-java">import java.util.LinkedHashSet;
import java.util.TreeSet;

public class Main &#123;
    public static void main(String[] args) &#123;
        TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;();
        set.add(245789);
        set.add(134);
        set.add(124);
        set.add(1256);
        set.add(215);
        for (int i:set)&#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;

</code></pre><p>输出样例</p><p><img data-src="/youdaonote-images/WEBRESOURCEf4337ca412a4ea6f91e539cd7e295641.png" alt=""></p><h2 id="二-自然排序comparable的使用"><a class="anchor" href="#二-自然排序comparable的使用">#</a> 二、自然排序 Comparable 的使用</h2><p>案例需求<br>存储学生对象并遍历，创建 TreeSet 集合使用无参构造方法<br>要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序<br>实现步骤<br>用 TreeSet 集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的<br>自然排序，就是让元素所属的类实现 Comparable 接口，重写 compareTo (T o) 方法<br>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</p><p>示例代码</p><p>学生类</p><pre><code class="language-java">package text;

public class Student implements Comparable&lt;Student&gt; &#123;
    private String name;
    private int age;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public Student() &#123;
    &#125;

    public Student(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;

    @Override
    public String toString() &#123;
        return name +
                &quot;,&quot; + age;
    &#125;

    @Override
    public int compareTo(Student s) &#123;
        int num = this.age - s.age;
        num = num == 0 ? this.name.compareTo(s.name) : num;
        return num;
    &#125;
&#125;

</code></pre><p>测试类</p><pre><code class="language-java">package text;

import java.util.TreeSet;

public class Demo &#123;
    public static void main(String[] args) &#123;
        TreeSet&lt;Student&gt; set = new TreeSet&lt;&gt;();
        set.add(new Student(&quot;aaa&quot;, 24));
        set.add(new Student(&quot;ccc&quot;, 29));
        set.add(new Student(&quot;vvv&quot;, 27));
        set.add(new Student(&quot;bbb&quot;, 27));
        for (Student i : set) &#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;
</code></pre><p>输出结果</p><p><img data-src="/youdaonote-images/WEBRESOURCEd299fe41c52bbe00b6292533dc44e53d.png" alt=""></p><h2 id="三-比较器排序comparator的使用"><a class="anchor" href="#三-比较器排序comparator的使用">#</a> 三、比较器排序 Comparator 的使用</h2><p>案例需求<br>存储学生对象并遍历，创建 TreeSet 集合使用带参构造方法<br>要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序<br>实现步骤<br>用 TreeSet 集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的<br>比较器排序，就是让集合构造方法接收 Comparator 的实现类对象，重写 compare (T o1,T o2) 方法<br>重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</p><p>示例代码</p><p>学生类</p><pre><code class="language-java">package text;

public class Student&#123;
    private String name;
    private int age;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public Student() &#123;
    &#125;

    public Student(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;

    @Override
    public String toString() &#123;
        return name +
                &quot;,&quot; + age;
    &#125;
&#125;


</code></pre><p>测试类</p><pre><code class="language-java">package text;

import java.util.Comparator;
import java.util.TreeSet;

public class Demo &#123;
    public static void main(String[] args) &#123;
        TreeSet&lt;Student&gt; set = new TreeSet&lt;&gt;(new Comparator&lt;Student&gt;() &#123;
            @Override
            public int compare(Student s1, Student s2) &#123;
                int num=s1.getAge()-s2.getAge();
                num=num==0?s1.getName().compareTo(s2.getName()):num;
                return num;
            &#125;
        &#125;);
        set.add(new Student(&quot;aaa&quot;, 24));
        set.add(new Student(&quot;ccc&quot;, 29));
        set.add(new Student(&quot;vvv&quot;, 27));
        set.add(new Student(&quot;bbb&quot;, 27));
        for (Student i : set) &#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;

</code></pre><h1 id="泛型"><a class="anchor" href="#泛型">#</a> 泛型</h1><h2 id="一-泛型概述和好处"><a class="anchor" href="#一-泛型概述和好处">#</a> 一、泛型概述和好处</h2><p>泛型概述<br>是 JDK5 中引入的特性，它提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型<br>它的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。一提到参数，最熟悉的就是定义方<br>法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具<br>体的类型参数化，然后在使用 / 调用时传入具体的类型。这种参数类型可以用在类、方法和接口中，分别被称<br>为泛型类、泛型方法、泛型接口<br>泛型定义格式<br>&lt;类型&gt;：指定一种类型的格式。这里的类型可以看成是形参<br>&lt;类型 1, 类型 2…&gt;：指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参<br>将来具体调用时候给定的类型可以看成是实参，并且实参的类型只能是引用数据类型<br>泛型的好处<br>把运行时期的问题提前到了编译期间<br>避免了强制类型转换</p><h2 id="二-泛型类"><a class="anchor" href="#二-泛型类">#</a> 二、泛型类</h2><p>定义格式</p><p>修饰符 class 类名 &lt;类型&gt;</p><p>示例代码</p><p>泛型类</p><pre><code class="language-java">package text;

public class Generic &lt;T&gt;&#123;
    private T t;

    public T getT() &#123;
        return t;
    &#125;

    public void setT(T t) &#123;
        this.t = t;
    &#125;
&#125;

</code></pre><p>测试类</p><pre><code class="language-java">package text;

public class Demo &#123;
    public static void main(String[] args) &#123;
        Generic&lt;String&gt; g1 = new Generic&lt;&gt;();
        g1.setT(&quot;大傻逼&quot;);
        System.out.println(g1.getT());
        Generic&lt;Integer&gt; g2 = new Generic&lt;&gt;();
        g2.setT(2451);
        System.out.println(g2.getT());
        Generic&lt;Boolean&gt; g3 = new Generic&lt;&gt;();
        g3.setT(true);
        System.out.println(g3.getT());
    &#125;
&#125;

</code></pre><p>输出结果</p><p><img data-src="/youdaonote-images/WEBRESOURCEf0ca3a0bf8e2d0e5395f59a03f3c16ed.png" alt=""></p><h2 id="三-泛型方法"><a class="anchor" href="#三-泛型方法">#</a> 三、泛型方法</h2><p>定义格式</p><p>修饰符 &lt;类型&gt; 返回值类型 方法名 (类型 变量名)</p><p>示例代码</p><p>带有泛型方法的类</p><pre><code class="language-java">package text;

public class Generic &#123;
    public &lt;T&gt; void show(T t)&#123;
        System.out.println(t);
    &#125;
&#125;

</code></pre><p>测试类</p><pre><code class="language-java">package text;

public class Demo &#123;
    public static void main(String[] args) &#123;
        Generic g = new Generic();
        g.show(&quot;大傻逼&quot;);
        g.show(523);
        g.show(true);
        g.show(3.1415926535);
    &#125;
&#125;

</code></pre><p>输出结果</p><p><img data-src="/youdaonote-images/WEBRESOURCE8a15a4fc0c3d60b12a97ac77ef20eb96.png" alt=""></p><h2 id="四-泛型接口"><a class="anchor" href="#四-泛型接口">#</a> 四、泛型接口</h2><p>定义格式</p><p>修饰符 interface 接口名 &lt;类型&gt;</p><p>示例代码<br>泛型接口</p><pre><code class="language-java">package text;

public interface Generic &lt;T&gt;&#123;
    void show(T t);
&#125;

</code></pre><p>泛型接口实现类</p><pre><code class="language-java">package text;

public class GenericImpl&lt;T&gt; implements Generic&lt;T&gt;&#123;
    @Override
    public void show(T o) &#123;
        System.out.println(o);
    &#125;
&#125;

</code></pre><p>测试类</p><pre><code class="language-java">package text;

public class Demo &#123;
    public static void main(String[] args) &#123;
        Generic&lt;String&gt; g1 = new GenericImpl&lt;&gt;();
        g1.show(&quot;林青霞&quot;);
        Generic&lt;Integer&gt; g2 = new GenericImpl&lt;&gt;();
        g2.show(30);
    &#125;
&#125;

</code></pre><p>输出结果</p><p><img data-src="/youdaonote-images/WEBRESOURCE04bcb5afb1d70597465a06d1da62def2.png" alt=""></p><h2 id="五-类型通配符"><a class="anchor" href="#五-类型通配符">#</a> 五、类型通配符</h2><p>类型通配符的作用</p><p>为了表示各种泛型 List 的父类，可以使用类型通配符<br>类型通配符的分类<br>类型通配符：<br>List&lt;?&gt;：表示元素类型未知的 List，它的元素可以匹配任何的类型<br>这种带通配符的 List 仅表示它是各种泛型 List 的父类，并不能把元素添加到其中<br>类型通配符上限：<br>List&lt;? extends Number&gt;：它表示的类型是 Number 或者其子类型<br>类型通配符下限：<br>List&lt;? super Number&gt;：它表示的类型是 Number 或者其父类型<br>类型通配符的基本使用</p><pre><code class="language-java">package text;

import java.util.ArrayList;
import java.util.List;

public class Demo &#123;
    public static void main(String[] args) &#123;
//类型通配符：&lt;?&gt;
        List&lt;?&gt; list1 = new ArrayList&lt;Object&gt;();
        List&lt;?&gt; list2 = new ArrayList&lt;Number&gt;();
        List&lt;?&gt; list3 = new ArrayList&lt;Integer&gt;();
        System.out.println(&quot;--------&quot;);
//类型通配符上限：&lt;? extends 类型&gt;
// List&lt;? extends Number&gt; list4 = new ArrayList&lt;Object&gt;();//报错
        List&lt;? extends Number&gt; list5 = new ArrayList&lt;Number&gt;();
        List&lt;? extends Number&gt; list6 = new ArrayList&lt;Integer&gt;();
        System.out.println(&quot;--------&quot;);
//类型通配符下限：&lt;? super 类型&gt;
        List&lt;? super Number&gt; list7 = new ArrayList&lt;Object&gt;();
        List&lt;? super Number&gt; list8 = new ArrayList&lt;Number&gt;();
// List&lt;? super Number&gt; list9 = new ArrayList&lt;Integer&gt;();//报错
    &#125;
&#125;

</code></pre><h1 id="可变参数"><a class="anchor" href="#可变参数">#</a> 可变参数</h1><h2 id="一-可变参数"><a class="anchor" href="#一-可变参数">#</a> 一、可变参数</h2><p>可变参数介绍<br>可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了<br>可变参数定义格式</p><pre><code>	修饰符 返回值类型 方法名(数据类型… 变量名) &#123; &#125;
</code></pre><p>可变参数的注意事项<br>这里的变量其实是一个数组<br>如果一个方法有多个参数，包含可变参数，可变参数要放在最后<br>可变参数的基本使用</p><pre><code class="language-java">package text;

public class Demo &#123;
    public static void main(String[] args) &#123;
        System.out.println(sum(10, 20));
        System.out.println(sum(10, 20, 30));
        System.out.println(sum(10, 20, 30, 40));
        System.out.println(sum(10,20,30,40,50));
        System.out.println(sum(10,20,30,40,50,60));
        System.out.println(sum(10,20,30,40,50,60,70));
        System.out.println(sum(10,20,30,40,50,60,70,80,90,100));
    &#125;
    // public static int sum(int b,int... a) &#123;
// return 0;
// &#125;
    public static int sum(int... a) &#123;
        int sum = 0;
        for(int i : a) &#123;
            sum += i;
        &#125;
        return sum;
    &#125;

&#125;

</code></pre><p>输出结果</p><p><img data-src="/youdaonote-images/WEBRESOURCE0973b1e2ba51d01effa86d444cf1e8fe.png" alt=""></p><h2 id="二-可变参数的使用"><a class="anchor" href="#二-可变参数的使用">#</a> 二、可变参数的使用</h2><p>Arrays 工具类中有一个静态方法：<br>public static List asList (T... a)：返回由指定数组支持的固定大小的列表<br>返回的集合不能做增删操作，可以做修改操作<br>List 接口中有一个静态方法：<br>public static List of (E... elements)：返回包含任意数量元素的不可变列表<br>返回的集合不能做增删改操作<br>Set 接口中有一个静态方法：<br>public static Set of (E... elements) ：返回一个包含任意数量元素的不可变集合<br>在给元素的时候，不能给重复的元素<br>返回的集合不能做增删操作，没有修改的方法</p><p>示例代码</p><pre><code class="language-java">package text;
import java.util.Arrays;
import java.util.List;
import java.util.Set;

public class Demo &#123;
    public static void main(String[] args) &#123;
        List&lt;String&gt; list= Arrays.asList(&quot;一一一&quot;,&quot;二二二&quot;,&quot;三三三&quot;);
        System.out.println(list);
        List&lt;String&gt; list1=List.of(&quot;一一一&quot;,&quot;二二二&quot;,&quot;三三三&quot;);
        System.out.println(list1);
        Set&lt;String&gt; list2 = Set.of(&quot;一一一&quot;,&quot;二二二&quot;,&quot;三三三&quot;);
        System.out.println(list2);
    &#125;
&#125;

</code></pre><h1 id="map集合"><a class="anchor" href="#map集合">#</a> Map 集合</h1><h2 id="一-map集合概述和特点"><a class="anchor" href="#一-map集合概述和特点">#</a> 一、Map 集合概述和特点</h2><p>Map 集合概述</p><p>interface Map &lt;K,V&gt; K：键的类型；V：值的类型<br>Map 集合的特点<br>键值对映射关系<br>一个键对应一个值<br>键不能重复，值可以重复<br>元素存取无序</p><p>Map 集合的基本使用</p><pre><code class="language-java">package text;

import java.util.HashMap;
import java.util.Map;

public class Demo &#123;
    public static void main(String[] args) &#123;
//创建集合对象
        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
//V put(K key, V value) 将指定的值与该映射中的指定键相关联
        map.put(&quot;itheima001&quot;, &quot;林青霞&quot;);
        map.put(&quot;itheima002&quot;, &quot;张曼玉&quot;);
        map.put(&quot;itheima003&quot;, &quot;王祖贤&quot;);
        map.put(&quot;itheima003&quot;, &quot;柳岩&quot;);
//输出集合对象
        System.out.println(map);
    &#125;

&#125;

</code></pre><h2 id="二-map集合的基本功能"><a class="anchor" href="#二-map集合的基本功能">#</a> 二、Map 集合的基本功能</h2><p>方法介绍</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>V put(K key,V value)</td><td>添加元素</td></tr><tr><td>V remove(Object key)</td><td>根据键删除键值对元素</td></tr><tr><td>void clear()</td><td>移除所有的键值对元素 &lt;br&gt;</td></tr><tr><td>boolean containsKey(Object key)</td><td>判断集合是否包含指定的键</td></tr><tr><td>boolean containsValue(Object value)</td><td>判断集合是否包含指定的值 &lt;br&gt;</td></tr><tr><td>boolean isEmpty()</td><td>判断集合是否为空</td></tr><tr><td>int size()</td><td>集合的长度，也就是集合中键值对的个数</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">package text;

import java.util.HashMap;
import java.util.Map;

public class Demo &#123;
    public static void main(String[] args) &#123;
        Map&lt;String,String&gt;map=new HashMap&lt;&gt;();
        map.put(&quot;张无忌&quot;,&quot;赵敏&quot;);
        map.put(&quot;郭靖&quot;,&quot;黄蓉&quot;);
        map.put(&quot;杨过&quot;,&quot;小龙女&quot;);
        //V remove(Object key)：根据键删除键值对元素
        System.out.println(map.remove(&quot;郭靖&quot;));
        System.out.println(map.remove(&quot;郭襄&quot;));
        map.put(&quot;郭靖&quot;,&quot;黄蓉&quot;);
        //void clear()：移除所有的键值对元素
        map.clear();
        System.out.println(map);
        map.put(&quot;张无忌&quot;,&quot;赵敏&quot;);
        map.put(&quot;郭靖&quot;,&quot;黄蓉&quot;);
        map.put(&quot;杨过&quot;,&quot;小龙女&quot;);
        //boolean containsKey(Object key)：判断集合是否包含指定的键
        System.out.println(map.containsKey(&quot;郭靖&quot;));
        System.out.println(map.containsKey(&quot;郭襄&quot;));
        //int size()：集合的长度，也就是集合中键值对的个数
        System.out.println(map.size());
        map.clear();
        System.out.println(map.size());
    &#125;

&#125;

</code></pre><p>输出结果</p><p><img data-src="/youdaonote-images/WEBRESOURCE274862d62ffc1bec729ecfffd650c0f3.png" alt=""></p><h2 id="三-map集合的获取功能"><a class="anchor" href="#三-map集合的获取功能">#</a> 三、Map 集合的获取功能</h2><p>方法介绍</p><table><thead><tr><th>方法名</th><th>说明 &lt;br&gt;</th></tr></thead><tbody><tr><td>V get(Object key)</td><td>根据键获取值</td></tr><tr><td>Set keySet()</td><td>获取所有键的集合</td></tr><tr><td>Collection values()</td><td>获取所有值的集合</td></tr><tr><td>Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet()&lt;br&gt;</td><td>获取所有键值对对象的集合</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">package text;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class Demo &#123;
    public static void main(String[] args) &#123;
    //创建集合对象
        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();
    //添加元素
        map.put(&quot;张无忌&quot;, &quot;赵敏&quot;);
        map.put(&quot;郭靖&quot;, &quot;黄蓉&quot;);
        map.put(&quot;杨过&quot;, &quot;小龙女&quot;);
    //V get(Object key):根据键获取值
        System.out.println(map.get(&quot;张无忌&quot;));
        System.out.println(map.get(&quot;张三丰&quot;));
    // Set&lt;K&gt; keySet ():获取所有键的集合
        Set&lt;String&gt; keySet = map.keySet();
        for (String key : keySet) &#123;
            System.out.println(key);
        &#125;
        System.out.println(&quot;-----------------&quot;);
    //Collection&lt;V&gt; values():获取所有值的集合
        Collection&lt;String&gt; values = map.values();
        for (String value : values) &#123;
            System.out.println(value);
        &#125;
    &#125;
&#125;
</code></pre><p>输出结果</p><pre><code class="language-java">赵敏
null
杨过
郭靖
张无忌
-----------------
小龙女
黄蓉
赵敏


</code></pre><h2 id="四-map集合的遍历方式1"><a class="anchor" href="#四-map集合的遍历方式1">#</a> 四、Map 集合的遍历 (方式 1)</h2><p>遍历思路<br>我们刚才存储的元素都是成对出现的，所以我们把 Map 看成是一个夫妻对的集合<br>把所有的丈夫给集中起来<br>遍历丈夫的集合，获取到每一个丈夫<br>根据丈夫去找对应的妻子</p><p>步骤分析<br>获取所有键的集合。用 keySet () 方法实现</p><p>遍历键的集合，获取到每一个键。用增强 for 实现<br>根据键去找值。用 get (Object key) 方法实现</p><p>示例代码</p><pre><code class="language-java">package text;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class Demo &#123;
    public static void main(String[] args) &#123;
//创建集合对象
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
//添加元素
        map.put(&quot;张无忌&quot;, &quot;赵敏&quot;);
        map.put(&quot;郭靖&quot;, &quot;黄蓉&quot;);
        map.put(&quot;杨过&quot;, &quot;小龙女&quot;);
//获取所有键的集合。用keySet()方法实现
        Set&lt;String&gt; keySet = map.keySet();
//遍历键的集合，获取到每一个键。用增强for实现
        for (String key : keySet) &#123;
//根据键去找值。用get(Object key)方法实现
            String value = map.get(key);
            System.out.println(key + &quot;,&quot; + value);
        &#125;
    &#125;

&#125;
</code></pre><p>输出结果</p><p><img data-src="/youdaonote-images/WEBRESOURCE2427854b2d4b4cbb4bb0f38350251112.png" alt=""></p><h2 id="五-map集合的遍历方式2"><a class="anchor" href="#五-map集合的遍历方式2">#</a> 五、Map 集合的遍历 (方式 2)</h2><pre><code>遍历思路
	我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合
		获取所有结婚证的集合
		遍历结婚证的集合，得到每一个结婚证
		根据结婚证获取丈夫和妻子
步骤分析
	获取所有键值对对象的集合
		Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()：获取所有键值对对象的集合
		遍历键值对对象的集合，得到每一个键值对对象
		用增强for实现，得到每一个Map.Entry
	根据键值对对象获取键和值
		用getKey()得到键
		用getValue()得到值
</code></pre><p>示例代码</p><pre><code class="language-java">package text;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class Demo &#123;
    public static void main(String[] args) &#123;
//创建集合对象
        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
//添加元素
        map.put(&quot;张无忌&quot;, &quot;赵敏&quot;);
        map.put(&quot;郭靖&quot;, &quot;黄蓉&quot;);
        map.put(&quot;杨过&quot;, &quot;小龙女&quot;);
        Set&lt;Map.Entry&lt;String, String&gt;&gt; me = map.entrySet();
        for (Map.Entry&lt;String, String&gt; i:me)&#123;
            System.out.println(i.getKey()+&quot;,&quot;+i.getValue());
        &#125;
    &#125;
&#125;

</code></pre><h1 id="collections集合工具类"><a class="anchor" href="#collections集合工具类">#</a> Collections 集合工具类</h1><h2 id="一-collections概述和使用"><a class="anchor" href="#一-collections概述和使用">#</a> 一、Collections 概述和使用</h2><p>Collections 类的作用<br>是针对集合操作的工具类</p><p>Collections 类常用方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static void sort(List list)</td><td>将指定的列表按升序排序</td></tr><tr><td>public static void reverse(List list)</td><td>反转指定列表中元素的顺序</td></tr><tr><td>public static void shuffle(List list)</td><td>使用默认的随机源随机排列指定的列表</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">package text;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;


public class Demo &#123;
    public static void main(String[] args) &#123;
        List&lt;Integer&gt; list=new ArrayList&lt;&gt;();
        list.add(30);
        list.add(20);
        list.add(50);
        list.add(10);
        list.add(40);
        Collections.sort(list);
        System.out.println(list);
        Collections.reverse(list);
        System.out.println(list);
        Collections.shuffle(list);
        System.out.println(list);
    &#125;
&#125;

</code></pre><p>输出样例</p><p><img data-src="/youdaonote-images/WEBRESOURCE7512245275f9a80e503b38d8dbf559a0.png" alt=""></p><h1 id="file类"><a class="anchor" href="#file类">#</a> File 类</h1><h2 id="一-file类概述和构造方法"><a class="anchor" href="#一-file类概述和构造方法">#</a> 一、File 类概述和构造方法</h2><p>File 类介绍<br>它是文件和目录路径名的抽象表示<br>文件和目录是可以通过 File 封装成对象的<br>对于 File 而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，也可以<br>是不存在的。将来是要通过具体的操作把这个路径的内容转换为具体存在的</p><p>File 类的构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>File(String pathname)</td><td>通过将给定的路径名字符串转换为抽象路径名来创建新的 File 实例</td></tr><tr><td>File(String parent, String child)</td><td>从父路径名字符串和子路径名字符串创建新的 File 实例</td></tr><tr><td>File(File parent, String child)</td><td>从父抽象路径名和子路径名字符串创建新的 File 实例</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">import java.io.File;
public class Main &#123;
    public static void main(String[] args) &#123;
        //File(String pathname)：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。
        File f1 = new File(&quot;D:\\itcast\\java.txt&quot;);
        System.out.println(f1);
        //File(String parent, String child)：从父路径名字符串和子路径名字符串创建新的File实例。
        File f2 = new File(&quot;D:\\itcast&quot;, &quot;java.txt&quot;);
        System.out.println(f2);
        //File(File parent, String child)：从父抽象路径名和子路径名字符串创建新的 File实例。
        File f3 = new File(&quot;D:\\itcast&quot;);
        File f4 = new File(f3, &quot;java.txt&quot;);
        System.out.println(f4);
    &#125;
&#125;

</code></pre><h2 id="二-file类创建功能"><a class="anchor" href="#二-file类创建功能">#</a> 二、File 类创建功能</h2><p>方法分类</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public boolean createNewFile()</td><td>当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件 &lt;br&gt;</td></tr><tr><td>public boolean mkdir()</td><td>创建由此抽象路径名命名的目录</td></tr><tr><td>public boolean mkdirs()</td><td>创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">import java.io.File;
import java.io.IOException;

public class Main &#123;
    public static void main (String[] args) throws IOException &#123;
        //在D:\\itcast下创建一个java.txt文件
        File f1 = new File(&quot;D:\\itcast\\java.txt&quot;);
        System.out.println(f1.createNewFile());
        //在D:\\itcast创建一个JavaSE文件夹
        File f2 = new File(&quot;D:\\itcast\\JavaSE&quot;);
        System.out.println(f2.mkdir());
        ////在D:\\itcast创建一个JavaWeb\\HTML文件夹
        File f3 = new File(&quot;D:\\itcast\\JavaWeb\\HTML&quot;);
        System.out.println(f3.mkdirs());
    &#125;
&#125;

</code></pre><p>决定创建的是文件还是文件夹的是使用的方法，和起的名字没有关系。</p><h2 id="三-file类删除功能"><a class="anchor" href="#三-file类删除功能">#</a> 三、File 类删除功能</h2><p>方法分类</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public boolean delete()</td><td>删除由此抽象路径名表示的文件或目录</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">import java.io.File;
import java.io.IOException;

public class Main &#123;
    public static void main (String[] args) throws IOException &#123;
        //在当前模块下创建文件
        File f1 = new File(&quot;java.txt&quot;);
        System.out.println(f1.createNewFile());
        //删除当前目录下的java.txt文件
        System.out.println(f1.delete());
        System.out.println(&quot;-------&quot;);
        //在当前目录下创建itCast文件夹
        File f2 = new File(&quot;itCast&quot;);
        System.out.println(f2.mkdir());
        System.out.println(f2.delete());
        System.out.println(&quot;-------&quot;);
        //在当前目录下创建多级目录javaSE\\javaCode
        File f3 = new File(&quot;javaSE\\javaCode&quot;);
        System.out.println(f3.mkdirs());
        System.out.println(new File(&quot;javaSE&quot;).delete());
    &#125;
&#125;

</code></pre><p>输出结果</p><pre><code>true
true
-------
true
true
-------
true
false

</code></pre><p>使用 delete 只能删除空文件夹和文件，不能删除又包含文件的非空文件夹</p><p>绝对路径和相对路径的区别<br>绝对路径：完整的路径名，不需要任何其他信息就可以定位它所表示的文件。例如：E:\itcast\java.txt<br>相对路径：必须使用取自其他路径名的信息进行解释。例如：myFile\java.txt</p><h2 id="四-file类判断和获取功能"><a class="anchor" href="#四-file类判断和获取功能">#</a> 四、File 类判断和获取功能</h2><p>判断功能</p><table><thead><tr><th>方法名 &lt;br&gt;</th><th>说明</th></tr></thead><tbody><tr><td>public boolean isDirectory()</td><td>测试此抽象路径名表示的 File 是否为目录</td></tr><tr><td>public boolean isFile()</td><td>测试此抽象路径名表示的 File 是否为文件</td></tr><tr><td>public boolean exists()</td><td>测试此抽象路径名表示的 File 是否存在</td></tr></tbody></table><p>获取功能</p><table><thead><tr><th>方法名</th><th>说明 &lt;br&gt;</th></tr></thead><tbody><tr><td>public String getAbsolutePath()</td><td>返回此抽象路径名的绝对路径名字符串</td></tr><tr><td>public String getPath()</td><td>将此抽象路径名转换为路径名字符串</td></tr><tr><td>public String getName()</td><td>返回由此抽象路径名表示的文件或目录的名称</td></tr><tr><td>public String[] list()</td><td>返回此抽象路径名表示的目录中的文件和目录的名称字符串数组 &lt;br&gt;</td></tr><tr><td>public File[] listFiles()</td><td>返回此抽象路径名表示的目录中的文件和目录的 File 对象数组</td></tr></tbody></table><h1 id="递归"><a class="anchor" href="#递归">#</a> 递归</h1><h2 id="一-递归"><a class="anchor" href="#一-递归">#</a> 一、递归</h2><p>递归的介绍<br>以编程的角度来看，递归指的是方法定义中调用方法本身的现象<br>把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解<br>递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算<br>递归的注意事项<br>递归一定要有出口。否则内存溢出<br>递归虽然有出口，但是递归的次数也不宜过多。否则内存溢出、</p><h2 id="二-递归遍历目录"><a class="anchor" href="#二-递归遍历目录">#</a> 二、递归遍历目录</h2><p>实现代码</p><pre><code class="language-java">import java.io.File;
import java.io.IOException;

public class Main &#123;
    public static void main (String[] args) throws IOException &#123;
        File file = new File(&quot;D:\\BaiduNetdiskDownload&quot;);
        getPatch(file);
    &#125;
    public static void getPatch(File f1)&#123;
        File[] files = f1.listFiles();
        if(files!=null)&#123;
            for (File i:files)&#123;
                if(i.isDirectory())
                    getPatch(i);
                else
                    System.out.println(i.getAbsoluteFile());
            &#125;
        &#125;
    &#125;
&#125;

</code></pre><p>运行结果</p><p><img data-src="/youdaonote-images/WEBRESOURCEb927cd9540ec7db2db85029ca7806518.png" alt=""></p><h1 id="io流"><a class="anchor" href="#io流">#</a> IO 流</h1><h2 id="一-io流概述和分类"><a class="anchor" href="#一-io流概述和分类">#</a> 一、 IO 流概述和分类</h2><p>IO 流介绍<br>IO：输入 / 输出 (Input/Output)<br>流：是一种抽象概念，是对数据传输的总称。也就是说数据在设备间的传输称为流，流的本质是数据传输<br>IO 流就是用来处理设备间数据传输问题的。常见的应用：文件复制；文件上传；文件下载<br>IO 流的分类<br>按照数据的流向<br>输入流：读数据<br>输出流：写数据<br>按照数据类型来分<br>字节流<br>字节输入流<br>字节输出流<br>字符流<br>字符输入流<br>字符输出流<br>IO 流的使用场景<br>如果操作的是纯文本文件，优先使用字符流<br>如果操作的是图片、视频、音频等二进制文件。优先使用字节流<br>如果不确定文件类型，优先使用字节流。字节流是万能的流</p><h2 id="二-字节流写数据"><a class="anchor" href="#二-字节流写数据">#</a> 二、字节流写数据</h2><p>字节流抽象基类<br>InputStream：这个抽象类是表示字节输入流的所有类的超类<br>OutputStream：这个抽象类是表示字节输出流的所有类的超类<br>子类名特点：子类名称都是以其父类名作为子类名的后缀<br>字节输出流<br>FileOutputStream (String name)：创建文件输出流以指定的名称写入文件<br>使用字节输出流写数据的步骤<br>创建字节输出流对象 (调用系统功能创建了文件，创建字节输出流对象，让字节输出流对象指向文件)<br>调用字节输出流对象的写数据方法<br>释放资源 (关闭此文件输出流并释放与此流相关联的任何系统资源)<br>示例代码</p><pre><code class="language-java">import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class Main &#123;
    public static void main(String[] args) throws IOException &#123;
        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);
        /*
            做了三件事情：
                A:调用系统功能创建了文件
                B:创建了字节输出流对象
                C:让字节输出流对象指向创建好的文件
        */
        fos.write(97);
        fos.close();
    &#125;
&#125;

</code></pre><h2 id="三-字节流写数据的三种方式"><a class="anchor" href="#三-字节流写数据的三种方式">#</a> 三、字节流写数据的三种方式</h2><p>写数据的方法分类</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void write(int b)</td><td>将指定的字节写入此文件输出流 一次写一个字节数据</td></tr><tr><td>void write(byte[] b)</td><td>将 b.length 字节从指定的字节数组写入此文件输出流 一次写一个字节数组数据</td></tr><tr><td>void write(byte[] b, int off, int len)</td><td>将 len 字节从指定的字节数组开始，从偏移量 off 开始写入此文件输出流 一次写一个字节数组的部分数据</td></tr></tbody></table><p>・	示例代码</p><pre><code class="language-java">import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

public class Main &#123;
    public static void main(String[] args) throws IOException &#123;
        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);
        //void write(int b)
        fos.write(97);
        fos.write(&quot;\r\n-------\r\n&quot;.getBytes());
        //void write(byte[] b)
        byte[]by=&#123;97,98,99,100,101&#125;;
        fos.write(by);
        fos.write(&quot;\r\n-------\r\n&quot;.getBytes());
        //void write(byte[] b, int off, int len)
        fos.write(by,1,3);
        fos.close();
    &#125;
&#125;

</code></pre><h2 id="四-字节流写数据的两个小问题"><a class="anchor" href="#四-字节流写数据的两个小问题">#</a> 四、字节流写数据的两个小问题</h2><p>字节流写数据如何实现换行<br>windows:\r\n<br>linux:\n<br>mac:\r<br>字节流写数据如何实现追加写入<br>public FileOutputStream (String name,boolean append)<br>创建文件输出流以指定的名称写入文件。如果第二个参数为 true ，则字节将写入文件的末尾而不是开头<br>示例代码</p><pre><code class="language-java">import java.io.FileOutputStream;
import java.io.IOException;

public class Main &#123;
    public static void main(String[] args) throws IOException &#123;
        FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;,true);
        for (int i = 0; i &lt; 10; i++) &#123;
            fos.write(&quot;hello\r\n&quot;.getBytes());
        &#125;
        fos.close();
    &#125;
&#125;

</code></pre><h2 id="五-字节流写数据加异常处理"><a class="anchor" href="#五-字节流写数据加异常处理">#</a> 五、字节流写数据加异常处理</h2><p>异常处理格式<br>try-catch-finally</p><pre><code class="language-java">try&#123;

    可能出现异常的代码;

&#125;catch(异常类名 变量名)&#123;

    异常的处理代码;

&#125;finally&#123;

    执行所有清除操作;

&#125;
</code></pre><p>finally 特点<br>被 finally 控制的语句一定会执行，除非 JVM 退出</p><p>示例代码</p><pre><code class="language-java">import java.io.FileOutputStream;
import java.io.IOException;

public class Main &#123;
    public static void main(String[] args) &#123;
//加入finally来实现释放资源
        FileOutputStream fos = null;
        try &#123;
            fos = new FileOutputStream(&quot;myByteStream\\fos.txt&quot;);
            fos.write(&quot;hello&quot;.getBytes());
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            if(fos != null) &#123;
                try &#123;
                    fos.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
    &#125;
&#125;

</code></pre><p>一般直接抛出异常而不使用 try-catch-finally</p><h2 id="六-字节流读数据一次读一个字节数据"><a class="anchor" href="#六-字节流读数据一次读一个字节数据">#</a> 六、字节流读数据 (一次读一个字节数据)</h2><p>字节输入流<br>FileInputStream (String name)：通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文<br>件系统中的路径名 name 命名<br>字节输入流读取数据的步骤<br>创建字节输入流对象<br>调用字节输入流对象的读数据方法<br>释放资源</p><p>示例代码</p><pre><code class="language-java">import java.io.FileInputStream;
import java.io.IOException;

public class Main &#123;
    public static void main(String[] args) throws IOException &#123;
        FileInputStream fis = new FileInputStream(&quot;fos.txt&quot;);
        int by;
        while ((by=fis.read())!=-1) &#123;
            System.out.print((char)by);
        &#125;
        fis.close();
    &#125;
&#125;

</code></pre><h2 id="七-字节流读数据一次读一个字节数组数据"><a class="anchor" href="#七-字节流读数据一次读一个字节数组数据">#</a> 七、字节流读数据 (一次读一个字节数组数据)</h2><p>一次读一个字节数组的方法<br>public int read (byte [] b)：从输入流读取最多 b.length 个字节的数据<br>返回的是读入缓冲区的总字节数，也就是实际的读取字节个数<br>示例代码</p><pre><code class="language-java">import java.io.FileInputStream;
import java.io.IOException;

public class Main &#123;
    public static void main(String[] args) throws IOException &#123;
        FileInputStream fis = new FileInputStream(&quot;fos.txt&quot;);
        byte[] by=new byte[1024];
        int len;
        while ((len=fis.read(by))!=-1) &#123;
            System.out.print(new String(by,0,len));
        &#125;
        fis.close();
        fos.close();
    &#125;
&#125;

</code></pre><h2 id="八-字节缓冲流构造方法"><a class="anchor" href="#八-字节缓冲流构造方法">#</a> 八、字节缓冲流构造方法</h2><p>字节缓冲流介绍</p><p>💎 BufferOutputStream：该类实现缓冲输出流。 通过设置这样的输出流，应用程序可以向底层输出</p><pre><code> 流写入字节，而不必为写入的每个字节导致底层系统的调用
</code></pre><p>💎BufferedInputStream：创建 BufferedInputStream 将创建一个内部缓冲区数组。 当从流中读取或跳</p><pre><code> 过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节
</code></pre><p>构造方法：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>BufferedOutputStream(OutputStream out)</td><td>创建字节缓冲输出流对象</td></tr><tr><td>BufferedInputStream(InputStream in)</td><td>创建字节缓冲输入流对</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">import java.io.*;

public class Main &#123;
    public static void main(String[] args) throws IOException &#123;
        BufferedOutputStream bof = new BufferedOutputStream(new FileOutputStream(&quot;bos.txt&quot;));
        bof.write(&quot;hello\r\n&quot;.getBytes());
        bof.write(&quot;world\r\n&quot;.getBytes());
        bof.close();
        BufferedInputStream bif = new BufferedInputStream(new FileInputStream(&quot;bos.txt&quot;));
        int by;
        while ((by = bif.read()) != -1) &#123;
            System.out.print((char) by);
        &#125;//*/
        System.out.println(&quot;-------&quot;);
        BufferedInputStream bif2 = new BufferedInputStream(new FileInputStream(&quot;bos.txt&quot;));
        byte[] byt = new byte[1024];
        int len;
        while ((len = bif2.read(byt)) != -1) &#123;
            System.out.print(new String(byt, 0, len));
        &#125;
    &#125;
&#125;

</code></pre><h1 id="字符流"><a class="anchor" href="#字符流">#</a> 字符流</h1><h2 id="一-为什么会出现字符流"><a class="anchor" href="#一-为什么会出现字符流">#</a> 一、为什么会出现字符流</h2><p>字符流的介绍</p><p>💎由于字节流操作中文不是特别的方便，所以 Java 就提供字符流</p><p>💎字符流 = 字节流 + 编码表</p><p>中文的字节存储方式</p><p>💎用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行</p><p>字节拼接成中文，如何识别是中文的呢？</p><p>💎汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数</p><h2 id="二-编码表"><a class="anchor" href="#二-编码表">#</a> 二、编码表</h2><p>什么是字符集</p><p>💎是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等 l 计算机要准</p><p>确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码。常见</p><p>字符集有 ASCII 字符集、GBXXX 字符集、Unicode 字符集等</p><p>💎常见的字符集</p><p>🔹ASCII 字符集：</p><p>ASCII：是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括</p><p>控制字符 (回车键、退格、换行键等) 和可显示字符 (英文大小写字符、阿拉伯数字和西文符号) 基本</p><p>的 ASCII 字符集，使用 7 位表示一个字符，共 128 字符。ASCII 的扩展字符集使用 8 位表示一个字</p><p>符，共 256 字符，方便支持欧洲常用字符。是一个系统支持的所有字符的集合，包括各国家文</p><p>字、标点符号、图形符号、数字等</p><p>🔹GBXXX 字符集：</p><p>GBK：最常用的中文码表。是在 GB2312 标准基础上的扩展规范，使用了双字</p><p>节编码方案，共收录了 21003 个汉字，完全兼容 GB2312 标准，同时支持繁体汉字以及日韩汉字等</p><p>🔹Unicode 字符集：</p><p>UTF-8 编码：</p><p>可以用来表示 Unicode 标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用中，</p><p>优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持 UTF-8 编码。它</p><p>使用一至四个字节为每个字符编码</p><p>编码规则：</p><p>128 个 US-ASCII 字符，只需一个字节编码拉丁文等字符，需要二个字节编码大部分常用字（含中</p><p>文），使用三个字节编码其他极少使用的 Unicode 辅助字符，使用四字节编码</p><h2 id="三-字符串中的编码解码问题"><a class="anchor" href="#三-字符串中的编码解码问题">#</a> 三、字符串中的编码解码问题</h2><p>相关方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>byte[] getBytes()</td><td>使用平台的默认字符集将该 String 编码为一系列字节</td></tr><tr><td>byte[] getBytes(String charsetName)</td><td>使用指定的字符集将该 String 编码为一系列字节</td></tr><tr><td>String(byte[] bytes)</td><td>使用平台的默认字符集解码指定的字节数组来创建字符串</td></tr><tr><td>String(byte[] bytes, String charsetName)</td><td>String(byte[] bytes, String charsetName)</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">import java.io.*;
import java.util.Arrays;

public class Main &#123;
    public static void main(String[] args) throws UnsupportedEncodingException &#123;
        String s = &quot;中国&quot;;
        byte[] by = s.getBytes();
        System.out.println(&quot;默认编码:&quot; + Arrays.toString(by));
        String ss = new String(by);
        System.out.println(&quot;默认编码：&quot;+ss);
        by = s.getBytes(&quot;UTF-8&quot;);
        System.out.println(&quot;UTF-8编码:&quot; + Arrays.toString(by));
        ss = new String(by,&quot;UTF-8&quot;);
        System.out.println(&quot;UTF-8编码：&quot;+ss);
        by = s.getBytes(&quot;GBK&quot;);
        System.out.println(&quot;GBK编码:&quot; + Arrays.toString(by));
        ss = new String(by,&quot;GBK&quot;);
        System.out.println(&quot;GBK编码：&quot;+ss);

    &#125;
&#125;

</code></pre><p>输出结果</p><p><img data-src="/youdaonote-images/WEBRESOURCEe3d4a97ac97c95ee092fe3b94dde135d.png" alt=""></p><h2 id="四-字符流中的编码解码问题"><a class="anchor" href="#四-字符流中的编码解码问题">#</a> 四、字符流中的编码解码问题</h2><p>字符流中和编码解码问题相关的两个类</p><p>💎InputStreamReader：是从字节流到字符流的桥梁它读取字节，并使用指定的编码将其解码为字符</p><p>它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集</p><p>💎OutputStreamWriter：是从字符流到字节流的桥梁是从字符流到字节流的桥梁，使用指定的编码将</p><p>写入的字符编码为字节它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默</p><p>认字符集</p><p>构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>InputStreamReader(InputStream in)</td><td>使用默认字符编码创建 InputStreamReader 对象</td></tr><tr><td>InputStreamReader(InputStream in,Stringchatset)</td><td>使用指定的字符编码创建 InputStreamReader 对象</td></tr><tr><td>OutputStreamWriter(OutputStream out)</td><td>使用默认字符编码创建 OutputStreamWriter 对象</td></tr><tr><td>OutputStreamWriter(OutputStream out,Stringcharset)</td><td>使用指定的字符编码创建 OutputStreamWriter 对象</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">import java.io.*;
import java.util.Arrays;

public class Main &#123;
    public static void main(String[] args) throws IOException &#123;
        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;osw.txt&quot;));
        osw.write(&quot;中国&quot;);
        osw.close();
        InputStreamReader isw = new InputStreamReader(new FileInputStream(&quot;osw.txt&quot;));
        int ch;
        while ((ch=isw.read())!=-1)&#123;
            System.out.print((char) ch);
        &#125;
    &#125;
&#125;

</code></pre><p>输出样例</p><p><img data-src="/youdaonote-images/WEBRESOURCE91b42962032d3bec0a3b01247221f7a6.png" alt=""></p><h2 id="五-字符流写数据的5种方式"><a class="anchor" href="#五-字符流写数据的5种方式">#</a> 五、字符流写数据的 5 种方式</h2><p>方法介绍</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void write(int c)</td><td>写一个字符</td></tr><tr><td>void write(char[] cbuf)</td><td>写入一个字符数组</td></tr><tr><td>void write(char[] cbuf, int off, int len)</td><td>写入字符数组的一部分</td></tr><tr><td>void write(String str)</td><td>写一个字符串</td></tr><tr><td>void write(String str, int off, int len)</td><td>写一个字符串的一部分</td></tr></tbody></table><p>刷新和关闭的方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>flush()</td><td>刷新流，之后还可以继续写数据</td></tr><tr><td>close()</td><td>关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">import java.io.*;
import java.util.Arrays;

public class Main &#123;
    public static void main(String[] args) throws IOException &#123;
        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(&quot;osw.txt&quot;));
        osw.write(97);
        osw.write(98);
        osw.write(99);
        osw.write(&quot;\r\n-------\r\n&quot;);
        char[] ch=&#123;'a','b','c','d','e'&#125;;
        osw.write(ch);
        osw.write(&quot;\r\n-------\r\n&quot;);
        osw.write(ch,1,3);
        osw.write(&quot;\r\n-------\r\n&quot;);
        osw.write(&quot;abcde&quot;);
        osw.write(&quot;\r\n-------\r\n&quot;);
        osw.write(&quot;abcde&quot;,1,3);
        osw.close();
    &#125;
&#125;

</code></pre><h2 id="六-字符流读数据的2种方式"><a class="anchor" href="#六-字符流读数据的2种方式">#</a> 六、字符流读数据的 2 种方式</h2><p>方法介绍</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>int read()</td><td>一次读一个字符数据</td></tr><tr><td>int read(char[] cbuf)</td><td>一次读一个字符数组数据</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">import java.io.*;
import java.util.Arrays;

public class Main &#123;
    public static void main(String[] args) throws IOException &#123;
        InputStreamReader osw = new InputStreamReader(new FileInputStream(&quot;osw.txt&quot;));
        int ch;
        while ((ch = osw.read()) != -1) &#123;
            System.out.print((char) ch);
        &#125;
        System.out.println();
        System.out.println(&quot;------我是华丽的分割线------&quot;);
        osw = new InputStreamReader(new FileInputStream(&quot;osw1.txt&quot;));
        char[] chs = new char[1024];
        int len;
        while ((len=osw.read(chs))!=-1)&#123;
            System.out.print(new String(chs,0,len));
        &#125;
    &#125;
&#125;

</code></pre><h2 id="七-便捷流对象"><a class="anchor" href="#七-便捷流对象">#</a> 七、便捷流对象</h2><p>格式</p><p>读入：</p><p>FileReader fr = new FileReader(&quot;myCharStream\ConversionStreamDemo.java&quot;)</p><p>输出：</p><p>FileWriter fw = new FileWriter(&quot;myCharStream\Copy.java&quot;);</p><h2 id="八-字符缓冲流"><a class="anchor" href="#八-字符缓冲流">#</a> 八、字符缓冲流</h2><p>字符缓冲流介绍</p><p>💎BufferedWriter：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写</p><p>入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途</p><p>💎BufferedReader：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指</p><p>定缓冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途</p><p>构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>BufferedWriter(Writer out)</td><td>创建字符缓冲输出流对象</td></tr><tr><td>BufferedReader(Reader in)</td><td>创建字符缓冲输入流对象</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">import java.io.*;
import java.util.Arrays;

public class Main &#123;
    public static void main(String[] args) throws IOException &#123;
        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;put.txt&quot;));
        bw.write(&quot;hello\r\n&quot;);
        bw.write(&quot;world\r\n&quot;);
        BufferedReader br = new BufferedReader(new FileReader(&quot;put.txt&quot;));
        int ch;
        bw.flush();
        while ((ch = br.read()) != -1) &#123;
            System.out.print((char) ch);
        &#125;
        bw.write(&quot;hello\r\n&quot;);
        bw.write(&quot;world\r\n&quot;);
        bw.flush();
        char[] chs = new char[1024];
        int len;
        while ((len = br.read(chs)) != -1) &#123;
            System.out.print(new String(chs, 0, len));
        &#125;
        br.close();
        bw.close();
    &#125;
&#125;

</code></pre><h2 id="九-字符缓冲流特有功能"><a class="anchor" href="#九-字符缓冲流特有功能">#</a> 九、字符缓冲流特有功能</h2><p>方法介绍</p><p>💎BufferedWriter：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void newLine()</td><td>写一行行分隔符，行分隔符字符串由系统属性定义</td></tr></tbody></table><p>💎BufferedReader:</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>String readLine()</td><td>读一行文字。 结果包含行的内容的字符串，不包括任何行终止字符如果流的结尾已经到达，则为 null</td></tr></tbody></table><h2 id="十-io流小结"><a class="anchor" href="#十-io流小结">#</a> 十、IO 流小结</h2><p>字节流</p><p><img data-src="/youdaonote-images/WEBRESOURCE43c52efd412086d633d704447bbb0a05.png" alt=""></p><p>字符流</p><p><img data-src="/youdaonote-images/WEBRESOURCE303c8b7daf8623ec197e7c2441d305cf.png" alt=""></p><h1 id="io特殊操作流"><a class="anchor" href="#io特殊操作流">#</a> IO 特殊操作流</h1><h2 id="一-标准输入流"><a class="anchor" href="#一-标准输入流">#</a> 一、标准输入流</h2><p>System 类中有两个静态的成员变量</p><p>💎public static final InputStream in：标准输入流。通常该流对应于键盘输入或由主机环境或用户指定</p><p>的另一个输入源</p><p>💎public static final PrintStream out：标准输出流。通常该流对应于显示输出或由主机环境或用户指</p><p>定的另一个输出目标</p><p>示例代码</p><pre><code class="language-java">import java.io.*;
import java.util.Arrays;

public class Main &#123;
    public static void main(String[] args) throws IOException &#123;
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s=br.readLine();
        System.out.println(s);
    &#125;
&#125;

</code></pre><h2 id="二-标准输出流"><a class="anchor" href="#二-标准输出流">#</a> 二、标准输出流</h2><pre><code>System类中有两个静态的成员变量
</code></pre><p>💎public static final InputStream in：标准输入流。通常该流对应于键盘输入或由主机环境或用户指定</p><p>的另一个输入源</p><p>💎public static final PrintStream out：标准输出流。通常该流对应于显示输出或由主机环境或用户指</p><p>定的另一个</p><p>输出目标输出语句的本质：是一个标准的输出流</p><p>PrintStream ps = System.out;</p><p>PrintStream 类有的方法，System.out 都可以使用</p><p>示例代码</p><pre><code class="language-java">import java.io.*;
import java.util.Arrays;

public class Main &#123;
    public static void main(String[] args) throws IOException &#123;
        PrintStream ps = System.out;
        ps.println(&quot;hwrgui&quot;);
        ps.println(3245);
    &#125;
&#125;

</code></pre><h2 id="三-字节打印流"><a class="anchor" href="#三-字节打印流">#</a> 三、字节打印流</h2><p>打印流分类</p><p>字节打印流：PrintStream</p><p>字符打印流：PrintWriter</p><p>打印流的特点</p><p>只负责输出数据，不负责读取数据</p><p>永远不会抛出 IOException</p><p>有自己的特有方法</p><p>字节打印流</p><p>PrintStream (String fileName)：使用指定的文件名创建新的打印流</p><p>使用继承父类的方法写数据，查看的时候会转码；使用自己的特有方法写数据，查看的数据原样输出</p><p>可以改变输出语句的目的地</p><p>public static void setOut (PrintStream out)：重新分配 “标准” 输出流</p><p>示例代码</p><pre><code class="language-java">import java.io.*;
import java.util.Arrays;

public class Main &#123;
    public static void main(String[] args) throws IOException &#123;
        PrintStream ps = new PrintStream(&quot;ps.txt&quot;);
        ps.println(&quot;hwrgui&quot;);
        ps.println(3245);
    &#125;
&#125;

</code></pre><h2 id="四-字符打印流"><a class="anchor" href="#四-字符打印流">#</a> 四、字符打印流</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>PrintWriter(Stringfile Name)</td><td>使用指定的文件名创建一个新的 PrintWriter，而不需要自动执行刷新</td></tr><tr><td>PrintWriter(Writerout, booleanauto Flush)</td><td>创建一个新的 PrintWriter out：字符输出流 autoFlush： 一个布尔值，如果为真，则 println ， printf ，或 format 方法将刷新输出缓冲区</td></tr></tbody></table><h2 id="五-对象序列化流"><a class="anchor" href="#五-对象序列化流">#</a> 五、对象序列化流</h2><p>对象序列化介绍</p><p>💎对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象</p><p>💎这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象</p><p>中存储的属性等信息</p><p>💎字节序列写到文件之后，相当于文件中持久保存了一个对象的信息</p><p>💎反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化</p><p>对象序列化流： ObjectOutputStream</p><p>💎将 Java 对象的原始数据类型和图形写入 OutputStream。 可以使用 ObjectInputStream 读取（重构）</p><p>对象。 可以通过使用流的文件来实现对象的持久存储。 如果流是网络套接字流，则可以在另一个主机</p><p>上或另一个进程中重构对象</p><p>构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>ObjectOutputStream(OutputStream out)</td><td>创建一个写入指定的 OutputStream 的 ObjectOutputStream</td></tr></tbody></table><p>序列化对象的方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void writeObject(Object obj)</td><td>将指定的对象写入 ObjectOutputStream</td></tr></tbody></table><p>❗❗注意事项</p><p>一个对象要想被序列化，该对象所属的类必须必须实现 Serializable 接口 Serializable 是一个标记接</p><p>口，实现该接口，不需要重写任何方法</p><h2 id="六-对象反序列化流"><a class="anchor" href="#六-对象反序列化流">#</a> 六、对象反序列化流</h2><p>对象反序列化流： ObjectInputStream</p><p>ObjectInputStream 反序列化先前使用 ObjectOutputStream 编写的原始数据和对象</p><p>构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>ObjectInputStream(InputStream in)</td><td>创建从指定的 InputStream 读取的 ObjectInputStream</td></tr></tbody></table><p>反序列化对象的方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Object readObject()</td><td>从 ObjectInputStream 读取一个对象</td></tr></tbody></table><h2 id="七-serialversionuidtransient"><a class="anchor" href="#七-serialversionuidtransient">#</a> 七、serialVersionUID&amp;transient</h2><p>serialVersionUID</p><p>💎用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题</p><p>呢？</p><p>会出问题，会抛出 InvalidClassException 异常</p><p>💎如果出问题了，如何解决呢？</p><p>重新序列化</p><p>给对象所属的类加一个 serialVersionUID</p><p>private static final long serialVersionUID = 42L;</p><p>transient</p><p>💎如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢？</p><p>给该成员变量加 transient 关键字修饰，该关键字标记的成员变量不参与序列化过程</p><p>示例代码</p><pre><code class="language-java">package text;

import java.io.*;
import java.util.*;

public class Demo &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;
        write();
        read();
    &#125;

    private static void read() throws IOException, ClassNotFoundException &#123;
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;out.txt&quot;));
        Object o = ois.readObject();
        Student s = (Student) o;
        System.out.println(s);
    &#125;

    private static void write() throws IOException &#123;
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;out.txt&quot;));
        Student s = new Student(&quot;一一一&quot;, 23);
        oos.writeObject(s);
        oos.close();
    &#125;
&#125;

</code></pre><h1 id="properties集合"><a class="anchor" href="#properties集合">#</a> Properties 集合</h1><h2 id="一-properties作为map集合的使用"><a class="anchor" href="#一-properties作为map集合的使用">#</a> 一、Properties 作为 Map 集合的使用</h2><p>Properties 介绍</p><p>是一个 Map 体系的集合类</p><p>Properties 可以保存到流中或从流中加载</p><p>属性列表中的每个键及其对应的值都是一个字符串</p><p>示例代码</p><pre><code class="language-java">import java.io.*;
import java.util.Arrays;
import java.util.Properties;
import java.util.Set;

public class Main &#123;
    public static void main(String[] args) &#123;
//创建集合对象
// Properties&lt;String,String&gt; prop = new Properties&lt;String,String&gt;(); //错误
        Properties prop = new Properties();
//存储元素
        prop.put(&quot;itheima001&quot;, &quot;林青霞&quot;);
        prop.put(&quot;itheima002&quot;, &quot;张曼玉&quot;);
        prop.put(&quot;itheima003&quot;, &quot;王祖贤&quot;);
//遍历集合
        Set&lt;Object&gt; keySet = prop.keySet();
        for (Object key : keySet) &#123;
            Object value = prop.get(key);
            System.out.println(key + &quot;,&quot; + value);
        &#125;
    &#125;
&#125;

</code></pre><h2 id="二-properties作为map集合的特有方法"><a class="anchor" href="#二-properties作为map集合的特有方法">#</a> 二、Properties 作为 Map 集合的特有方法</h2><p>特有方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Object setProperty(String key,String value)</td><td>设置集合的键和值，都是 String 类型，底层调用 Hashtable 方法 put</td></tr><tr><td>String getProperty(String key)</td><td>使用此属性列表中指定的键搜索属性</td></tr><tr><td>Set stringPropertyNames()</td><td>从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">import java.io.*;
import java.util.Arrays;
import java.util.Properties;
import java.util.Set;

public class Main &#123;
    public static void main(String[] args) &#123;
//创建集合对象
        Properties prop = new Properties();
//Object setProperty(String key, String value)：设置集合的键和值，都是String类型，底层调用Hashtable方法put
        prop.setProperty(&quot;itheima001&quot;, &quot;林青霞&quot;);
/*
//Object setProperty(String key, String value) &#123;
//return put(key, value);
//&#125;
//Object put(Object key, Object value) &#123;
//return map.put(key, value);
//&#125;
*/
        prop.setProperty(&quot;itheima002&quot;, &quot;张曼玉&quot;);
        prop.setProperty(&quot;itheima003&quot;, &quot;王祖贤&quot;);
//String getProperty(String key)：使用此属性列表中指定的键搜索属性
        System.out.println(prop.getProperty(&quot;itheima001&quot;));
        System.out.println(prop.getProperty(&quot;itheima0011&quot;));
        System.out.println(prop);
//Set&lt;String&gt; stringPropertyNames()：从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串
        Set&lt;String&gt; names = prop.stringPropertyNames();
        for (String key : names) &#123;
// System.out.println(key);
            String value = prop.getProperty(key);
            System.out.println(key + &quot;,&quot; + value);
        &#125;
    &#125;

&#125;

</code></pre><h2 id="三-properties和io流相结合的方法"><a class="anchor" href="#三-properties和io流相结合的方法">#</a> 三、Properties 和 IO 流相结合的方法</h2><p>和 IO 流结合的方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void load(InputStream inStream)</td><td>从输入字节流读取属性列表（键和元素对）</td></tr><tr><td>void load(Reader reader)</td><td>从输入字符流读取属性列表（键和元素对）</td></tr><tr><td>void store(OutputStream out, String comments)</td><td>将此属性列表（键和元素对）写入此 Properties 表中，以适合于使用 load (InputStream) 方法的格式写入输出字节流</td></tr><tr><td>void store(Writer writer,String comments)</td><td>将此属性列表（键和元素对）写入此 Properties 表中，以适合使用 load (Reader) 方法的格式写入输出字符流</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">import java.io.*;
        import java.util.Arrays;
        import java.util.Properties;
        import java.util.Set;

public class Main &#123;
    public static void main(String[] args) throws IOException &#123;
//把集合中的数据保存到文件
        myStore();
//把文件中的数据加载到集合
        myLoad();

    &#125;
    private static void myLoad() throws IOException &#123;
        Properties prop = new Properties();
//void load(Reader reader)：
        FileReader fr = new FileReader(&quot;fw.txt&quot;);
        prop.load(fr);
        fr.close();
        System.out.println(prop);
    &#125;
    private static void myStore() throws IOException &#123;
        Properties prop = new Properties();
        prop.setProperty(&quot;itheima001&quot;,&quot;林青霞&quot;);
        prop.setProperty(&quot;itheima002&quot;,&quot;张曼玉&quot;);
        prop.setProperty(&quot;itheima003&quot;,&quot;王祖贤&quot;);
//void store(Writer writer, String comments)：
        FileWriter fw = new FileWriter(&quot;fw.txt&quot;);
        prop.store(fw,null);
        fw.close();
    &#125;

&#125;

</code></pre><h1 id="实现多线程"><a class="anchor" href="#实现多线程">#</a> 实现多线程</h1><h2 id="一-进程和线程"><a class="anchor" href="#一-进程和线程">#</a> 一、进程和线程</h2><p>💎进程：是正在运行的程序</p><p>是系统进行资源分配和调用的独立单位</p><p>每一个进程都有它自己的内存空间和系统资源</p><p>💎线程：是进程中的单个顺序控制流，是一条执行路径</p><p>单线程：一个进程如果只有一条执行路径，则称为单线程程序</p><p>多线程：一个进程如果有多条执行路径，则称为多线程程序</p><h2 id="二-实现多线程方式一继承thread类"><a class="anchor" href="#二-实现多线程方式一继承thread类">#</a> 二、实现多线程方式一：继承 Thread 类</h2><p>方法介绍</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void run()</td><td>在线程开启后，此方法将被调用执行</td></tr><tr><td>void start()</td><td>使此线程开始执行，Java 虚拟机会调用 run 方法 ()</td></tr></tbody></table><p>实现步骤</p><p>定义一个类 MyThread 继承 Thread 类</p><p>在 MyThread 类中重写 run () 方法</p><p>创建 MyThread 类的对象</p><p>启动线程</p><p>示例代码</p><p>MyThread 类</p><pre><code class="language-java">package text;

public class MyThread extends Thread &#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 100; i++) &#123;
            System.out.println(i);
        &#125;
    &#125;
&#125;

</code></pre><p>测试类</p><pre><code class="language-java">package text;

import java.io.*;
import java.util.*;

public class Demo &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;
        MyThread my1 = new MyThread();
        MyThread my2 = new MyThread();
        my1.start();
        my2.start();
    &#125;
&#125;

</code></pre><p>两个小问题</p><p>💎为什么要重写 run () 方法？</p><p>因为 run () 是用来封装被线程执行的代码</p><p>💎run () 方法和 start () 方法的区别？</p><p>run ()：封装线程执行的代码，直接调用，相当于普通方法的调用</p><p>start ()：启动线程；然后由 JVM 调用此线程的 run () 方法</p><h2 id="三-设置和获取线程名称"><a class="anchor" href="#三-设置和获取线程名称">#</a> 三、设置和获取线程名称</h2><p>方法介绍</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void setName(String name)</td><td>将此线程的名称更改为等于参数 name</td></tr><tr><td>String getName()</td><td>返回此线程的名称</td></tr><tr><td>Thread currentThread(）</td><td>返回对当前正在执行的线程对象的引用</td></tr></tbody></table><p>示例代码</p><p>Thread 类</p><pre><code class="language-java">package text;

public class MyThread extends Thread &#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 100; i++) &#123;
            System.out.println(this.getName()+&quot;,&quot;+i);
        &#125;
    &#125;
&#125;

</code></pre><p>测试类</p><pre><code class="language-java">package text;

import java.io.*;
import java.util.*;

public class Demo &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;
        MyThread my1 = new MyThread();
        MyThread my2 = new MyThread();
        my1.setName(&quot;飞机&quot;);
        my2.setName(&quot;高铁&quot;);
        my1.start();
        my2.start();

        System.out.println(Thread.currentThread().getName());
    &#125;
&#125;

</code></pre><h2 id="四-线程优先级"><a class="anchor" href="#四-线程优先级">#</a> 四、线程优先级</h2><p>线程调度</p><p>💎两种调度方式</p><p>🔹分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片</p><p>🔹抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择</p><p>一个，优先级高的线程获取的 CPU 时间片相对多一些</p><p>💎Java 使用的是抢占式调度模型</p><p>💎随机性</p><p>假如计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到 CPU 时间</p><p>片，也就是使用权，才可以执行指令。所以说多线程程序的执行是有随机性，因为谁抢到 CPU 的</p><p>使用权是不一定的</p><p>优先级相关方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>final int getPriority()</td><td>返回此线程的优先级</td></tr><tr><td>final void setPriority(intnewPriority)</td><td>更改此线程的优先级 线程默认优先级是 5；线程优先级的范围是：1-10</td></tr></tbody></table><p>示例代码</p><p>Thread 类同上</p><pre><code class="language-java">package text;

import java.io.*;
import java.util.*;

public class Demo &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;
        MyThread my1 = new MyThread();
        MyThread my2 = new MyThread();
        my1.setName(&quot;飞机&quot;);
        my2.setName(&quot;高铁&quot;);
        System.out.println(my1.getPriority());
        System.out.println(my2.getPriority());
        my1.setPriority(10);
        my1.start();
        my2.start();
    &#125;
&#125;

</code></pre><p>注意</p><p>并不是优先级高就一定先运行，只是抢占到运行权的几率高</p><h2 id="五-线程控制"><a class="anchor" href="#五-线程控制">#</a> 五、线程控制</h2><p>相关方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>static void sleep(longmillis)</td><td>使当前正在执行的线程停留（暂停执行）指定的毫秒数</td></tr><tr><td>void join()</td><td>等待这个线程死亡</td></tr><tr><td>void setDaemon(booleanon)</td><td>将此线程标记为守护线程，当运行的线程都是守护线程时，Java 虚拟机将退出</td></tr></tbody></table><p>代码演示</p><p>💎sleep 演示</p><p>Thread 类</p><pre><code class="language-java">package text;

public class MyThread extends Thread &#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 100; i++) &#123;
            System.out.println(this.getName()+&quot;,&quot;+i);
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;

</code></pre><p>测试类</p><pre><code class="language-java">package text;

import java.io.*;
import java.util.*;

public class Demo &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;
        MyThread my1 = new MyThread();
        MyThread my2 = new MyThread();
        MyThread my3 = new MyThread();
        my1.setName(&quot;曹操&quot;);
        my2.setName(&quot;刘备&quot;);
        my3.setName(&quot;张飞&quot;);
        my1.start();
        my2.start();
        my3.start();
    &#125;
&#125;

</code></pre><p>💎join 演示</p><p>Thread 类</p><pre><code class="language-java">package text;

public class MyThread extends Thread &#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 100; i++) &#123;
            System.out.println(this.getName()+&quot;,&quot;+i);
        &#125;
    &#125;
&#125;

</code></pre><p>测试类</p><pre><code class="language-java">package text;

import java.io.*;
import java.util.*;

public class Demo &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;
        MyThread my1 = new MyThread();
        MyThread my2 = new MyThread();
        MyThread my3 = new MyThread();
        my1.setName(&quot;康熙&quot;);
        my2.setName(&quot;四阿哥&quot;);
        my3.setName(&quot;八阿哥&quot;);
        my1.start();
        try &#123;
            my1.join();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        my2.start();
        my3.start();
    &#125;
&#125;

</code></pre><p>💎Daemon 演示</p><p>Thread 类</p><pre><code class="language-java">package text;

public class MyThread extends Thread &#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 100; i++) &#123;
            System.out.println(this.getName()+&quot;,&quot;+i);
        &#125;
    &#125;
&#125;

</code></pre><p>测试类</p><pre><code class="language-java">package text;

import java.io.*;
import java.util.*;

public class Demo &#123;
    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;
        MyThread my1 = new MyThread();
        MyThread my2 = new MyThread();
        my1.setName(&quot;关羽&quot;);
        my2.setName(&quot;张飞&quot;);
        //设置主线程为刘备
        Thread.currentThread().setName(&quot;刘备&quot;);
        my1.setDaemon(true);
        my2.setDaemon(true);
        my1.start();
        my2.start();
        for (int i = 0; i &lt; 10; i++) &#123;
            System.out.println(Thread.currentThread().getName()+&quot;,&quot;+i);
        &#125;
    &#125;
&#125;

</code></pre><h2 id="六-线程的生命周期"><a class="anchor" href="#六-线程的生命周期">#</a> 六、线程的生命周期</h2><p>线程一共有五种状态，线程在各种状态之间转换。</p><p><img data-src="/youdaonote-images/WEBRESOURCE0636647efab2685fc431423dbf15d9ce.png" alt=""></p><h2 id="七-实现多线程方式二实现runnable接口"><a class="anchor" href="#七-实现多线程方式二实现runnable接口">#</a> 七、实现多线程方式二：实现 Runnable 接口</h2><p>Thread 构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Thread(Runnable target)</td><td>分配一个新的 Thread 对象</td></tr><tr><td>Thread(Runnable target, String name)</td><td>分配一个新的 Thread 对象</td></tr></tbody></table><p>实现步骤</p><p>定义一个类 MyRunnable 实现 Runnable 接口</p><p>在 MyRunnable 类中重写 run () 方法</p><p>创建 MyRunnable 类的对象</p><p>创建 Thread 类的对象，把 MyRunnable 对象作为构造方法的参数</p><p>启动线程</p><p>示例代码</p><p>Runnable 类</p><pre><code class="language-java">package text;

public class MyRunnable implements Runnable &#123;
    @Override
    public void run() &#123;
        for (int i = 0; i &lt; 100; i++) &#123;
            System.out.println(Thread.currentThread().getName() + &quot;,&quot; + i);
        &#125;
    &#125;
&#125;
</code></pre><p>测试类</p><pre><code class="language-java">package text;

import java.io.*;
import java.util.*;

public class Demo &#123;
    public static void main(String[] args) &#123;
        MyRunnable mr = new MyRunnable();
        Thread t1 = new Thread(mr, &quot;飞机&quot;);
        Thread t2 = new Thread(mr, &quot;高铁&quot;);
        t1.start();
        t2.start();
    &#125;
&#125;

</code></pre><p>多线程的实现方案有两种</p><p>💎继承 Thread 类</p><p>💎实现 Runnable 接口</p><p>相比继承 Thread 类，实现 Runnable 接口的好处</p><p>💎避免了 Java 单继承的局限性</p><p>💎适合多个相同程序的代码去处理同一个资源的情况，把线程和程序的代码、数据有效分离，较好的</p><p>体现了面向对象的设计思想</p><h1 id="线程同步"><a class="anchor" href="#线程同步">#</a> 线程同步</h1><h2 id="一-卖票"><a class="anchor" href="#一-卖票">#</a> 一、卖票</h2><p>案例需求</p><p>🔹某电影院目前正在上映国产大片，共有 100 张票，而它有 3 个窗口卖票，请设计一个程序模拟该电影</p><p>院卖票</p><p>实现步骤</p><p>🔹定义一个类 SellTicket 实现 Runnable 接口，里面定义一个成员变量：private int tickets = 100;</p><p>🔹在 SellTicket 类中重写 run () 方法实现卖票，代码步骤如下</p><p>🔹判断票数大于 0，就卖票，并告知是哪个窗口卖的</p><p>🔹卖了票之后，总票数要减 1</p><p>🔹票没有了，也可能有人来问，所以这里用死循环让卖票的动作一直执行</p><p>🔹定义一个测试类 SellTicketDemo，里面有 main 方法，代码步骤如下</p><p>🔹创建 SellTicket 类的对象创建三个 Thread 类的对象，把 SellTicket 对象作为构造方法的参数，并给出</p><p>对应的窗口名</p><p>🔹称启动线程</p><p>代码实现</p><p>Runnable 类</p><pre><code class="language-java">package text;

public class MyRunnable implements Runnable &#123;
    private int ticket=100;
    @Override
    public void run() &#123;
        while (true)&#123;
            if(ticket&gt;0)&#123;
                System.out.println(Thread.currentThread().getName()+&quot;正在出售第&quot;+(101-ticket)+&quot;张票&quot;);
                ticket--;
            &#125;
        &#125;
    &#125;
&#125;

</code></pre><p>测试类</p><pre><code class="language-java">package text;

public class Demo &#123;
    public static void main(String[] args) &#123;
        MyRunnable mr = new MyRunnable();
        Thread t1 = new Thread(mr, &quot;窗口1&quot;);
        Thread t2 = new Thread(mr, &quot;窗口2&quot;);
        Thread t3 = new Thread(mr, &quot;窗口3&quot;);
        t1.start();
        t2.start();
        t3.start();
    &#125;
&#125;

</code></pre><p>输出结果</p><p><img data-src="/youdaonote-images/WEBRESOURCE6effbc3d84d44bd49f35594da6c62956.png" alt=""></p><h2 id="二-卖票案例的问题"><a class="anchor" href="#二-卖票案例的问题">#</a> 二、卖票案例的问题</h2><p>卖票出现了问题</p><p>💎相同的票出现了多次</p><p>💎出现了负数的</p><p>票问题产生原因</p><p>💎线程执行的随机性导致的</p><h2 id="三-同步代码块解决数据安全问题"><a class="anchor" href="#三-同步代码块解决数据安全问题">#</a> 三、同步代码块解决数据安全问题</h2><p>安全问题出现的条件</p><p>💎是多线程环境</p><p>💎有共享数据</p><p>💎有多条语句操作共享数据</p><p>如何解决多线程安全问题呢？</p><p>💎基本思想：让程序没有安全问题的环境</p><p>怎么实现呢？</p><p>💎把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可</p><p>💎Java 提供了同步代码块的方式来解决</p><p>同步代码块格式：</p><pre><code class="language-java">synchronized(任意对象) &#123;多条语句操作共享数据的代码&#125;
</code></pre><p>💎synchronized (任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁</p><p>同步的好处和弊端</p><p>💎好处：解决了多线程的数据安全问题</p><p>💎弊端：当线程很多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程</p><p>序的运行效率</p><p>示例代码</p><p>Runnable 类</p><pre><code class="language-java">package text;

public class MyRunnable implements Runnable &#123;
    private int ticket=100;
    @Override
    public void run() &#123;
        while (true)&#123;
            synchronized (this)&#123;
                if (ticket &gt; 0) &#123;
                    try &#123;
                        Thread.sleep(100);
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                    System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + (101 - ticket) + &quot;张票&quot;);
                    ticket--;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;

</code></pre><p>测试类</p><pre><code class="language-java">package text;

public class Demo &#123;
    public static void main(String[] args) &#123;
        MyRunnable mr = new MyRunnable();
        Thread t1 = new Thread(mr, &quot;窗口1&quot;);
        Thread t2 = new Thread(mr, &quot;窗口2&quot;);
        Thread t3 = new Thread(mr, &quot;窗口3&quot;);
        t1.start();
        t2.start();
        t3.start();
    &#125;
&#125;

</code></pre><h2 id="四-同步方法解决数据安全问题"><a class="anchor" href="#四-同步方法解决数据安全问题">#</a> 四、同步方法解决数据安全问题</h2><p>同步方法的格式</p><p>同步方法：就是把 synchronized 关键字加到方法上</p><pre><code class="language-java">修饰符 synchronized 返回值类型 方法名(方法参数) &#123;方法体；&#125;
</code></pre><p>同步方法的锁对象是什么呢？</p><p>this</p><p>静态同步方法</p><p>同步静态方法：就是把 synchronized 关键字加到静态方法上</p><pre><code class="language-java">修饰符 static synchronized 返回值类型 方法名(方法参数) &#123;方法体；&#125;
</code></pre><p>同步静态方法的锁对象是什么呢？</p><p>类名.class</p><h2 id="五-线程安全的类"><a class="anchor" href="#五-线程安全的类">#</a> 五、线程安全的类</h2><p>StringBuffer</p><p>💎线程安全，可变的字符序列</p><p>💎从版本 JDK 5 开始，被 StringBuilder 替代。 通常应该使用 StringBuilder 类，因为它支持所有相同的</p><p>操作，但它更快，因为它不执行同步</p><p>Vector</p><p>💎从 Java 2 平台 v1.2 开始，该类改进了 List 接口，使其成为 Java Collections Framework 的成员。 与</p><p>新的集合实现不同， Vector 被同步。 如果不需要线程安全的实现，建议使用 ArrayList 代替 Vector</p><p>Hashtable</p><p>💎该类实现了一个哈希表，它将键映射到值。 任何非 null 对象都可以用作键或者值</p><p>💎从 Java 2 平台 v1.2 开始，该类进行了改进，实现了 Map 接口，使其成为 Java Collections</p><p>Framework 的成员。 与新的集合实现不同， Hashtable 被同步。 如果不需要线程安全的实现，建议使</p><p>用 HashMap 代替 Hashtable</p><h2 id="六-lock锁"><a class="anchor" href="#六-lock锁">#</a> 六、Lock 锁</h2><p>虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪</p><p>里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5 以后提供了一个新的锁对象 Lock</p><p>Lock 是接口不能直接实例化，这里采用它的实现类 ReentrantLock 来实例化</p><p>ReentrantLock 构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>ReentrantLock()</td><td>创建一个 ReentrantLock 的实例</td></tr></tbody></table><p>加锁解锁方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void lock()</td><td>获得锁</td></tr><tr><td>void unlock()</td><td>void unlock()</td></tr></tbody></table><p>代码演示</p><p>Runnable 类</p><pre><code class="language-java">package text;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class MyRunnable implements Runnable &#123;
    private int ticket = 100;
    private Lock lock=new ReentrantLock();
    @Override
    public void run() &#123;
        while (true) &#123;
            lock.lock();
            if (ticket &gt; 0) &#123;
                try &#123;
                    Thread.sleep(100);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                System.out.println(Thread.currentThread().getName() + &quot;正在出售第&quot; + (101 - ticket) + &quot;张票&quot;);
                ticket--;
            &#125;
            lock.unlock();
        &#125;
    &#125;
&#125;

</code></pre><p>测试类</p><pre><code class="language-java">package text;

public class Demo &#123;
    public static void main(String[] args) &#123;
        MyRunnable mr = new MyRunnable();
        Thread t1 = new Thread(mr, &quot;窗口1&quot;);
        Thread t2 = new Thread(mr, &quot;窗口2&quot;);
        Thread t3 = new Thread(mr, &quot;窗口3&quot;);
        t1.start();
        t2.start();
        t3.start();
    &#125;
&#125;

</code></pre><h1 id="生产者消费者"><a class="anchor" href="#生产者消费者">#</a> 生产者消费者</h1><h2 id="一-生产者和消费者模式概述"><a class="anchor" href="#一-生产者和消费者模式概述">#</a> 一、生产者和消费者模式概述</h2><p>概述</p><p>生产者消费者模式是一个十分经典的多线程协作的模式，弄懂生产者消费者问题能够让我们对多线程</p><p>编程的理解更加深刻。所谓生产者消费者问题，实际上主要是包含了两类线程：一类是生产者线程用</p><p>于生产数据一类是消费者线程用于消费数据为了解耦生产者和消费者的关系，通常会采用共享的数据</p><p>区域，就像是一个仓库生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为消</p><p>费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为</p><p><img data-src="/youdaonote-images/WEBRESOURCE8c84bad1816d95e1cc38df3a062aaefd.png" alt=""></p><p>Object 类的等待和唤醒方法</p><table><thead><tr><th>方法名</th><th>方法名</th></tr></thead><tbody><tr><td>void wait()</td><td>导致当前线程等待，直到另一个线程调用该对象的 notify () 方法或 notifyAll () 方法</td></tr><tr><td>void notify()</td><td>唤醒正在等待对象监视器的单个线程</td></tr><tr><td>void notifyAll()</td><td>唤醒正在等待对象监视器的所有线程</td></tr></tbody></table><h2 id="二-生产者和消费者案例"><a class="anchor" href="#二-生产者和消费者案例">#</a> 二、生产者和消费者案例</h2><p>案例需求</p><p>生产者消费者案例中包含的类：</p><p>奶箱类 (Box)：定义一个成员变量，表示第 x 瓶奶，提供存储牛奶和获取牛奶的操作</p><p>生产者类 (Producer)：实现 Runnable 接口，重写 run () 方法，调用存储牛奶的操作</p><p>消费者类 (Customer)：实现 Runnable 接口，重写 run () 方法，调用获取牛奶的操作</p><p>测试类 (BoxDemo)：里面有 main 方法，main 方法中的代码步骤如下</p><p>①创建奶箱对象，这是共享数据区域</p><p>②创建消费者创建生产者对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用存储</p><p>牛奶的操作</p><p>③对象，把奶箱对象作为构造方法参数传递，因为在这个类中要调用获取牛奶的操作</p><p>④创建 2 个线程对象，分别把生产者对象和消费者对象作为构造方法参数传递</p><p>⑤启动线程</p><p>示例代码</p><p>box 类</p><pre><code class="language-java">package text;

public class Box &#123;
    private int milk;
    private boolean flag=false;
    public synchronized void put(int milk)&#123;
        if(flag)&#123;
            try &#123;
                wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        this.milk=milk;
        System.out.println(&quot;送奶工将第&quot; + this.milk + &quot;瓶奶放入奶箱&quot;);
        flag=true;
        notifyAll();
    &#125;
    public synchronized void get()&#123;
        if(!flag)&#123;
            try &#123;
                wait();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        System.out.println(&quot;用户拿到第&quot; + this.milk + &quot;瓶奶&quot;);
        flag=false;
        notifyAll();
    &#125;
&#125;

</code></pre><p>producer 类</p><pre><code class="language-java">package text;

public class Producer implements Runnable&#123;
    Box b;

    public Producer(Box b) &#123;
        this.b = b;
    &#125;

    public Producer() &#123;
    &#125;

    @Override
    public void run() &#123;
        for (int i = 1; i &lt; 80; i++) &#123;
            b.put(i);
        &#125;
    &#125;
&#125;

</code></pre><p>costumer 类</p><pre><code class="language-java">package text;

public class Customer implements Runnable&#123;
    Box b;

    public Customer() &#123;
    &#125;

    public Customer(Box b) &#123;
        this.b = b;
    &#125;

    @Override
    public void run() &#123;
        while (true)&#123;
            b.get();
        &#125;
    &#125;
&#125;

</code></pre><p>测试类</p><pre><code class="language-java">package text;

public class Demo &#123;
    public static void main(String[] args) &#123;
        Box box = new Box();
        Producer producer = new Producer(box);
        Customer customer = new Customer(box);
        Thread t1 = new Thread(producer);
        Thread t2 = new Thread(customer);
        t1.start();
        t2.start();
    &#125;
&#125;

</code></pre><h1 id="网络编程入门"><a class="anchor" href="#网络编程入门">#</a> 网络编程入门</h1><h2 id="一-网络编程概述"><a class="anchor" href="#一-网络编程概述">#</a> 一、网络编程概述</h2><p>计算机网络</p><p>是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操</p><p>作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统</p><p>网络编程</p><p>在网络通信协议下，实现网络互连的不同计算机上运行的程序间可以进行数据交换</p><h2 id="二-网络编程三要素"><a class="anchor" href="#二-网络编程三要素">#</a> 二、网络编程三要素</h2><p>IP 地址</p><p>要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要</p><p>接收数据的计算机和识别发送的计算机，而 IP 地址就是这个标识号。也就是设备的标识</p><p>端口</p><p>网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，</p><p>如何区分这些应用程序呢？如果说 IP 地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设</p><p>备中的应用程序了。也就是应用程序的标识</p><p>协议</p><p>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵</p><p>守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接</p><p>和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通</p><p>信双方必须同时遵守才能完成数据交换。常见的协议有 UDP 协议和 TCP 协议</p><h2 id="三-ip地址"><a class="anchor" href="#三-ip地址">#</a> 三、IP 地址</h2><p>IP 地址：是网络中设备的唯一标识</p><p>IP 地址分为两大类</p><p>💎IPv4：是给每个连接在网络上的主机分配一个 32bit 地址。按照 TCP/IP 规定，IP 地址用二进制来表</p><p>示，每个 IP 地址长 32bit，也就是 4 个字节。例如一个采用二进制形式的 IP 地址是 “11000000</p><p>1010100000000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP 地址经常</p><p>被写成十进制的形式，中间使用符号 “.” 分隔不同的字节。于是，上面的 IP 地址可以表示为</p><p>“192.168.1.66”。IP 地址的这种表示法叫做 “点分十进制表示法”，这显然比 1 和 0 容易记忆得多</p><p>💎IPv6：由于互联网的蓬勃发展，IP 地址的需求量愈来愈大，但是网络地址资源有限，使得 IP 的分配</p><p>越发紧张。为了扩大地址空间，通过 IPv6 重新定义地址空间，采用 128 位地址长度，每 16 个字节一</p><p>组，分成 8 组十六进制数，这样就解决了网络地址资源数量不够的问题</p><p>DOS 常用命令：</p><p>💎ipconfig：查看本机 IP 地址</p><p>💎ping IP 地址：检查网络是否连通</p><p>特殊 IP 地址：</p><p>127.0.0.1：是回送地址，可以代表本机地址，一般用来测试使用</p><h2 id="四-inetaddress"><a class="anchor" href="#四-inetaddress">#</a> 四、InetAddress</h2><p>InetAddress：此类表示 Internet 协议（IP）地址</p><p>相关方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>static InetAddress getByName(String host)</td><td>确定主机名称的 IP 地址。主机名称可以是机器名称，也可以是 IP 地址</td></tr><tr><td>String getHostName()</td><td>获取此 IP 地址的主机名</td></tr><tr><td>String getHostAddress()</td><td>返回文本显示中的 IP 地址字符串</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">package text;

import java.net.InetAddress;
import java.net.UnknownHostException;

public class Demo &#123;
    public static void main(String[] args) throws UnknownHostException &#123;
        InetAddress ia = InetAddress.getByName(&quot;LAPTOP-J66IF2GE&quot;);
        System.out.println(ia.getHostAddress());
        System.out.println(ia.getHostName());
        System.out.println(&quot;--------------&quot;);
        InetAddress ia1 = InetAddress.getByName(&quot;192.168.3.21&quot;);
        System.out.println(ia1.getHostAddress());
        System.out.println(ia1.getHostName());
    &#125;
&#125;

</code></pre><p>输出结果</p><p><img data-src="/youdaonote-images/WEBRESOURCE6b829f13c2aa043f55fc94f951c62f32.png" alt=""></p><h2 id="五-端口和协议"><a class="anchor" href="#五-端口和协议">#</a> 五、端口和协议</h2><p>端口</p><p>💎设备上应用程序的唯一标识</p><p>端口号</p><p>💎用两个字节表示的整数，它的取值范围是 0<sub>65535。其中，0</sub>1023 之间的端口号用于一些知名的</p><p>网络服务和应用，普通的应用程序需要使用 1024 以上的端口号。如果端口号被另外一个服务或应用所</p><p>占用，会导致当前程序启动失败</p><p>协议</p><p>💎计算机网络中，连接和通信的规则被称为网络通信协议</p><p>UDP 协议</p><p>💎用户数据报协议 (User Datagram Protocol)</p><p>💎UDP 是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当</p><p>一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接</p><p>收端在收到数据时，也不会向发送端反馈是否收到数据。</p><p>💎由于使用 UDP 协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输</p><p>💎例如视频会议通常采用 UDP 协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产</p><p>生太大影响。但是在使用 UDP 协议传送数据时，由于 UDP 的面向无连接性，不能保证数据的完整性，</p><p>因此在传输重要数据时不建议使用 UDP 协议</p><p>TCP 协议</p><p>💎传输控制协议 (Transmission Control Protocol)</p><p>💎TCP 协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输</p><p>数据，它提供了两台计算机之间可靠无差错的数据传输。在 TCP 连接中必须要明确客户端与服务器</p><p>端，由客户端向服务端发出连接请求，每次连接的创建都需要经过 “三次握手”</p><p>💎三次握手：TCP 协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的</p><p>可靠第一次握手，客户端向服务器端发出连接请求，等待服务器确认第二次握手，服务器端向客户端</p><p>回送一个响应，通知客户端收到了连接请求第三次握手，客户端再次向服务器端发送确认信息，确认</p><p>连接</p><p>💎完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特</p><p>性，TCP 协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等</p><h1 id="udp通信程序"><a class="anchor" href="#udp通信程序">#</a> UDP 通信程序</h1><h2 id="一-udp发送数据"><a class="anchor" href="#一-udp发送数据">#</a> 一、UDP 发送数据</h2><p>Java 中的 UDP 通信</p><p>💎UDP 协议是一种不可靠的网络协议，它在通信的两端各建立一个 Socket 对象，但是这两个 Socket</p><p>只是发送，接收数据的对象，因此对于基于 UDP 协议的通信双方而言，没有所谓的客户端和服务器的</p><p>概念</p><p>💎Java 提供了 DatagramSocket 类作为基于 UDP 协议的 Socket</p><p>构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>DatagramSocket()</td><td>创建数据报套接字并将其绑定到本机地址上的任何可用端口</td></tr><tr><td>DatagramPacket(byte[] buf,int len,InetAddressadd,int port)</td><td>创建数据包，发送长度为 len 的数据包到指定主机的指定端口</td></tr></tbody></table><p>相关方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void send(DatagramPacket p)</td><td>发送数据报包</td></tr><tr><td>void close()</td><td>关闭数据报套接字</td></tr><tr><td>void receive(DatagramPacket p)</td><td>从此套接字接受数据报包</td></tr></tbody></table><p>发送数据的步骤</p><p>💎创建发送端的 Socket 对象 (DatagramSocket)</p><p>💎创建数据，并把数据打包</p><p>💎调用 DatagramSocket 对象的方法发送数据</p><p>💎关闭发送端</p><p>示例代码</p><pre><code class="language-java">package text;

import java.io.IOException;
import java.net.*;

public class Demo &#123;
    public static void main(String[] args) throws IOException &#123;
        DatagramSocket ds = new DatagramSocket();
        byte[]message=&quot;hello,UDP,我来了&quot;.getBytes();
        DatagramPacket dp = new DatagramPacket(message, message.length, InetAddress.getByName(&quot;192.168.3.21&quot;), 10000);
        ds.send(dp);
        ds.close();
    &#125;
&#125;

</code></pre><h2 id="二-udp接收数据"><a class="anchor" href="#二-udp接收数据">#</a> 二、UDP 接收数据</h2><p>接收数据的步骤</p><p>💎创建接收端的 Socket 对象 (DatagramSocket)</p><p>💎创建一个数据包，用于接收数据</p><p>💎调用 DatagramSocket 对象的方法接收数据</p><p>💎解析数据包，并把数据在控制台显示</p><p>💎关闭接收端</p><p>构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>DatagramPacket(byte[] buf, int len)</td><td>创建一个 DatagramPacket 用于接收长度为 len 的数据包</td></tr></tbody></table><p>相关方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>byte[] getData()</td><td>返回数据缓冲区</td></tr><tr><td>int getLength()</td><td>返回要发送的数据的长度或接收的数据的长度</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">package text;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;

public class Receive &#123;
    public static void main(String[] args) throws IOException &#123;
        DatagramSocket ds = new DatagramSocket(10086);
        byte[] by = new byte[1024];
        DatagramPacket dp = new DatagramPacket(by, by.length);
        ds.receive(dp);
        System.out.println(&quot;数据是：&quot;+ new String(dp.getData(),0,dp.getLength()));
        ds.close();
    &#125;
&#125;

</code></pre><h1 id="tcp通信程序"><a class="anchor" href="#tcp通信程序">#</a> TCP 通信程序</h1><h2 id="一-tcp发送数据"><a class="anchor" href="#一-tcp发送数据">#</a> 一、TCP 发送数据</h2><p>Java 中的 TCP 通信</p><p>💎Java 对基于 TCP 协议的的网络提供了良好的封装，使用 Socket 对象来代表两端的通信端口，并通过</p><p>Socket 产生 IO 流来进行网络通信。</p><p>💎Java 为客户端提供了 Socket 类，为服务器端提供了 ServerSocket 类</p><p>构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Socket(InetAddress address,int port)</td><td>创建流套接字并将其连接到指定 IP 指定端口号</td></tr><tr><td>Socket(String host, int port)</td><td>创建流套接字并将其连接到指定主机上的指定端口号</td></tr></tbody></table><p>相关方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>InputStream getInputStream()</td><td>返回此套接字的输入流</td></tr><tr><td>OutputStream getOutputStream()</td><td>返回此套接字的输出流</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">package text;

import java.io.IOException;
import java.io.OutputStream;
import java.net.*;

public class Demo &#123;
    public static void main(String[] args) throws IOException &#123;
        Socket s = new Socket(&quot;192.168.3.21&quot;, 10000);
        OutputStream os = s.getOutputStream();
        os.write(&quot;hello,TCP,我来了&quot;.getBytes());
        s.close();
    &#125;
&#125;

</code></pre><h2 id="二-tcp接收数据"><a class="anchor" href="#二-tcp接收数据">#</a> 二、TCP 接收数据</h2><p>构造方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>ServletSocket(int port)</td><td>创建绑定到指定端口的服务器套接字</td></tr></tbody></table><p>相关方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Socket accept()</td><td>监听要连接到此的套接字并接受它</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">package text;

import java.io.IOException;
import java.io.OutputStream;
import java.net.*;

public class Demo &#123;
    public static void main(String[] args) throws IOException &#123;
        Socket s = new Socket(&quot;192.168.3.21&quot;, 12345);
        OutputStream os = s.getOutputStream();
        os.write(&quot;hello,TCP,我来了&quot;.getBytes());
        s.close();
    &#125;
&#125;

</code></pre><h1 id="lambda表达式"><a class="anchor" href="#lambda表达式">#</a> Lambda 表达式</h1><h2 id="一-体验lambda表达式"><a class="anchor" href="#一-体验lambda表达式">#</a> 一、体验 Lambda 表达式</h2><p>案例需求</p><p>启动一个线程，在控制台输出一句话：多线程程序启动了</p><p>实现方式一</p><p>实现步骤</p><p>🔹定义一个类 MyRunnable 实现 Runnable 接口，重写 run () 方法</p><p>🔹创建 MyRunnable 类的对象</p><p>🔹创建 Thread 类的对象，把 MyRunnable 的对象作为构造参数传递</p><p>🔹启动线程</p><p>实现方式二</p><p>匿名内部类的方式改进</p><p>实现方式三</p><p>Lambda 表达式的方式改进代码演示</p><p>示例代码</p><pre><code class="language-java">public class Main &#123;
    public static void main(String[] args) &#123;
        MyRunnable my = new MyRunnable();
        Thread t = new Thread(my);
        t.start();
        //方式二
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;多线程程序启动了&quot;);
            &#125;
        &#125;).start();
        //方式三
        new Thread(()-&gt;&#123;
            System.out.println(&quot;多线程程序启动了&quot;);
        &#125;).start();;
    &#125;
&#125;
class MyRunnable implements Runnable&#123;
    @Override
    public void run() &#123;
        System.out.println(&quot;多线程程序启动了&quot;);
    &#125;
&#125;
</code></pre><p>函数式编程思想概述</p><p>函数式思想则尽量忽略面向对象的复杂语法：“强调做什么，而不是以什么形式去做”</p><p>而我们要学习的 Lambda 表达式就是函数式思想的体现</p><h2 id="二-lambda表达式的标准格式"><a class="anchor" href="#二-lambda表达式的标准格式">#</a> 二、Lambda 表达式的标准格式</h2><p>格式：</p><p 代码块="">(形式参数) -&gt;</p><p>🔹形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可</p><p>🔹-&gt;：由英文中画线和大于符号组成，固定写法。代表指向动作</p><p>🔹代码块：是我们具体要做的事情，也就是以前我们写的方法体内容</p><p>组成 Lambda 表达式的三要素：</p><p>形式参数，箭头，代码块</p><h2 id="三-lambda表达式练习1"><a class="anchor" href="#三-lambda表达式练习1">#</a> 三、Lambda 表达式练习 1</h2><p>Lambda 表达式的使用前提</p><p>💎有一个接口</p><p>💎接口中有且仅有一个抽象方法</p><p>练习描述</p><p>💎无参无返回值抽象方法的练习</p><p>操作步骤</p><p>💎定义一个接口 (Eatable)，里面定义一个抽象方法：void eat ();</p><p>💎定义一个测试类 (EatableDemo)，在测试类中提供两个方法</p><p>🔹一个方法是：useEatable (Eatable e)</p><p>🔹一个方法是主方法，在主方法中调用 useEatable 方法示例代码</p><p>示例代码</p><pre><code class="language-java">public class Main &#123;
    public static void main(String[] args) &#123;
        //方式一
        EatableImpl e = new EatableImpl();
        useEatable(e);
        //方式二
        useEatable(new Eatable() &#123;
            @Override
            public void eat() &#123;
                System.out.println(&quot;一天一苹果，医生远离我&quot;);
            &#125;
        &#125;);
        //方式三
        useEatable(()-&gt;&#123;
            System.out.println(&quot;一天一苹果，医生远离我&quot;);
        &#125;);
    &#125;
    public static void useEatable(Eatable e)&#123;
        e.eat();
    &#125;
&#125;

interface Eatable &#123;
    void eat();
&#125;
class EatableImpl implements Eatable&#123;
    @Override
    public void eat() &#123;
        System.out.println(&quot;一天一苹果，医生远离我&quot;);
    &#125;
&#125;


</code></pre><h2 id="四-lambda表达式练习2"><a class="anchor" href="#四-lambda表达式练习2">#</a> 四、Lambda 表达式练习 2</h2><p>练习描述</p><p>💎有参无返回值抽象方法的练习</p><p>操作步骤</p><p>💎定义一个接口 (Flyable)，里面定义一个抽象方法：void fly (String s);</p><p>💎定义一个测试类 (FlyableDemo)，在测试类中提供两个方法</p><p>🔹一个方法是：useFlyable (Flyable f)</p><p>🔹一个方法是主方法，在主方法中调用 useFlyable 方法示例代码</p><p>示例代码</p><pre><code class="language-java">public class Main &#123;
    public static void main(String[] args) &#123;
        useFlyable(new Flyable() &#123;
            @Override
            public void fly(String s) &#123;
                System.out.println(s);
                System.out.println(&quot;飞机自驾游&quot;);
            &#125;
        &#125;);
        System.out.println(&quot;---------&quot;);
        useFlyable((s)-&gt;&#123;
            System.out.println(s);
            System.out.println(&quot;飞机自驾游&quot;);
        &#125;);
    &#125;
    public static void useFlyable(Flyable f)&#123;
        f.fly(&quot;风和日丽，晴空万里&quot;);
    &#125;
&#125;
interface Flyable&#123;
    void fly(String s);
&#125;


</code></pre><h2 id="五-lambda表达式练习3"><a class="anchor" href="#五-lambda表达式练习3">#</a> 五、Lambda 表达式练习 3</h2><p>练习描述</p><p>💎有参有返回值抽象方法的练习</p><p>操作步骤</p><p>💎定义一个接口 (Addable)，里面定义一个抽象方法：int add (int x,int y);</p><p>💎定义一个测试类 (AddableDemo)，在测试类中提供两个方法</p><p>🔹一个方法是：useAddable (Addable a)</p><p>🔹一个方法是主方法，在主方法中调用 useAddable 方法示例代码</p><p>示例代码</p><pre><code class="language-java">public class Main &#123;
    public static void main(String[] args) &#123;
        useAddable(new Addable() &#123;
            @Override
            public int add(int x, int y) &#123;
                return x+y;
            &#125;
        &#125;);
        useAddable((x,y)-&gt;&#123;
            return x+y;
        &#125;);
    &#125;
    public static void useAddable(Addable a)&#123;
        System.out.println(a.add(10,20));
    &#125;
&#125;
interface Addable&#123;
    int add(int x,int y);
&#125;


</code></pre><h2 id="六-lambda表达式的省略模式"><a class="anchor" href="#六-lambda表达式的省略模式">#</a> 六、Lambda 表达式的省略模式</h2><p>省略的规则</p><p>💎参数类型可以省略。但是有多个参数的情况下，不能只省略一个</p><p>💎如果参数有且仅有一个，那么小括号可以省略</p><p>💎如果代码块的语句只有一条，可以省略大括号和分号，和 return 关键字</p><p>代码演示</p><pre><code class="language-java">public class Main &#123;
    public static void main(String[] args) &#123;
    //参数的类型可以省略
        /**
         * useAddable((int x,int y) -&gt; &#123;
         *      return x + y;
         * &#125;);
         */
        useAddable((x,y)-&gt;&#123;
            return x+y;
        &#125;);
        //如果参数有且仅有一个，那么小括号可以省略
        /**
         *useFlyable((String s) -&gt; &#123;
         *       System.out.println(s);
         * &#125;);
         */
        useFlyable(s -&gt; &#123;
            System.out.println(s);
        &#125;);
        //如果代码块的语句只有一条，可以省略大括号和分号
        useFlyable(s -&gt; System.out.println(s));
        //如果代码块的语句只有一条，可以省略大括号和分号，如果有return，return也要省略掉
        useAddable(((x, y) -&gt; x+y));
    &#125;
    private static void useFlyable(Flyable f) &#123;
        f.fly(&quot;风和日丽，晴空万里&quot;);
    &#125;
    private static void useAddable(Addable a) &#123;
        int sum = a.add(10, 20);
        System.out.println(sum);
    &#125;
&#125;
interface Addable &#123;
    int add(int x, int y);
&#125;
interface Flyable &#123;
    void fly(String s);
&#125;
</code></pre><h2 id="七-lambda表达式的注意事项"><a class="anchor" href="#七-lambda表达式的注意事项">#</a> 七、Lambda 表达式的注意事项</h2><p>使用 Lambda 必须要有接口，并且要求接口中有且仅有一个抽象方法</p><p>必须有上下文环境，才能推导出 Lambda 对应的接口</p><p>💎根据局部变量的赋值得知 Lambda 对应的接口</p><p>Runnable r = () -&gt; System.out.println (&quot;Lambda 表达式&quot;);</p><p>💎根据调用方法的参数得知 Lambda 对应的接口</p><p>new Thread (() -&gt; System.out.println (&quot;Lambda 表达式&quot;)).start ();</p><h2 id="八-lambda表达式和匿名内部类的区别"><a class="anchor" href="#八-lambda表达式和匿名内部类的区别">#</a> 八、Lambda 表达式和匿名内部类的区别</h2><p>所需类型不同</p><p>💎匿名内部类：可以是接口，也可以是抽象类，还可以是具体类</p><p>💎Lambda 表达式：只能是接口</p><p>使用限制不同</p><p>💎如果接口中有且仅有一个抽象方法，可以使用 Lambda 表达式，也可以使用匿名内部类</p><p>💎如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用 Lambda 表达式</p><p>实现原理不同</p><p>💎匿名内部类：编译之后，产生一个单独的.class 字节码文件</p><p>💎Lambda 表达式：编译之后，没有一个单独的.class 字节码文件。对应的字节码会在运行的时候动态</p><p>生成</p><h1 id="接口组成更新"><a class="anchor" href="#接口组成更新">#</a> 接口组成更新</h1><h2 id="一-接口组成更新概述"><a class="anchor" href="#一-接口组成更新概述">#</a> 一、接口组成更新概述‘</h2><p>常量</p><p>public static final</p><p>抽象方法</p><p>public abstract</p><p>默认方法 (Java 8)</p><p>静态方法 (Java 8)</p><p>私有方法 (Java 9)</p><h2 id="二-接口中默认方法"><a class="anchor" href="#二-接口中默认方法">#</a> 二、接口中默认方法</h2><p>格式</p><p>public default 返回值类型 方法名 (参数列表)</p><p>范例</p><pre><code class="language-java">public default void show3() &#123;
    
&#125;
</code></pre><p>❗❗注意事项</p><p>💎默认方法不是抽象方法，所以不强制被重写。但是可以被重写，重写的时候去掉 default 关键字</p><p>💎public 可以省略，default 不能省略</p><h2 id="三-接口中静态方法"><a class="anchor" href="#三-接口中静态方法">#</a> 三、接口中静态方法</h2><p>格式</p><p>public static 返回值类型 方法名 (参数列表)</p><p>范例</p><pre><code class="language-java">public static void show() &#123;
    
&#125;
</code></pre><p>❗❗注意事项</p><p>💎静态方法只能通过接口名调用，不能通过实现类名或者对象名调用</p><p>💎public 可以省略，static 不能省略</p><h2 id="四-接口中私有方法"><a class="anchor" href="#四-接口中私有方法">#</a> 四、接口中私有方法</h2><p>私有方法产生原因</p><p>Java 9 中新增了带方法体的私有方法，这其实在 Java 8 中就埋下了伏笔：Java 8 允许在接口中定义带</p><p>方法体的默认方法和静态方法。这样可能就会引发一个问题：当两个默认方法或者静态方法中包含一</p><p>段相同的代码实现时，程序必然考虑将这段实现代码抽取成一个共性方法，而这个共性方法是不需要</p><p>让别人使用的，因此用私有给隐藏起来，这就是 Java 9 增加私有方法的必然性</p><p>定义格式</p><p>💎格式 1</p><p>private 返回值类型 方法名 (参数列表)</p><p>范例 1</p><pre><code class="language-java">private void show() &#123;
    
&#125;
</code></pre><p>💎格式 2</p><p>private static 返回值类型 方法名 (参数列表)</p><p>范例 2</p><pre><code class="language-java">private static void method() &#123;
    
&#125;
</code></pre><p>❗❗注意事项</p><p>💎默认方法可以调用私有的静态方法和非静态方法</p><p>💎静态方法只能调用私有的静态方法</p><h1 id="方法引用"><a class="anchor" href="#方法引用">#</a> 方法引用</h1><h2 id="一-体验方法引用"><a class="anchor" href="#一-体验方法引用">#</a> 一、体验方法引用</h2><p>方法引用的出现原因</p><p>在使用 Lambda 表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿参数做操作那么考</p><p>虑一种情况：如果我们在 Lambda 中所指定的操作方案，已经有地方存在相同方案，那是否还有必要</p><p>再写重复逻辑呢？答案肯定是没有必要</p><p>那我们又是如何使用已经存在的方案的呢？</p><p>这就是我们要讲解的方法引用，我们是通过方法引用来使用已经存在的方案</p><p>代码演示</p><pre><code class="language-java">public class Main &#123;
    public static void main(String[] args) &#123;
        //Lambda简化写法
        usePrintable(s -&gt; System.out.println(s));
        //方法引用
        usePrintable(System.out::println);
    &#125;

    public static void usePrintable(Printable p) &#123;
        p.printString(&quot;爱生活爱Java&quot;);
    &#125;
&#125;

interface Printable &#123;
    void printString(String s);
&#125;
</code></pre><h2 id="二-方法引用符"><a class="anchor" href="#二-方法引用符">#</a> 二、方法引用符</h2><p>方法引用符</p><p>:: 该符号为引用运算符，而它所在的表达式被称为方法引用</p><p>推导与省略</p><pre><code>💎如果使用Lambda，那么根据“可推导就是可省略”的原则，无需指定参数类型，也无需指定的重载
</code></pre><p>形式，它们都将被自动推导</p><p>💎如果使用方法引用，也是同样可以根据上下文进行推导</p><p>💎方法引用是 Lambda 的孪生兄弟</p><h2 id="三-引用类方法"><a class="anchor" href="#三-引用类方法">#</a> 三、引用类方法</h2><p>引用类方法，其实就是引用类的静态方法</p><p>格式</p><p>💎类名：：静态方法</p><p>范例</p><p>💎Integer::parseInt</p><p>💎Integer 类的方法：public static int parseInt (String s) 将此 String 转换为 int 类型数据</p><p>练习描述</p><p>💎定义一个接口 (Converter)，里面定义一个抽象方法 int convert (String s);</p><p>💎定义一个测试类 (ConverterDemo)，在测试类中提供两个方法</p><p>🔹一个方法是：useConverter (Converter c)</p><p>🔹一个方法是主方法，在主方法中调用 useConverter 方法</p><p>代码演示</p><pre><code class="language-java">public class Main &#123;
    public static void main(String[] args) &#123;
        usrConverter(Integer::parseInt);
    &#125;
    public static void usrConverter(Converter c)&#123;
        System.out.println(c.convert(&quot;12345678&quot;));
    &#125;
&#125;
interface Converter&#123;
    int convert(String s);
&#125;
</code></pre><p>使用说明</p><p>Lambda 表达式被类方法替代的时候，它的形式参数全部传递给静态方法作为参数</p><h2 id="四-引用对象的实例方法"><a class="anchor" href="#四-引用对象的实例方法">#</a> 四、引用对象的实例方法</h2><p>引用对象的实例方法，其实就引用类中的成员方法</p><p>格式</p><p>💎对象：：成员方法</p><p>范例</p><p>💎&quot;HelloWorld&quot;::toUpperCase</p><p>💎String 类中的方法：public String toUpperCase () 将此 String 所有字符转换为大写</p><p>练习描述</p><p>💎定义一个类 (PrintString)，里面定义一个方法</p><p>public void printUpper (String s)：把字符串参数变成大写的数据，然后在控制台输出</p><p>💎定义一个接口 (Printer)，里面定义一个抽象方法</p><p>void printUpperCase(String s)</p><p>💎定义一个测试类 (PrinterDemo)，在测试类中提供两个方法</p><p>🔹一个方法是：usePrinter (Printer p)</p><p>🔹一个方法是主方法，在主方法中调用 usePrinter 方法</p><p>代码演示</p><pre><code class="language-java">public class Main &#123;
    public static void main(String[] args) &#123;
        PrintString pr = new PrintString();
        usePrint(pr::printUpper);
    &#125;
    public static void usePrint(Printer p)&#123;
        p.printUpperCase(&quot;Hello World&quot;);
    &#125;
&#125;
class PrintString&#123;
    public void printUpper(String s)&#123;
        System.out.println(s.toUpperCase());
    &#125;
&#125;
interface Printer&#123;
    void printUpperCase(String s);
&#125;
</code></pre><p>使用说明</p><p>Lambda 表达式被对象的实例方法替代的时候，它的形式参数全部传递给该方法作为参数</p><h2 id="五-引用类的实例方法"><a class="anchor" href="#五-引用类的实例方法">#</a> 五、引用类的实例方法</h2><p>引用类的实例方法，其实就是引用类中的成员方法</p><p>格式</p><p>💎类名：：成员方法</p><p>范例</p><p>💎String::substring</p><p>public String substring(int beginIndex,int endIndex)</p><p>从 beginIndex 开始到 endIndex 结束，截取字符串。返回一个子串，子串的长度为 endIndex-</p><p>beginIndex</p><p>练习描述</p><p>💎定义一个接口 (MyString)，里面定义一个抽象方法：</p><p>🔹String mySubString(String s,int x,int y);</p><p>💎定义一个测试类 (MyStringDemo)，在测试类中提供两个方法</p><p>🔹一个方法是：useMyString (MyString my)</p><p>🔹一个方法是主方法，在主方法中调用 useMyString 方法</p><p>代码演示</p><pre><code class="language-java">public class Main &#123;
    public static void main(String[] args) &#123;
        useMyString(String::substring);
    &#125;
    public static void useMyString(MyString my)&#123;
        System.out.println( my.mySubString(&quot;hello world&quot;,3,8));
    &#125;
&#125;
interface MyString&#123;
    String mySubString(String s,int x,int y);
&#125;
</code></pre><p>使用说明</p><p>Lambda 表达式被类的实例方法替代的时候 第一个参数作为调用者 后面的参数全部传递给该方法作为参数</p><h2 id="六-引用构造器"><a class="anchor" href="#六-引用构造器">#</a> 六、引用构造器</h2><p>引用构造器，其实就是引用构造方法</p><p>格式</p><p>💎类名::new</p><p>范例</p><p>💎Student::new</p><p>练习描述</p><p>💎定义一个类 (Student)，里面有两个成员变量 (name,age)</p><p>并提供无参构造方法和带参构造方法，以及成员变量对应的 get 和 set 方法</p><p>💎定义一个接口 (StudentBuilder)，里面定义一个抽象方法</p><p>Student build(String name,int age);</p><p>💎定义一个测试类 (StudentDemo)，在测试类中提供两个方法</p><p>🔹一个方法是：useStudentBuilder (StudentBuilder s)</p><p>🔹一个方法是主方法，在主方法中调用 useStudentBuilder 方法</p><p>代码演示</p><pre><code class="language-java">public class Main &#123;
    public static void main(String[] args) &#123;
        useStudentBuilder(Student::new);
    &#125;
    public static void useStudentBuilder(StudentBuilder s)&#123;
        System.out.println(s.build(&quot;张三&quot;,26));
    &#125;
&#125;
interface StudentBuilder&#123;
    Student build(String name,int age);
&#125;
class Student &#123;
    private String name;
    private int age;

    public Student() &#123;
    &#125;

    public Student(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;

    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    @Override
    public String toString() &#123;
        return name + &quot;,&quot; + age;
    &#125;
&#125;
</code></pre><p>使用说明</p><p>Lambda 表达式被构造器替代的时候，它的形式参数全部传递给构造器作为参数</p><h1 id="函数式接口"><a class="anchor" href="#函数式接口">#</a> 函数式接口</h1><h2 id="一-函数式接口概述"><a class="anchor" href="#一-函数式接口概述">#</a> 一、函数式接口概述</h2><p>概念</p><p>有且仅有一个抽象方法的接口</p><p>如何检测一个接口是不是函数式接口</p><p>@FunctionalInterface</p><p>放在接口定义的上方：如果接口是函数式接口，编译通过；如果不是，编译失败</p><p>注意事项</p><p>我们自己定义函数式接口的时候，@FunctionalInterface 是可选的，就算我不写这个注解，只要保证满</p><p>足函数式接口定义的条件，也照样是函数式接口。但是，建议加上该注解</p><h2 id="二-函数式接口作为方法的参数"><a class="anchor" href="#二-函数式接口作为方法的参数">#</a> 二、函数式接口作为方法的参数</h2><p>需求描述</p><p>定义一个类 (RunnableDemo)，在类中提供两个方法</p><p>一个方法是：startThread (Runnable r) 方法参数 Runnable 是一个函数式接口</p><p>一个方法是主方法，在主方法中调用 startThread 方法</p><p>代码演示</p><pre><code class="language-java">public class Main &#123;
    public static void main(String[] args) &#123;
        start(()-&gt; System.out.println(Thread.currentThread().getName()+&quot;启动了&quot;));
    &#125;
    public static void start(Runnable r)&#123;
        new Thread(r).start();
    &#125;
&#125;
</code></pre><h2 id="三-函数式接口作为方法的返回值"><a class="anchor" href="#三-函数式接口作为方法的返回值">#</a> 三、函数式接口作为方法的返回值</h2><p>需求描述</p><p>定义一个类 (ComparatorDemo)，在类中提供两个方法</p><p>一个方法是：Comparator getComparator () 方法返回值 Comparator 是一个函数式接口</p><p>一个方法是主方法，在主方法中调用 getComparator 方法</p><p>示例代码</p><pre><code class="language-java">import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class Main &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; arrays = new ArrayList&lt;&gt;();
        arrays.add(&quot;adf&quot;);
        arrays.add(&quot;hfead&quot;);
        arrays.add(&quot;fhaesy&quot;);
        arrays.add(&quot;sa&quot;);
        System.out.println(&quot;排序前&quot;+arrays);
        Collections.sort(arrays);
        System.out.println(&quot;自然排序后&quot;+arrays);
        Collections.sort(arrays,get());
        System.out.println(&quot;排序后&quot;+arrays);
    &#125;
    public static Comparator&lt;String&gt; get()&#123;
        return (s1,s2)-&gt;s1.length()-s2.length();
    &#125;
&#125;
</code></pre><h2 id="四-常用函数式接口之supplier"><a class="anchor" href="#四-常用函数式接口之supplier">#</a> 四、常用函数式接口之 Supplier</h2><p>Supplier 接口</p><p>Supplier 接口也被称为生产型接口，如果我们指定了接口的泛型是什么类型，那么接口中的 get 方法就</p><p>会生产什么类型的数据供我们使用。</p><p>常用方法</p><p>只有一个无参的方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>T get()</td><td>按照某种实现逻辑 (由 Lambda 表达式实现) 返回一个数据</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">import java.util.function.Supplier;

public class Main &#123;
    public static void main(String[] args) &#123;
        System.out.println(getInt(()-&gt;10000));
        System.out.println(getString(()-&gt;&quot;qefrhu&quot;));
    &#125;
    public static Integer getInt(Supplier&lt;Integer&gt; s)&#123;
        return s.get();
    &#125;
    public static String getString(Supplier&lt;String&gt; s)&#123;
        return s.get();
    &#125;
&#125;
</code></pre><h2 id="五-常用函数式接口之consumer"><a class="anchor" href="#五-常用函数式接口之consumer">#</a> 五、常用函数式接口之 Consumer</h2><p>Consumer 接口</p><p>Consumer 接口也被称为消费型接口，它消费的数据的数据类型由泛型指定</p><p>常用方法</p><p>Consumer：包含两个方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void accept(T t)</td><td>对给定的参数执行此操作</td></tr><tr><td>default Consumer andThen(Consumerafter)</td><td>返回一个组合的 Consumer，依次执行此操作，然后执行 after 操作</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">import java.util.function.Consumer;

public class Main &#123;
    public static void main(String[] args) &#123;
        opt(&quot;张三&quot;,System.out::println,s-&gt; System.out.println(new StringBuilder(s).reverse()));
    &#125;
    public static void opt(String name, Consumer&lt;String&gt;c1,Consumer&lt;String&gt;c2)&#123;
        c1.andThen(c2).accept(name);
    &#125;
&#125;
</code></pre><h2 id="六-常用函数式接口之predicate"><a class="anchor" href="#六-常用函数式接口之predicate">#</a> 六、常用函数式接口之 Predicate</h2><p>Predicate 接口</p><p>Predicate 接口通常用于判断参数是否满足指定的条件</p><p>常用方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>boolean test(T t)</td><td>对给定的参数进行判断 (判断逻辑由 Lambda 表达式实现)，返回一个布尔值</td></tr><tr><td>default Predicate negate()</td><td>返回一个逻辑的否定，对应逻辑非</td></tr><tr><td>default Predicate and(Predicate other)</td><td>返回一个组合判断，对应短路与</td></tr><tr><td>default Predicate or(Predicate other)</td><td>返回一个组合判断，对应短路或</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">import java.util.function.Consumer;
import java.util.function.Predicate;

public class Main &#123;
    public static void main(String[] args) &#123;
        String s1=&quot;hello&quot;;
        String s2=&quot;hello world&quot;;
        System.out.println(negate(s1,s-&gt;s.length()&gt;8));
        System.out.println(and(s2,s -&gt; s.length()&gt;8,s-&gt;s.length()&lt;9));
        System.out.println(or(s2,s -&gt; s.length()&gt;8,s-&gt;s.length()&lt;13));
    &#125;
    public static boolean negate(String s,Predicate&lt;String&gt;p)&#123;
        return p.negate().test(s);
    &#125;
    public static boolean and(String s,Predicate&lt;String&gt;p1,Predicate&lt;String&gt;p2)&#123;
        return p1.and(p2).test(s);
    &#125;
    public static boolean or(String s,Predicate&lt;String&gt;p1,Predicate&lt;String&gt;p2)&#123;
        return p1.and(p2).test(s);
    &#125;
&#125;
</code></pre><h2 id="七-常用函数式接口之function"><a class="anchor" href="#七-常用函数式接口之function">#</a> 七、常用函数式接口之 Function</h2><p>Function 接口</p><p>Function&lt;T,R&gt; 接口通常用于对参数进行处理，转换 (处理逻辑由 Lambda 表达式实现)，然后返回一个</p><p>新的值</p><p>常用方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>R apply(T t)</td><td>将此函数应用于给定的参数</td></tr><tr><td>default FunctionandThen(Function after)</td><td>返回一个组合函数，首先将该函数应用于输入，然后将 after 函数应用于结果</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">import java.util.function.Function;

public class Main &#123;
    public static void main(String[] args) &#123;
        convert(&quot;100&quot;, Integer::parseInt);
        convert(100,i -&gt; String.valueOf(i + 566));
        convert(&quot;100&quot;, Integer::parseInt, i -&gt; String.valueOf(i + 566));
    &#125;
    private static void convert(String s, Function&lt;String,Integer&gt; fun) &#123;
    // Integer i = fun.apply(s);
        int i = fun.apply(s);
        System.out.println(i);
    &#125;
    //定义一个方法，把一个int类型的数据加上一个整数之后，转为字符串在控制台输出
    private static void convert(int i, Function&lt;Integer,String&gt; fun) &#123;
        String s = fun.apply(i);
        System.out.println(s);
    &#125;
    //定义一个方法，把一个字符串转换int类型，把int类型的数据加上一个整数之后，转为字符串在控制台输出
    private static void convert(String s, Function&lt;String,Integer&gt; fun1, Function&lt;Integer,String&gt; fun2) &#123;
        String ss = fun1.andThen(fun2).apply(s);
        System.out.println(ss);
    &#125;

&#125;
</code></pre><h1 id="stream流"><a class="anchor" href="#stream流">#</a> Stream 流</h1><h2 id="一-体验stream流"><a class="anchor" href="#一-体验stream流">#</a> 一、体验 Stream 流</h2><p>案例需求</p><p>按照下面的要求完成集合的创建和遍历</p><p>创建一个集合，存储多个字符串元素</p><p>把集合中所有以 &quot;张&quot; 开头的元素存储到一个新的集合</p><p>把 &quot;张&quot; 开头的集合中的长度为 3 的元素存储到一个新的集合</p><p>遍历上一步得到的集合</p><p>示例代码</p><pre><code class="language-java">import java.util.ArrayList;
import java.util.function.Function;
import java.util.stream.Stream;

public class Main &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(&quot;林青霞&quot;);
        list.add(&quot;张曼玉&quot;);
        list.add(&quot;王祖贤&quot;);
        list.add(&quot;柳岩&quot;);
        list.add(&quot;张敏&quot;);
        list.add(&quot;张无忌&quot;);
        Stream&lt;String&gt; s = list.stream();
        s.filter(s1 -&gt; s1.startsWith(&quot;张&quot;)).filter(s1 -&gt; s1.length()==3).forEach(System.out::println);
    &#125;
&#125;
</code></pre><h2 id="二-stream流的常见生成方式"><a class="anchor" href="#二-stream流的常见生成方式">#</a> 二、Stream 流的常见生成方式</h2><p>Stream 流的思想</p><p><img data-src="/youdaonote-images/WEBRESOURCE90a5c98fd442c1401cd9c8f6a937d8f3.png" alt=""></p><p>生成 Stream 流的方式</p><p>💎Collection 体系集合</p><p>使用默认方法 stream () 生成流， default Stream stream ()</p><p>💎Map 体系集合</p><p>把 Map 转成 Set 集合，间接的生成流</p><p>💎数组</p><p>通过 Stream 接口的静态方法 of (T... values) 生成流</p><p>示例代码</p><pre><code class="language-java">import java.util.*;
import java.util.stream.Stream;

public class Main &#123;
    public static void main(String[] args) &#123;
        //Collection体系的集合可以使用默认方法stream()生成流
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        Stream&lt;String&gt; listStream = list.stream();
        Set&lt;String&gt; set = new HashSet&lt;String&gt;();
        Stream&lt;String&gt; setStream = set.stream();
        //Map体系的集合间接的生成流
        Map&lt;String,Integer&gt; map = new HashMap&lt;String, Integer&gt;();
        Stream&lt;String&gt; keyStream = map.keySet().stream();
        Stream&lt;Integer&gt; valueStream = map.values().stream();
        Stream&lt;Map.Entry&lt;String, Integer&gt;&gt; entryStream = map.entrySet().stream();
        //数组可以通过Stream接口的静态方法of(T... values)生成流
        String[] strArray = &#123;&quot;hello&quot;,&quot;world&quot;,&quot;java&quot;&#125;;
        Stream&lt;String&gt; strArrayStream = Stream.of(strArray);
        Stream&lt;String&gt; strArrayStream2 = Stream.of(&quot;hello&quot;, &quot;world&quot;, &quot;java&quot;);
        Stream&lt;Integer&gt; intStream = Stream.of(10, 20, 30);
    &#125;
&#125;
</code></pre><h2 id="三-stream流中间操作方法"><a class="anchor" href="#三-stream流中间操作方法">#</a> 三、Stream 流中间操作方法</h2><p>概念</p><p>中间操作的意思是，执行完此方法之后，Stream 流依然可以继续执行其他操作。</p><p>常见方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Stream filter(Predicate predicate</td><td>用于对流中的数据进行过滤</td></tr><tr><td>Stream limit(long maxSize)</td><td>返回此流中的元素组成的流，截取前指定参数个数的数据</td></tr><tr><td>Stream skip(long n)</td><td>跳过指定参数个数的数据，返回由该流的剩余元素组成的流</td></tr><tr><td>static Stream concat(Stream a, Stream b)</td><td>合并 a 和 b 两个流为一个流</td></tr><tr><td>Stream distinct()</td><td>返回由该流的不同元素（根据 Object.equals (Object) ）组成的流</td></tr><tr><td>Stream sorted()</td><td>返回由此流的元素组成的流，根据自然顺序排序</td></tr><tr><td>Stream sorted(Comparator comparator)</td><td>返回由此流的元素组成的流，根据自然顺序排序</td></tr><tr><td>Stream map(Function mapper)</td><td>返回由给定函数应用于此流的元素的结果组成的流</td></tr><tr><td>Stream map(Function mapper)</td><td>返回一个 IntStream 其中包含将给定函数应用于此流的元素的结果</td></tr></tbody></table><p>💎filter 代码演示</p><pre><code class="language-java">import java.util.*;
import java.util.stream.Stream;

public class Main &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(&quot;林青霞&quot;);
        list.add(&quot;张曼玉&quot;);
        list.add(&quot;王祖贤&quot;);
        list.add(&quot;柳岩&quot;);
        list.add(&quot;张敏&quot;);
        list.add(&quot;张无忌&quot;);
        //需求1：把list集合中以张开头的元素在控制台输出
        list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).forEach(System.out::println);
        System.out.println(&quot;--------&quot;);
        //需求2：把list集合中长度为3的元素在控制台输出
        list.stream().filter(s -&gt; s.length()==3).forEach(System.out::println);
        System.out.println(&quot;--------&quot;);
        //需求3：把list集合中以张开头的，长度为3的元素在控制台输出
        list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).filter(s -&gt; s.length()==3).forEach(System.out::println);
    &#125;
&#125;
</code></pre><p>💎limit&amp;skip 代码演示</p><pre><code class="language-java">import java.util.*;
import java.util.stream.Stream;

public class Main &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(&quot;林青霞&quot;);
        list.add(&quot;张曼玉&quot;);
        list.add(&quot;王祖贤&quot;);
        list.add(&quot;柳岩&quot;);
        list.add(&quot;张敏&quot;);
        list.add(&quot;张无忌&quot;);
        //需求1：取前3个数据在控制台输出
        list.stream().limit(3).forEach(System.out::println);
        System.out.println(&quot;---------&quot;);
        //需求2：跳过3个元素，把剩下的元素在控制台输出
        list.stream().skip(3).forEach(System.out::println);
        System.out.println(&quot;---------&quot;);
        //需求3：跳过2个元素，把剩下的元素中前2个在控制台输出
        list.stream().skip(2).limit(2).forEach(System.out::println);
    &#125;
&#125;
</code></pre><p>💎concat&amp;distinct 代码演示</p><pre><code class="language-java">import java.util.*;
import java.util.stream.Stream;

public class Main &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(&quot;林青霞&quot;);
        list.add(&quot;张曼玉&quot;);
        list.add(&quot;王祖贤&quot;);
        list.add(&quot;柳岩&quot;);
        list.add(&quot;张敏&quot;);
        list.add(&quot;张无忌&quot;);
        //需求1：取前4个数据组成一个流
        Stream&lt;String&gt; s1 = list.stream().limit(4);
        //需求2：跳过2个数据组成一个流
        Stream&lt;String&gt; s2 = list.stream().skip(2);
        //需求3：合并需求1和需求2得到的流，并把结果在控制台输出
//        Stream.concat(s1,s2).forEach(System.out::println);
        //需求4：合并需求1和需求2得到的流，并把结果在控制台输出，要求字符串元素不能重复
        Stream.concat(s1,s2).distinct().forEach(System.out::println);
    &#125;
&#125;
</code></pre><p>💎sorted 代码演示</p><pre><code class="language-java">import java.util.*;
import java.util.stream.Stream;

public class Main &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(&quot;linqingxia&quot;);
        list.add(&quot;zhangmanyu&quot;);
        list.add(&quot;wangzuxian&quot;);
        list.add(&quot;liuyan&quot;);
        list.add(&quot;zhangmin&quot;);
        list.add(&quot;zhangwuji&quot;);
        //需求1：按照字母顺序把数据在控制台输出
//        list.stream().sorted().forEach(System.out::println);
        //需求2：按照字符串长度把数据在控制台输出
        list.stream().sorted((s1,s2)-&gt;&#123;
            int num=s1.length()-s2.length();
            num=num==0?s1.compareTo(s2):num;
            return num;
        &#125;).forEach(System.out::println);//*/
    &#125;
&#125;
</code></pre><p>💎map&amp;mapToInt 代码演示</p><pre><code class="language-java">import java.util.*;
import java.util.stream.Stream;

public class Main &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(&quot;10&quot;);
        list.add(&quot;20&quot;);
        list.add(&quot;30&quot;);
        list.add(&quot;40&quot;);
        list.add(&quot;50&quot;);
        //需求：将集合中的字符串数据转换为整数之后在控制台输出
//        list.stream().map(Integer::parseInt).forEach(System.out::println);
        //int sum() 返回此流中元素的总和
        int ans=list.stream().mapToInt(Integer::parseInt).sum();
        System.out.println(ans);
    &#125;
&#125;
</code></pre><h2 id="四-stream流终结操作方法"><a class="anchor" href="#四-stream流终结操作方法">#</a> 四、Stream 流终结操作方法</h2><p>概念</p><p>终结操作的意思是，执行完此方法之后，Stream 流将不能再执行其他操作。</p><p>常见方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void forEach(Consumer action)</td><td>对此流的每个元素执行操作</td></tr><tr><td>long count()</td><td>返回此流中的元素数</td></tr></tbody></table><p>代码演示</p><pre><code class="language-java">import java.util.*;
import java.util.stream.Stream;

public class Main &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(&quot;林青霞&quot;);
        list.add(&quot;张曼玉&quot;);
        list.add(&quot;王祖贤&quot;);
        list.add(&quot;柳岩&quot;);
        list.add(&quot;张敏&quot;);
        list.add(&quot;张无忌&quot;);
        //需求1：把集合中的元素在控制台输出
        list.stream().forEach(System.out::println);
        System.out.println(&quot;---------&quot;);
        //需求2：统计集合中有几个以张开头的元素，并把统计结果在控制台输出
        long cnt = list.stream().filter(s -&gt; s.startsWith(&quot;张&quot;)).count();
        System.out.println(cnt);
    &#125;
&#125;
</code></pre><h2 id="五-stream流的收集操作"><a class="anchor" href="#五-stream流的收集操作">#</a> 五、Stream 流的收集操作</h2><p>概念</p><p>对数据使用 Stream 流的方式操作完毕后，可以把流中的数据收集到集合中。</p><p>常用方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>R collect(Collector collector)</td><td>把结果收集到集合中</td></tr></tbody></table><p>工具类 Collectors 提供了具体的收集方式</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static Collector toList()</td><td>把元素收集到 List 集合中</td></tr><tr><td>public static Collector toSet()</td><td>把元素收集到 Set 集合中</td></tr><tr><td>public static Collector toMap(Function keyMapper,Functionvalue Mapper)</td><td>把元素收集到 Map 集合中</td></tr></tbody></table><p>示例代码</p><pre><code class="language-java">import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class Main &#123;
    public static void main(String[] args) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();
        list.add(&quot;林青霞&quot;);
        list.add(&quot;张曼玉&quot;);
        list.add(&quot;王祖贤&quot;);
        list.add(&quot;柳岩&quot;);
        /*
        //需求1：得到名字为3个字的流
        Stream&lt;String&gt; listStream = list.stream().filter(s -&gt; s.length() == 3);
        //需求2：把使用Stream流操作完毕的数据收集到List集合中并遍历
        List&lt;String&gt; names = listStream.collect(Collectors.toList());
        for(String s:names)
            System.out.println(s);//*/


        Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();
        set.add(10);
        set.add(20);
        set.add(30);
        set.add(33);
        set.add(35);
        /*
        //需求3：得到年龄大于25的流
        Stream&lt;Integer&gt; setStream = set.stream().filter(integer -&gt; integer &gt; 25);
        //需求4：把使用Stream流操作完毕的数据收集到Set集合中并遍历
        Set&lt;Integer&gt; ages = setStream.collect(Collectors.toSet());
        for (int i:ages)
            System.out.println(i);//*/

        String[] strArray = &#123;&quot;林青霞,30&quot;, &quot;张曼玉,35&quot;, &quot;王祖贤,33&quot;, &quot;柳岩,25&quot;&#125;;
        //需求5：得到字符串中年龄数据大于28的流
        Stream&lt;String&gt; arrayStream = Stream.of(strArray).filter(s -&gt; Integer.parseInt(s.split(&quot;,&quot;)[1]) &gt; 28);
        //需求6：把使用Stream流操作完毕的数据收集到Map集合中并遍历，字符串中的姓名作键，年龄作值
        Map&lt;String, Integer&gt; map = arrayStream.collect(Collectors.toMap(s-&gt;s.split(&quot;,&quot;)[0],s -&gt; Integer.parseInt(s.split(&quot;,&quot;)[1])));
        Set&lt;String&gt; keySet = map.keySet();
        for (String key : keySet) &#123;
            Integer value = map.get(key);
            System.out.println(key + &quot;,&quot; + value);
        &#125;

    &#125;
&#125;
</code></pre><h1 id="类加载器"><a class="anchor" href="#类加载器">#</a> 类加载器</h1><h2 id="一-类加载"><a class="anchor" href="#一-类加载">#</a> 一、类加载</h2><p>💎类加载的描述</p><p>🔹当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过类的加载，类的连接，类的</p><p>初始化这三个步骤来对类进行初始化。如果不出现意外情况，JVM 将会连续完成这三个步骤，所以有</p><p>时也把这三个步骤统称为类加载或者类初始化</p><p>💎类的加载</p><p>🔹就是指将 class 文件读入内存，并为之创建一个 java.lang.Class 对象</p><p>🔹任何类被使用时，系统都会为之建立一个 java.lang.Class 对象</p><p>💎类的连接</p><p>🔹验证阶段：用于检验被加载的类是否有正确的内部结构，并和其他类协调一致</p><p>🔹准备阶段：负责为类的类变量分配内存，并设置默认初始化值</p><p>🔹解析阶段：将类的二进制数据中的符号引用替换为直接引用</p><p>💎类的初始化</p><p>🔹在该阶段，主要就是对类变量进行初始化</p><p>💎类的初始化步骤</p><p>🔹假如类还未被加载和连接，则程序先加载并连接该类</p><p>🔹假如该类的直接父类还未被初始化，则先初始化其直接父类</p><p>🔹假如类中有初始化语句，则系统依次执行这些初始化语句</p><p>🔹注意：在执行第 2 个步骤的时候，系统对直接父类的初始化步骤也遵循初始化步骤 1-3</p><p>💎类的初始化时机</p><p>🔹创建类的实例</p><p>🔹调用类的类方法</p><p>🔹访问类或者接口的类变量，或者为该类变量赋值</p><p>🔹使用反射方式来强制创建某个类或接口对应的 java.lang.Class 对象</p><p>🔹初始化某个类的子类</p><p>🔹直接使用 java.exe 命令来运行某个主类</p><h2 id="二-类加载器"><a class="anchor" href="#二-类加载器">#</a> 二、类加载器</h2><p>💎类加载器的作用</p><p>🔹负责将.class 文件加载到内存中，并为之生成对应的 java.lang.Class 对象。虽然我们不用过分关心</p><p>类加载机制，但是了解这个机制我们就能更好的理解程序的运行！</p><p>💎JVM 的类加载机制</p><p>🔹全盘负责：就是当一个类加载器负责加载某个 Class 时，该 Class 所依赖的和引用的其他 Class 也将</p><p>由该类加载器负责载入，除非显示使用另外一个类加载器来载入</p><p>🔹父类委托：就是当一个类加载器负责加载某个 Class 时，先让父类加载器试图加载该 Class，只有在</p><p>父类加载器无法加载该类时才尝试从自己的类路径中加载该类</p><p>🔹缓存机制：保证所有加载过的 Class 都会被缓存，当程序需要使用某个 Class 对象时，类加载器先从</p><p>缓存区中搜索该 Class，只有当缓存区中不存在该 Class 对象时，系统才会读取该类对应的二进制数</p><p>据，并将其转换成 Class 对象，存储到缓存区</p><p>💎Java 中的内置类加载器</p><p>🔹Bootstrap class loader：它是虚拟机的内置类加载器，通常表示为 null ，并且没有父 null</p><p>🔹Platform class loader：平台类加载器可以看到所有平台类 ，平台类包括由平台类加载器或其祖先</p><p>定义的 JavaSE 平台 API，其实现类和 JDK 特定的运行时类</p><p>🔹System class loader：它也被称为应用程序类加载器 ，与平台类加载器不同。 系统类加载器通常</p><p>用于定义应用程序类路径，模块路径和 JDK 特定工具上的类</p><p>🔹类加载器的继承关系：System 的父加载器为 Platform，而 Platform 的父加载器为 Bootstrap</p><p>💎ClassLoader 中的两个方法</p><p>🔹方法分类</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>static ClassLoader getSystemClassLoader()</td><td>返回用于委派的系统类加载器</td></tr><tr><td>ClassLoader getParent()</td><td>返回父类加载器进行委派</td></tr></tbody></table><p>🔹示例代码</p><pre><code class="language-java">public class Main &#123;
    public static void main(String[] args) &#123;
        //static ClassLoader getSystemClassLoader()：返回用于委派的系统类加载器
        ClassLoader c = ClassLoader.getSystemClassLoader();
        System.out.println(c);
        //ClassLoader getParent()：返回父类加载器进行委派
        System.out.println(&quot;-------&quot;);
        ClassLoader c2 = c.getParent();
        System.out.println(c2);

        ClassLoader c3 = c2.getParent();
        System.out.println(c3);
    &#125;
&#125;
</code></pre><h1 id="反射"><a class="anchor" href="#反射">#</a> 反射</h1><h2 id="一-反射的概述"><a class="anchor" href="#一-反射的概述">#</a> 一、反射的概述</h2><p>🔹是指在运行时去获取一个类的变量和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机</p><p>制。由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译期就完成确定，在运行期仍然可以</p><p>扩展</p><h2 id="二-获取class类对象的三种方式"><a class="anchor" href="#二-获取class类对象的三种方式">#</a> 二、获取 Class 类对象的三种方式</h2><p>💎三种方式分类</p><p>🔹类名.class 属性</p><p>🔹对象名.getClass () 方法</p><p>🔹Class.forName (全类名) 方法</p><p>💎代码演示</p><p>student 类</p><pre><code class="language-java">package text;

public class Student &#123;
    //成员变量：一个私有，一个默认，一个公共
    private String name;
    int age;
    public String address;
    //构造方法：一个私有，一个默认，两个公共
    public Student() &#123;
    &#125;
    private Student(String name) &#123;
        this.name = name;
    &#125;
    Student(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
    public Student(String name, int age, String address) &#123;
        this.name = name;
        this.age = age;
        this.address = address;
    &#125;
    //成员方法：一个私有，四个公共
    private void function() &#123;
        System.out.println(&quot;function&quot;);
    &#125;
    public void method1() &#123;
        System.out.println(&quot;method&quot;);
    &#125;
    public void method2(String s) &#123;
        System.out.println(&quot;method:&quot; + s);
    &#125;
    public String method3(String s, int i) &#123;
        return s + &quot;,&quot; + i;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Student&#123;&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                &quot;, address='&quot; + address + '\'' +
                '&#125;';
    &#125;
&#125;
</code></pre><pre><code class="language-java">package text;

public class Demo &#123;
    public static void main(String[] args) throws ClassNotFoundException &#123;
        //使用类的class属性来获取该类对应的Class对象
        Class&lt;Student&gt; c1 = Student.class;
        System.out.println(c1);

        Class&lt;Student&gt; c2 = Student.class;
        System.out.println(c1==c2);
        //调用对象的getClass()方法，返回该对象所属类对应的Class对象
        Student s = new Student();
        Class&lt;? extends Student&gt; c3 = s.getClass();
        System.out.println(c1==c3);
        //使用Class类中的静态方法forName(String className)
        Class&lt;?&gt; c4 = Class.forName(&quot;text.Student&quot;);
        System.out.println(c1==c4);
    &#125;
&#125;
</code></pre><h2 id="三-反射获取构造方法并使用"><a class="anchor" href="#三-反射获取构造方法并使用">#</a> 三、反射获取构造方法并使用</h2><p>💎Class 类获取构造方法对象的方法</p><p>🔹方法分类</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Constructor[] getConstructors()</td><td>返回所有公共构造方法对象的数组</td></tr><tr><td>Constructor[] getDeclaredConstructors()</td><td>返回所有构造方法对象的数组</td></tr><tr><td>Constructor getConstructor(Class&lt;?&gt;... parameter Types)</td><td>返回单个公共构造方法对象</td></tr><tr><td>Constructor getDeclaredConstructor(Class&lt;?&gt;...parameter Types)</td><td>返回单个构造方法对象</td></tr></tbody></table><p>🔹Constructor 类用于创建对象的方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>T newInstance(Object...initargs)</td><td>根据指定的构造方法创建对象</td></tr></tbody></table><p>🔹示例代码</p><pre><code class="language-java">package text;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class Demo &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;
        //获取Class对象
        Class&lt;?&gt; c = Class.forName(&quot;text.Student&quot;);
        //Constructor&lt;?&gt;[] getConstructors() 返回一个包含 Constructor对象的数组，Constructor对象反映了由该 Class对象表示的类的所有公共构造函数
//        Constructor&lt;?&gt;[] cons = c.getConstructors();
        //Constructor&lt;?&gt;[] getDeclaredConstructors() 返回反映由该 Class对象表示的类声明的所有构造函数的 Constructor对象的数组
        Constructor&lt;?&gt;[] cons = c.getDeclaredConstructors();
        for (Constructor con:cons)
            System.out.println(con);
        System.out.println(&quot;--------&quot;);
        //Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes) 返回一个Constructor对象，该对象反映由该 Class对象表示的类的指定公共构造函数
        //参数：你要获取的构造方法的参数的个数和数据类型对应的字节码文件对象
        Constructor&lt;?&gt; con = c.getConstructor();
        Object obj = con.newInstance();
        System.out.println(obj);

    &#125;
&#125;
</code></pre><h2 id="四-反射获取成员变量并使用"><a class="anchor" href="#四-反射获取成员变量并使用">#</a> 四、反射获取成员变量并使用</h2><p>💎Class 类获取成员变量对象的方法</p><p>🔹方法分类</p><table><thead><tr><th>方法名</th><th>方法名</th></tr></thead><tbody><tr><td>Field[] getFields()</td><td>返回所有公共成员变量对象的数组</td></tr><tr><td>Field[] getDeclaredFields()</td><td>返回所有成员变量对象的数组</td></tr><tr><td>Field getField(String name)</td><td>返回单个公共成员变量对象</td></tr><tr><td>Field getDeclaredField(String name)</td><td>返回单个成员变量对象</td></tr></tbody></table><p>🔹Field 类用于给成员变量赋值的方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>void set(Object obj,Object value)</td><td>给 obj 对象的成员变量赋值为 value</td></tr></tbody></table><p>🔹示例代码</p><pre><code class="language-java">package text;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;

public class Demo &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123;
        Class&lt;?&gt; c = Class.forName(&quot;text.Student&quot;);
        //Field[] getFields() 返回一个包含 Field对象的数组， Field对象反映由该 Class对象表示的类或接口的所有可访问的公共字段
        //Field[] getDeclaredFields() 返回一个 Field对象的数组，反映了由该 Class对象表示的类或接口声明的所有字段
//        Field[] fields = c.getFields();
        Field[] fields = c.getDeclaredFields();
        for (Field field:fields)
            System.out.println(field);
        System.out.println(&quot;--------&quot;);
        //Field getField(String name) 返回一个 Field对象，该对象反映由该 Class对象表 示的类或接口的指定公共成员字段
        //Field getDeclaredField(String name) 返回一个 Field对象，该对象反映由该Class对象表示的类或接口的指定声明字段
        Constructor&lt;?&gt; con = c.getConstructor();
        Object obj = con.newInstance();
        //Field提供有关类或接口的单个字段的信息和动态访问
        //void set(Object obj, Object value) 将指定的对象参数中由此 Field对象表示的字段设置为指定的新值
        Field address = c.getField(&quot;address&quot;);
        address.set(obj,&quot;西安&quot;);
        System.out.println(obj);
    &#125;
&#125;
</code></pre><h2 id="五-反射获取成员方法并使用"><a class="anchor" href="#五-反射获取成员方法并使用">#</a> 五、反射获取成员方法并使用</h2><p>💎Class 类获取成员方法对象的方法</p><p>🔹方法分类</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Method[] getMethods()</td><td>返回所有公共成员方法对象的数组，包括继承的</td></tr><tr><td>Method[] getDeclaredMethods()</td><td>返回所有成员方法对象的数组，不包括继承的</td></tr><tr><td>Method getMethod(String name, Class&lt;?&gt; ...parameter Types)</td><td>返回单个公共成员方法对象</td></tr><tr><td>Method getDeclaredMethod(String name, Class&lt;? &gt; ...parameter Types)</td><td>返回单个成员方法对象</td></tr></tbody></table><p>🔹Method 类用于执行方法的方法</p><table><thead><tr><th>方法名</th><th>方法名</th></tr></thead><tbody><tr><td>Objectinvoke(Object obj,Object... args)</td><td>调用 obj 对象的成员方法，参数是 args, 返回值是 Object 类型</td></tr></tbody></table><p>🔹示例代码</p><pre><code class="language-java">package text;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class Demo &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123;
        Class&lt;?&gt; c = Class.forName(&quot;text.Student&quot;);
        //Student s = new Student();
        Constructor&lt;?&gt; con = c.getConstructor();
        Object obj = con.newInstance();
        //s.method1();
        Method m1 = c.getMethod(&quot;method1&quot;);
        m1.invoke(obj);
        //s.method2(&quot;林青霞&quot;);
        Method m2 = c.getMethod(&quot;method2&quot;, String.class);
        m2.invoke(obj,&quot;林青霞&quot;);
        // String ss = s.method3(&quot;林青霞&quot;,30);
        // System.out.println(ss);
        Method m3 = c.getMethod(&quot;method3&quot;, String.class, int.class);
        Object o = m3.invoke(obj, &quot;林青霞&quot;, 30);
        System.out.println(o);
    &#125;
&#125;
</code></pre><h2 id="六-反射练习之越过泛型检查"><a class="anchor" href="#六-反射练习之越过泛型检查">#</a> 六、反射练习之越过泛型检查</h2><p>案例需求</p><p>通过反射技术，向一个泛型为 Integer 的集合中添加一些字符串数据</p><p>代码实现</p><pre><code class="language-java">package text;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;

public class Demo &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123;
        ArrayList&lt;Integer&gt; arr = new ArrayList&lt;&gt;();
        Class&lt;? extends ArrayList&gt; c = arr.getClass();
        Method add = c.getMethod(&quot;add&quot;, Object.class);
        add.invoke(arr,&quot;hello&quot;);
        add.invoke(arr,&quot;world&quot;);
        add.invoke(arr,&quot;java&quot;);
        System.out.println(arr);
    &#125;
&#125;
</code></pre><h2 id="七-运行配置文件中指定类的指定方法"><a class="anchor" href="#七-运行配置文件中指定类的指定方法">#</a> 七、运行配置文件中指定类的指定方法</h2><p>案例需求</p><p>通过反射运行配置文件中指定类的指定方法</p><p>代码实现</p><p>class.txt</p><pre><code>className=text.Teacher
methodName=teach
</code></pre><p>Student 类</p><pre><code class="language-java">package text;

public class Student &#123;
    public void study()&#123;
        System.out.println(&quot;学习&quot;);
    &#125;
&#125;
</code></pre><p>Teacher 类</p><pre><code class="language-java">package text;

public class Teacher &#123;
    public void teach()&#123;
        System.out.println(&quot;教学&quot;);
    &#125;
&#125;
</code></pre><p>测试类</p><pre><code class="language-java">package text;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Properties;

public class Demo &#123;
    public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException, IOException &#123;
        Properties pro = new Properties();
        FileReader fr = new FileReader(&quot;src\\class.txt&quot;);
        pro.load(fr);
        fr.close();
        Class&lt;?&gt; className = Class.forName(pro.getProperty(&quot;className&quot;));
        Object obj = className.getConstructor().newInstance();
        Method m = className.getMethod(pro.getProperty(&quot;methodName&quot;));
        m.invoke(obj);
    &#125;
&#125;
</code></pre><h1 id="模块化"><a class="anchor" href="#模块化">#</a> 模块化</h1><h2 id="一-模块化概述"><a class="anchor" href="#一-模块化概述">#</a> 一、模块化概述</h2><p>Java 语言随着这些年的发展已经成为了一门影响深远的编程语言，无数平台，系统都采用 Java 语言编写。</p><p>但是，伴随着发展，Java 也越来越庞大，逐渐发展成为一门 “臃肿” 的语言。而且，无论是运行一个大型的</p><p>软件系统，还是运行一个小的程序，即使程序只需要使用 Java 的部分核心功能， JVM 也要加载整个 JRE 环</p><p>境。 为了给 Java “瘦身”，让 Java 实现轻量化，Java 9 正式的推出了模块化系统。Java 被拆分为 N 多个模</p><p>块，并允许 Java 程序可以根据需要选择加载程序必须的 Java 模块，这样就可以让 Java 以轻量化的方式来运</p><p>行</p><p>其实，Java 7 的时候已经提出了模块化的概念，但由于其过于复杂，Java 7，Java 8 都一直未能真正推</p><p>出，直到 Java9 才真正成熟起来。对于 Java 语言来说，模块化系统是一次真正的自我革新，这种革新使得</p><p>“古老而庞大” 的 Java 语言重新焕发年轻的活力</p><h2 id="二-模块的基本使用"><a class="anchor" href="#二-模块的基本使用">#</a> 二、模块的基本使用</h2><p><a href="/youdaonote-attachments/WEBRESOURCEb12016470014dd4a4fc44748678c65e9TheEnd.zip">TheEnd.zip</a></p><ol><li><p>在项目中创建两个模块。一个是 myOne, 一个是 myTwo</p></li><li><p>在 myOne 模块中创建以下包和以下类，并在类中添加方法</p></li></ol><p><img data-src="/youdaonote-images/WEBRESOURCEcaefd97e115bf1b51edd166e72d9cd50.png" alt=""></p><ol start="3"><li>在 myTwo 模块中创建以下包和以下类，并在类中创建对象并使用</li></ol><p><img data-src="/youdaonote-images/WEBRESOURCEbd69c557a1cd068d0a396c24e1d6c282.png" alt=""></p><ol start="4"><li>在 myOne 模块中 src 目录下，创建 module-info.java，并写入以下内容</li></ol><p><img data-src="/youdaonote-images/WEBRESOURCEe5bb65afe4a7a4c040ae0c7937569bae.png" alt=""></p><ol start="5"><li>在 myTwo 模块中 src 目录下，创建 module-info.java，并写入以下内容</li></ol><p><img data-src="/youdaonote-images/WEBRESOURCE64914cf6daf0521b749f851d9c1005fe.png" alt=""></p><h2 id="三-模块服务的基本使用"><a class="anchor" href="#三-模块服务的基本使用">#</a> 三、模块服务的基本使用</h2><p><a href="/youdaonote-attachments/WEBRESOURCEced0caa9e2104eead6d93437702e18d1TheEnd.zip">TheEnd.zip</a></p><ol><li>在 myOne 模块中新建一个包，提供一个接口和两个实现类</li></ol><p><img data-src="/youdaonote-images/WEBRESOURCEd9d151481a5acdbfc4671484e57bf923.png" alt=""></p><ol start="2"><li>在 myOne 模块中修改 module-info.java 文件，添加以下内容</li></ol><p><img data-src="/youdaonote-images/WEBRESOURCE705e193ad948b3231eb9b963e59ff48e.png" alt=""></p><ol start="3"><li>在 myTwo 模块中新建一个测试类</li></ol><p><img data-src="/youdaonote-images/WEBRESOURCE7ca9583304e9bcbfd9f0dc7bdc74a4d0.png" alt=""></p><ol start="4"><li>在 myTwo 模块中修改 module-info.java 文件，添加以下内容</li></ol><p><img data-src="/youdaonote-images/WEBRESOURCE92a702170e480eb44be92cd48b2100e6.png" alt=""></p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2023-08-24 18:27:38" itemprop="dateModified" datetime="2023-08-24T18:27:38+08:00">2023-08-24</time></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="KangKang 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="KangKang 支付宝"><p>支付宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>kangkang <i class="ic i-at"><em>@</em></i>KangKang</li><li class="link"><strong>本文链接：</strong> <a href="https://blog.0kangkang0.top/2023/07/12/Java/" title="Java">https://blog.0kangkang0.top/2023/07/12/Java/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/07/11/spring%E9%AB%98%E7%BA%A7/" itemprop="url" rel="prev" data-background-image="&#x2F;img&#x2F;v2-f35943a6d87c5f9f10f45eee4941deb3_720w.jpg" title="spring高级"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>spring高级</h3></a></div><div class="item right"><a href="/2023/07/23/JavaWeb/" itemprop="url" rel="next" data-background-image="&#x2F;img&#x2F;00034-3635204744.png" title="JavaWeb"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i></span><h3>JavaWeb</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">类和对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88arraylist"><span class="toc-number">2.</span> <span class="toc-text">集合 ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E6%9E%84%E9%80%A0%E5%92%8C%E6%B7%BB%E5%8A%A0"><span class="toc-number">2.1.</span> <span class="toc-text">一、构造和添加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">二、常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">2.3.</span> <span class="toc-text">三、集合的遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">3.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E7%BB%A7%E6%89%BF%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">一、继承概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%A5%BD%E5%A4%84%E5%92%8C%E5%BC%8A%E7%AB%AF"><span class="toc-number">3.2.</span> <span class="toc-text">二、继承的好处和弊端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E7%BB%A7%E6%89%BF%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">3.3.</span> <span class="toc-text">三、 继承中变量的访问特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-super"><span class="toc-number">3.4.</span> <span class="toc-text">四、super</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">3.5.</span> <span class="toc-text">五、 继承中构造方法的访问特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">3.6.</span> <span class="toc-text">六、继承中成员方法的访问特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-super%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">3.7.</span> <span class="toc-text">七、super 内存图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.8.</span> <span class="toc-text">八、方法重写的注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D-java%E4%B8%AD%E7%BB%A7%E6%89%BF%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.9.</span> <span class="toc-text">九、 Java 中继承的注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">4.</span> <span class="toc-text">修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-package"><span class="toc-number">4.1.</span> <span class="toc-text">一、package</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-import"><span class="toc-number">4.2.</span> <span class="toc-text">二、import</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">4.3.</span> <span class="toc-text">三、权限修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-final"><span class="toc-number">4.4.</span> <span class="toc-text">四、 final</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-final%E4%BF%AE%E9%A5%B0%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">4.5.</span> <span class="toc-text">五、 final 修饰局部变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-static"><span class="toc-number">4.6.</span> <span class="toc-text">六、 static</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-static%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">4.7.</span> <span class="toc-text">七、 static 访问特点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">5.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">一、多态的概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%A4%9A%E6%80%81%E4%B8%AD%E7%9A%84%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">5.2.</span> <span class="toc-text">二、多态中的成员访问特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%A4%9A%E6%80%81%E7%9A%84%E5%A5%BD%E5%A4%84%E5%92%8C%E5%BC%8A%E7%AB%AF"><span class="toc-number">5.3.</span> <span class="toc-text">三、多态的好处和弊端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%A4%9A%E6%80%81%E4%B8%AD%E7%9A%84%E8%BD%AC%E5%9E%8B"><span class="toc-number">5.4.</span> <span class="toc-text">四、多态中的转型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">一、抽象类的概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">6.2.</span> <span class="toc-text">二、抽象类的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E7%89%B9%E7%82%B9"><span class="toc-number">6.3.</span> <span class="toc-text">三、抽象类的成员特点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">7.1.</span> <span class="toc-text">一、接口的概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">7.2.</span> <span class="toc-text">二、接口的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%88%90%E5%91%98%E7%89%B9%E7%82%B9"><span class="toc-number">7.3.</span> <span class="toc-text">三、接口的成员特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.4.</span> <span class="toc-text">四、类和接口的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.5.</span> <span class="toc-text">五、抽象类和接口的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">8.</span> <span class="toc-text">参数传递</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E7%B1%BB%E5%90%8D%E4%BD%9C%E4%B8%BA%E5%BD%A2%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">8.1.</span> <span class="toc-text">一、类名作为形参和返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%BD%9C%E4%B8%BA%E5%BD%A2%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">8.2.</span> <span class="toc-text">二、抽象类作为形参和返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E6%8E%A5%E5%8F%A3%E5%90%8D%E4%BD%9C%E4%B8%BA%E5%BD%A2%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">8.3.</span> <span class="toc-text">三、接口名作为形参和返回值</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">9.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">9.1.</span> <span class="toc-text">一、内部类的基本使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">9.2.</span> <span class="toc-text">二、 成员内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">9.3.</span> <span class="toc-text">三、局部内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">9.4.</span> <span class="toc-text">四、 匿名内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">9.5.</span> <span class="toc-text">五、 匿名内部类在开发中的使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8api"><span class="toc-number">10.</span> <span class="toc-text">常用 API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-math"><span class="toc-number">10.1.</span> <span class="toc-text">一、Math</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-system"><span class="toc-number">10.2.</span> <span class="toc-text">二、 System</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-object%E7%B1%BB%E7%9A%84tostring%E6%96%B9%E6%B3%95"><span class="toc-number">10.3.</span> <span class="toc-text">三、Object 类的 toString 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-object%E7%B1%BB%E7%9A%84equals%E6%96%B9%E6%B3%95"><span class="toc-number">10.4.</span> <span class="toc-text">四、Object 类的 equals 方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%8E%9F%E7%90%86"><span class="toc-number">10.5.</span> <span class="toc-text">五、 冒泡排序原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.6.</span> <span class="toc-text">六、冒泡排序代码实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-arrays"><span class="toc-number">10.7.</span> <span class="toc-text">七、Arrays</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">11.</span> <span class="toc-text">包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">11.1.</span> <span class="toc-text">一、基本类型包装类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-integer%E7%B1%BB"><span class="toc-number">11.2.</span> <span class="toc-text">二、Integer 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-int%E5%92%8Cstring%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">11.3.</span> <span class="toc-text">三、int 和 String 类型的相互转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E5%92%8C%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1"><span class="toc-number">11.4.</span> <span class="toc-text">四、自动拆箱和自动装箱</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">12.</span> <span class="toc-text">时间日期类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-date%E7%B1%BB"><span class="toc-number">12.1.</span> <span class="toc-text">一、Date 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-date%E7%B1%BB%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">12.2.</span> <span class="toc-text">二、Date 类常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-simpledateformat%E7%B1%BB"><span class="toc-number">12.3.</span> <span class="toc-text">三、SimpleDateFormat 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-calendar%E7%B1%BB"><span class="toc-number">12.4.</span> <span class="toc-text">四、Calendar 类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">13.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%BC%82%E5%B8%B8"><span class="toc-number">13.1.</span> <span class="toc-text">一、异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-jvm%E9%BB%98%E8%AE%A4%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">13.2.</span> <span class="toc-text">二、JVM 默认处理异常的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-try-catch%E6%96%B9%E5%BC%8F%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="toc-number">13.3.</span> <span class="toc-text">三、try-catch 方式处理异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-throwable%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">13.4.</span> <span class="toc-text">四、Throwable 成员方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.5.</span> <span class="toc-text">五、编译时异常和运行时异常的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-throws%E6%96%B9%E5%BC%8F%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="toc-number">13.6.</span> <span class="toc-text">六、throws 方式处理异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-throws%E5%92%8Cthrow%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.7.</span> <span class="toc-text">七、throws 和 throw 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">13.8.</span> <span class="toc-text">八、自定义异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#colection%E9%9B%86%E5%90%88"><span class="toc-number">14.</span> <span class="toc-text">colection 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E9%9B%86%E5%90%88%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">14.1.</span> <span class="toc-text">一、集合体系结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-collection%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">14.2.</span> <span class="toc-text">二、Collection 集合概述和基本使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-collection%E9%9B%86%E5%90%88%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">14.3.</span> <span class="toc-text">三、Collection 集合的常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-collection%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">14.4.</span> <span class="toc-text">四、Collection 集合的遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#list%E9%9B%86%E5%90%88"><span class="toc-number">15.</span> <span class="toc-text">List 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-list%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">15.1.</span> <span class="toc-text">一、List 集合概述和特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-list%E9%9B%86%E5%90%88%E7%9A%84%E7%89%B9%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">15.2.</span> <span class="toc-text">二、List 集合的特有方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%B9%B6%E5%8F%91%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8"><span class="toc-number">15.3.</span> <span class="toc-text">三、并发修改异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">15.4.</span> <span class="toc-text">四、列表迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF"><span class="toc-number">15.5.</span> <span class="toc-text">五、增强 for 循环</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">16.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-number">16.1.</span> <span class="toc-text">一、数据结构之栈和队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">16.2.</span> <span class="toc-text">二、数据结构之数组和链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#list%E9%9B%86%E5%90%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">17.</span> <span class="toc-text">List 集合的实现类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-list%E9%9B%86%E5%90%88%E5%AD%90%E7%B1%BB%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">17.1.</span> <span class="toc-text">一、List 集合子类的特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-linkedlist%E9%9B%86%E5%90%88%E7%9A%84%E7%89%B9%E6%9C%89%E5%8A%9F%E8%83%BD"><span class="toc-number">17.2.</span> <span class="toc-text">二、LinkedList 集合的特有功能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#set%E9%9B%86%E5%90%88"><span class="toc-number">18.</span> <span class="toc-text">set 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-set%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">18.1.</span> <span class="toc-text">一、Set 集合概述和特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%93%88%E5%B8%8C%E5%80%BC"><span class="toc-number">18.2.</span> <span class="toc-text">二、哈希值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-hashset%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">18.3.</span> <span class="toc-text">三、HashSet 集合概述和特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-hashset%E9%9B%86%E5%90%88%E4%BF%9D%E8%AF%81%E5%85%83%E7%B4%A0%E5%94%AF%E4%B8%80%E6%80%A7%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">18.4.</span> <span class="toc-text">四、HashSet 集合保证元素唯一性源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">18.5.</span> <span class="toc-text">五、常见数据结构之哈希表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-linkedhashset%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">18.6.</span> <span class="toc-text">六、LinkedHashSet 集合概述和特点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#set%E9%9B%86%E5%90%88%E6%8E%92%E5%BA%8F"><span class="toc-number">19.</span> <span class="toc-text">Set 集合排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-treeset%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">19.1.</span> <span class="toc-text">一、TreeSet 集合概述和特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8Fcomparable%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">19.2.</span> <span class="toc-text">二、自然排序 Comparable 的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E6%AF%94%E8%BE%83%E5%99%A8%E6%8E%92%E5%BA%8Fcomparator%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">19.3.</span> <span class="toc-text">三、比较器排序 Comparator 的使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">20.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E6%B3%9B%E5%9E%8B%E6%A6%82%E8%BF%B0%E5%92%8C%E5%A5%BD%E5%A4%84"><span class="toc-number">20.1.</span> <span class="toc-text">一、泛型概述和好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">20.2.</span> <span class="toc-text">二、泛型类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">20.3.</span> <span class="toc-text">三、泛型方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">20.4.</span> <span class="toc-text">四、泛型接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">20.5.</span> <span class="toc-text">五、类型通配符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">21.</span> <span class="toc-text">可变参数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">21.1.</span> <span class="toc-text">一、可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">21.2.</span> <span class="toc-text">二、可变参数的使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#map%E9%9B%86%E5%90%88"><span class="toc-number">22.</span> <span class="toc-text">Map 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-map%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">22.1.</span> <span class="toc-text">一、Map 集合概述和特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-map%E9%9B%86%E5%90%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="toc-number">22.2.</span> <span class="toc-text">二、Map 集合的基本功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-map%E9%9B%86%E5%90%88%E7%9A%84%E8%8E%B7%E5%8F%96%E5%8A%9F%E8%83%BD"><span class="toc-number">22.3.</span> <span class="toc-text">三、Map 集合的获取功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-map%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F1"><span class="toc-number">22.4.</span> <span class="toc-text">四、Map 集合的遍历 (方式 1)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-map%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F2"><span class="toc-number">22.5.</span> <span class="toc-text">五、Map 集合的遍历 (方式 2)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#collections%E9%9B%86%E5%90%88%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">23.</span> <span class="toc-text">Collections 集合工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-collections%E6%A6%82%E8%BF%B0%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">23.1.</span> <span class="toc-text">一、Collections 概述和使用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#file%E7%B1%BB"><span class="toc-number">24.</span> <span class="toc-text">File 类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-file%E7%B1%BB%E6%A6%82%E8%BF%B0%E5%92%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">24.1.</span> <span class="toc-text">一、File 类概述和构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-file%E7%B1%BB%E5%88%9B%E5%BB%BA%E5%8A%9F%E8%83%BD"><span class="toc-number">24.2.</span> <span class="toc-text">二、File 类创建功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-file%E7%B1%BB%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD"><span class="toc-number">24.3.</span> <span class="toc-text">三、File 类删除功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-file%E7%B1%BB%E5%88%A4%E6%96%AD%E5%92%8C%E8%8E%B7%E5%8F%96%E5%8A%9F%E8%83%BD"><span class="toc-number">24.4.</span> <span class="toc-text">四、File 类判断和获取功能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">25.</span> <span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E9%80%92%E5%BD%92"><span class="toc-number">25.1.</span> <span class="toc-text">一、递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95"><span class="toc-number">25.2.</span> <span class="toc-text">二、递归遍历目录</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#io%E6%B5%81"><span class="toc-number">26.</span> <span class="toc-text">IO 流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-io%E6%B5%81%E6%A6%82%E8%BF%B0%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-number">26.1.</span> <span class="toc-text">一、 IO 流概述和分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%AD%97%E8%8A%82%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-number">26.2.</span> <span class="toc-text">二、字节流写数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%AD%97%E8%8A%82%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">26.3.</span> <span class="toc-text">三、字节流写数据的三种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%AD%97%E8%8A%82%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98"><span class="toc-number">26.4.</span> <span class="toc-text">四、字节流写数据的两个小问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E5%AD%97%E8%8A%82%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">26.5.</span> <span class="toc-text">五、字节流写数据加异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E6%95%B0%E6%8D%AE%E4%B8%80%E6%AC%A1%E8%AF%BB%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE"><span class="toc-number">26.6.</span> <span class="toc-text">六、字节流读数据 (一次读一个字节数据)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E6%95%B0%E6%8D%AE%E4%B8%80%E6%AC%A1%E8%AF%BB%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E6%95%B0%E6%8D%AE"><span class="toc-number">26.7.</span> <span class="toc-text">七、字节流读数据 (一次读一个字节数组数据)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">26.8.</span> <span class="toc-text">八、字节缓冲流构造方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">27.</span> <span class="toc-text">字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">27.1.</span> <span class="toc-text">一、为什么会出现字符流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%BC%96%E7%A0%81%E8%A1%A8"><span class="toc-number">27.2.</span> <span class="toc-text">二、编码表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E9%97%AE%E9%A2%98"><span class="toc-number">27.3.</span> <span class="toc-text">三、字符串中的编码解码问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E9%97%AE%E9%A2%98"><span class="toc-number">27.4.</span> <span class="toc-text">四、字符流中的编码解码问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E5%AD%97%E7%AC%A6%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%845%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">27.5.</span> <span class="toc-text">五、字符流写数据的 5 种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E5%AD%97%E7%AC%A6%E6%B5%81%E8%AF%BB%E6%95%B0%E6%8D%AE%E7%9A%842%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">27.6.</span> <span class="toc-text">六、字符流读数据的 2 种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E4%BE%BF%E6%8D%B7%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="toc-number">27.7.</span> <span class="toc-text">七、便捷流对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">27.8.</span> <span class="toc-text">八、字符缓冲流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D-%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%E7%89%B9%E6%9C%89%E5%8A%9F%E8%83%BD"><span class="toc-number">27.9.</span> <span class="toc-text">九、字符缓冲流特有功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81-io%E6%B5%81%E5%B0%8F%E7%BB%93"><span class="toc-number">27.10.</span> <span class="toc-text">十、IO 流小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#io%E7%89%B9%E6%AE%8A%E6%93%8D%E4%BD%9C%E6%B5%81"><span class="toc-number">28.</span> <span class="toc-text">IO 特殊操作流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">28.1.</span> <span class="toc-text">一、标准输入流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">28.2.</span> <span class="toc-text">二、标准输出流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%AD%97%E8%8A%82%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">28.3.</span> <span class="toc-text">三、字节打印流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%AD%97%E7%AC%A6%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">28.4.</span> <span class="toc-text">四、字符打印流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81"><span class="toc-number">28.5.</span> <span class="toc-text">五、对象序列化流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E5%AF%B9%E8%B1%A1%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81"><span class="toc-number">28.6.</span> <span class="toc-text">六、对象反序列化流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-serialversionuidtransient"><span class="toc-number">28.7.</span> <span class="toc-text">七、serialVersionUID&amp;transient</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#properties%E9%9B%86%E5%90%88"><span class="toc-number">29.</span> <span class="toc-text">Properties 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-properties%E4%BD%9C%E4%B8%BAmap%E9%9B%86%E5%90%88%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">29.1.</span> <span class="toc-text">一、Properties 作为 Map 集合的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-properties%E4%BD%9C%E4%B8%BAmap%E9%9B%86%E5%90%88%E7%9A%84%E7%89%B9%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">29.2.</span> <span class="toc-text">二、Properties 作为 Map 集合的特有方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-properties%E5%92%8Cio%E6%B5%81%E7%9B%B8%E7%BB%93%E5%90%88%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">29.3.</span> <span class="toc-text">三、Properties 和 IO 流相结合的方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">30.</span> <span class="toc-text">实现多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">30.1.</span> <span class="toc-text">一、进程和线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F%E4%B8%80%E7%BB%A7%E6%89%BFthread%E7%B1%BB"><span class="toc-number">30.2.</span> <span class="toc-text">二、实现多线程方式一：继承 Thread 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E5%90%8D%E7%A7%B0"><span class="toc-number">30.3.</span> <span class="toc-text">三、设置和获取线程名称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">30.4.</span> <span class="toc-text">四、线程优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">30.5.</span> <span class="toc-text">五、线程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">30.6.</span> <span class="toc-text">六、线程的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%B9%E5%BC%8F%E4%BA%8C%E5%AE%9E%E7%8E%B0runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">30.7.</span> <span class="toc-text">七、实现多线程方式二：实现 Runnable 接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">31.</span> <span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%8D%96%E7%A5%A8"><span class="toc-number">31.1.</span> <span class="toc-text">一、卖票</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%8D%96%E7%A5%A8%E6%A1%88%E4%BE%8B%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">31.2.</span> <span class="toc-text">二、卖票案例的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">31.3.</span> <span class="toc-text">三、同步代码块解决数据安全问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">31.4.</span> <span class="toc-text">四、同步方法解决数据安全问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">31.5.</span> <span class="toc-text">五、线程安全的类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-lock%E9%94%81"><span class="toc-number">31.6.</span> <span class="toc-text">六、Lock 锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">32.</span> <span class="toc-text">生产者消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0"><span class="toc-number">32.1.</span> <span class="toc-text">一、生产者和消费者模式概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A1%88%E4%BE%8B"><span class="toc-number">32.2.</span> <span class="toc-text">二、生产者和消费者案例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8"><span class="toc-number">33.</span> <span class="toc-text">网络编程入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">33.1.</span> <span class="toc-text">一、网络编程概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">33.2.</span> <span class="toc-text">二、网络编程三要素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-ip%E5%9C%B0%E5%9D%80"><span class="toc-number">33.3.</span> <span class="toc-text">三、IP 地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-inetaddress"><span class="toc-number">33.4.</span> <span class="toc-text">四、InetAddress</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E7%AB%AF%E5%8F%A3%E5%92%8C%E5%8D%8F%E8%AE%AE"><span class="toc-number">33.5.</span> <span class="toc-text">五、端口和协议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#udp%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F"><span class="toc-number">34.</span> <span class="toc-text">UDP 通信程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-udp%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-number">34.1.</span> <span class="toc-text">一、UDP 发送数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-udp%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">34.2.</span> <span class="toc-text">二、UDP 接收数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcp%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F"><span class="toc-number">35.</span> <span class="toc-text">TCP 通信程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-tcp%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-number">35.1.</span> <span class="toc-text">一、TCP 发送数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-tcp%E6%8E%A5%E6%94%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">35.2.</span> <span class="toc-text">二、TCP 接收数据</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">36.</span> <span class="toc-text">Lambda 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E4%BD%93%E9%AA%8Clambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">36.1.</span> <span class="toc-text">一、体验 Lambda 表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F"><span class="toc-number">36.2.</span> <span class="toc-text">二、Lambda 表达式的标准格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%83%E4%B9%A01"><span class="toc-number">36.3.</span> <span class="toc-text">三、Lambda 表达式练习 1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%83%E4%B9%A02"><span class="toc-number">36.4.</span> <span class="toc-text">四、Lambda 表达式练习 2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%BB%83%E4%B9%A03"><span class="toc-number">36.5.</span> <span class="toc-text">五、Lambda 表达式练习 3</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%9C%81%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">36.6.</span> <span class="toc-text">六、Lambda 表达式的省略模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">36.7.</span> <span class="toc-text">七、Lambda 表达式的注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">36.8.</span> <span class="toc-text">八、Lambda 表达式和匿名内部类的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%BB%84%E6%88%90%E6%9B%B4%E6%96%B0"><span class="toc-number">37.</span> <span class="toc-text">接口组成更新</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E6%8E%A5%E5%8F%A3%E7%BB%84%E6%88%90%E6%9B%B4%E6%96%B0%E6%A6%82%E8%BF%B0"><span class="toc-number">37.1.</span> <span class="toc-text">一、接口组成更新概述‘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">37.2.</span> <span class="toc-text">二、接口中默认方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">37.3.</span> <span class="toc-text">三、接口中静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">37.4.</span> <span class="toc-text">四、接口中私有方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">38.</span> <span class="toc-text">方法引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E4%BD%93%E9%AA%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">38.1.</span> <span class="toc-text">一、体验方法引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%AC%A6"><span class="toc-number">38.2.</span> <span class="toc-text">二、方法引用符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%BC%95%E7%94%A8%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">38.3.</span> <span class="toc-text">三、引用类方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">38.4.</span> <span class="toc-text">四、引用对象的实例方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E5%BC%95%E7%94%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">38.5.</span> <span class="toc-text">五、引用类的实例方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E5%BC%95%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">38.6.</span> <span class="toc-text">六、引用构造器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">39.</span> <span class="toc-text">函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="toc-number">39.1.</span> <span class="toc-text">一、函数式接口概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">39.2.</span> <span class="toc-text">二、函数式接口作为方法的参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">39.3.</span> <span class="toc-text">三、函数式接口作为方法的返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%B9%8Bsupplier"><span class="toc-number">39.4.</span> <span class="toc-text">四、常用函数式接口之 Supplier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%B9%8Bconsumer"><span class="toc-number">39.5.</span> <span class="toc-text">五、常用函数式接口之 Consumer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%B9%8Bpredicate"><span class="toc-number">39.6.</span> <span class="toc-text">六、常用函数式接口之 Predicate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%B9%8Bfunction"><span class="toc-number">39.7.</span> <span class="toc-text">七、常用函数式接口之 Function</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#stream%E6%B5%81"><span class="toc-number">40.</span> <span class="toc-text">Stream 流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E4%BD%93%E9%AA%8Cstream%E6%B5%81"><span class="toc-number">40.1.</span> <span class="toc-text">一、体验 Stream 流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-stream%E6%B5%81%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F"><span class="toc-number">40.2.</span> <span class="toc-text">二、Stream 流的常见生成方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-stream%E6%B5%81%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">40.3.</span> <span class="toc-text">三、Stream 流中间操作方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-stream%E6%B5%81%E7%BB%88%E7%BB%93%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">40.4.</span> <span class="toc-text">四、Stream 流终结操作方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-stream%E6%B5%81%E7%9A%84%E6%94%B6%E9%9B%86%E6%93%8D%E4%BD%9C"><span class="toc-number">40.5.</span> <span class="toc-text">五、Stream 流的收集操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">41.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">41.1.</span> <span class="toc-text">一、类加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">41.2.</span> <span class="toc-text">二、类加载器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">42.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%8F%8D%E5%B0%84%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="toc-number">42.1.</span> <span class="toc-text">一、反射的概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E8%8E%B7%E5%8F%96class%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">42.2.</span> <span class="toc-text">二、获取 Class 类对象的三种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%B9%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">42.3.</span> <span class="toc-text">三、反射获取构造方法并使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%B9%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">42.4.</span> <span class="toc-text">四、反射获取成员变量并使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E5%B9%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">42.5.</span> <span class="toc-text">五、反射获取成员方法并使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E5%8F%8D%E5%B0%84%E7%BB%83%E4%B9%A0%E4%B9%8B%E8%B6%8A%E8%BF%87%E6%B3%9B%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-number">42.6.</span> <span class="toc-text">六、反射练习之越过泛型检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E8%BF%90%E8%A1%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E6%8C%87%E5%AE%9A%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E6%96%B9%E6%B3%95"><span class="toc-number">42.7.</span> <span class="toc-text">七、运行配置文件中指定类的指定方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">43.</span> <span class="toc-text">模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E6%A8%A1%E5%9D%97%E5%8C%96%E6%A6%82%E8%BF%B0"><span class="toc-number">43.1.</span> <span class="toc-text">一、模块化概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">43.2.</span> <span class="toc-text">二、模块的基本使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E6%A8%A1%E5%9D%97%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">43.3.</span> <span class="toc-text">三、模块服务的基本使用</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="KangKang" data-src="/images/avatar.jpg"><p class="name" itemprop="name">KangKang</p><div class="description" itemprop="description"></div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">12</span> <span class="name">文章</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tLzBrYW5na2FuZzA=" title="https:&#x2F;&#x2F;github.com&#x2F;0kangkang0"><i class="ic i-github"></i></span> <span class="exturl item csdn" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1MTY2NjU1" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_15166655"><i class="ic i-csdn"></i></span> <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9rYW5na2FuZy02OC0xOC04OQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;kangkang-68-18-89"><i class="ic i-zhihu"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTE2MjE4MTczMjA=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;1621817320"><i class="ic i-cloud-music"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/07/11/spring%E9%AB%98%E7%BA%A7/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/07/23/JavaWeb/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/23/JavaWeb/" title="JavaWeb">JavaWeb</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/12/25/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/" title="软件测试基本原理与实践">软件测试基本原理与实践</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/09/02/SpringBoot%E8%AE%B2%E4%B9%89/" title="springboot2">springboot2</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/11/06/AJAX+Node.js+Webpack/" title="AJAX+Node.js+Webpack">AJAX+Node.js+Webpack</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/12/10/UML%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90%E3%80%81%E5%BB%BA%E6%A8%A1%E4%B8%8E%E8%AE%BE%E8%AE%A1/" title="UML面向对象分析、建模与设计">UML面向对象分析、建模与设计</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/11/hello-world/" title="Hello World">Hello World</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/12/Java/" title="Java">Java</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/12/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2023/07/11/MybatisPlus/" title="MybatisPlus">MybatisPlus</a></span></li><li class="item"><div class="breadcrumb"></div><span><a href="/2024/01/01/Linux/" title="Linux">Linux</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">KangKang @ kangkang</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">1.2m 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">18:32</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div><div class="beian"><a href="https://beian.miit.gov.cn/" target="_blank">闽ICP备2023012662号</a></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/07/12/Java/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="/js/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->